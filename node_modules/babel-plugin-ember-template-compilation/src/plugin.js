"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const babel_import_util_1 = require("babel-import-util");
const expression_parser_1 = require("./expression-parser");
const INLINE_PRECOMPILE_MODULES = [
    {
        moduleName: 'ember-cli-htmlbars',
        export: 'hbs',
        allowTemplateLiteral: true,
        enableScope: false,
    },
    {
        moduleName: 'ember-cli-htmlbars-inline-precompile',
        export: 'default',
        allowTemplateLiteral: true,
        enableScope: false,
    },
    {
        moduleName: 'htmlbars-inline-precompile',
        export: 'default',
        allowTemplateLiteral: true,
        enableScope: false,
    },
    {
        moduleName: '@ember/template-compilation',
        export: 'precompileTemplate',
        allowTemplateLiteral: false,
        enableScope: true,
    },
];
function makePlugin(
// receives the Babel plugin options, returns Ember's precompiler
loadPrecompiler) {
    return function htmlbarsInlinePrecompile(babel) {
        let t = babel.types;
        function insertCompiledTemplate(target, state, template, userTypedOptions) {
            let options = Object.assign({ contents: template }, userTypedOptions);
            let precompile = state.precompile;
            let precompileResultString;
            if (options.insertRuntimeErrors) {
                try {
                    precompileResultString = precompile(template, options);
                }
                catch (error) {
                    target.replaceWith(runtimeErrorIIFE(babel, { ERROR_MESSAGE: error.message }));
                    return;
                }
            }
            else {
                precompileResultString = precompile(template, options);
            }
            let precompileResultAST = babel.parse(`var precompileResult = ${precompileResultString};`, {
                babelrc: false,
                configFile: false,
            });
            let templateExpression = precompileResultAST.program.body[0]
                .declarations[0].init;
            t.addComment(templateExpression, 'leading', `\n  ${template.replace(/\*\//g, '*\\/')}\n`, 
            /* line comment? */ false);
            let templateFactoryIdentifier = state.util.import(target, state.templateFactory.moduleName, state.templateFactory.exportName);
            target.replaceWith(t.callExpression(templateFactoryIdentifier, [templateExpression]));
        }
        return {
            visitor: {
                Program: {
                    enter(path, state) {
                        var _a, _b;
                        let moduleName = '@ember/template-factory';
                        let exportName = 'createTemplateFactory';
                        let overrides = (_b = (_a = state.opts.outputModuleOverrides) === null || _a === void 0 ? void 0 : _a[moduleName]) === null || _b === void 0 ? void 0 : _b[exportName];
                        state.templateFactory = overrides
                            ? { exportName: overrides[0], moduleName: overrides[1] }
                            : { exportName, moduleName };
                        state.util = new babel_import_util_1.ImportUtil(t, path);
                        state.precompile = loadPrecompiler(state.opts);
                    },
                    exit(_path, state) {
                        for (let { moduleName, export: exportName } of configuredModules(state)) {
                            state.util.removeImport(moduleName, exportName);
                        }
                    },
                },
                TaggedTemplateExpression(path, state) {
                    let tagPath = path.get('tag');
                    if (!tagPath.isIdentifier()) {
                        return;
                    }
                    let options = referencesInlineCompiler(tagPath, state);
                    if (!options) {
                        return;
                    }
                    if (!options.allowTemplateLiteral) {
                        throw path.buildCodeFrameError(`Attempted to use \`${tagPath.node.name}\` as a template tag, but it can only be called as a function with a string passed to it: ${tagPath.node.name}('content here')`);
                    }
                    if (path.node.quasi.expressions.length) {
                        throw path.buildCodeFrameError('placeholders inside a tagged template string are not supported');
                    }
                    let template = path.node.quasi.quasis.map((quasi) => quasi.value.cooked).join('');
                    insertCompiledTemplate(path, state, template, {});
                },
                CallExpression(path, state) {
                    let calleePath = path.get('callee');
                    if (!calleePath.isIdentifier()) {
                        return;
                    }
                    let options = referencesInlineCompiler(calleePath, state);
                    if (!options) {
                        return;
                    }
                    let [firstArg, secondArg, ...restArgs] = path.get('arguments');
                    let template;
                    switch (firstArg === null || firstArg === void 0 ? void 0 : firstArg.node.type) {
                        case 'StringLiteral':
                            template = firstArg.node.value;
                            break;
                        case 'TemplateLiteral':
                            if (firstArg.node.expressions.length) {
                                throw path.buildCodeFrameError('placeholders inside a template string are not supported');
                            }
                            else {
                                template = firstArg.node.quasis.map((quasi) => quasi.value.cooked).join('');
                            }
                            break;
                        case 'TaggedTemplateExpression':
                            throw path.buildCodeFrameError(`tagged template strings inside ${calleePath.node.name} are not supported`);
                        default:
                            throw path.buildCodeFrameError(`${calleePath.node.name} should be invoked with at least a single argument (the template string)`);
                    }
                    let userTypedOptions;
                    if (!secondArg) {
                        userTypedOptions = {};
                    }
                    else {
                        if (!secondArg.isObjectExpression()) {
                            throw path.buildCodeFrameError(`${calleePath.node.name} can only be invoked with 2 arguments: the template string, and any static options`);
                        }
                        userTypedOptions = new expression_parser_1.ExpressionParser(babel).parseObjectExpression(calleePath.node.name, secondArg, true);
                    }
                    if (restArgs.length > 0) {
                        throw path.buildCodeFrameError(`${calleePath.node.name} can only be invoked with 2 arguments: the template string, and any static options`);
                    }
                    insertCompiledTemplate(path, state, template, userTypedOptions);
                },
            },
        };
    };
}
exports.default = makePlugin;
function* configuredModules(state) {
    var _a;
    for (let moduleConfig of INLINE_PRECOMPILE_MODULES) {
        if (moduleConfig.moduleName !== '@ember/template-compilation' &&
            !((_a = state.opts.enableLegacyModules) === null || _a === void 0 ? void 0 : _a.includes(moduleConfig.moduleName))) {
            continue;
        }
        yield moduleConfig;
    }
}
function referencesInlineCompiler(path, state) {
    for (let moduleConfig of configuredModules(state)) {
        if (path.referencesImport(moduleConfig.moduleName, moduleConfig.export)) {
            return moduleConfig;
        }
    }
    return undefined;
}
function runtimeErrorIIFE(babel, replacements) {
    let statement = babel.template(`(function() {\n  throw new Error('ERROR_MESSAGE');\n})();`)(replacements);
    return statement.expression;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGx1Z2luLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGx1Z2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBR0EseURBQStDO0FBQy9DLDJEQUF1RDtBQWtCdkQsTUFBTSx5QkFBeUIsR0FBbUI7SUFDaEQ7UUFDRSxVQUFVLEVBQUUsb0JBQW9CO1FBQ2hDLE1BQU0sRUFBRSxLQUFLO1FBQ2Isb0JBQW9CLEVBQUUsSUFBSTtRQUMxQixXQUFXLEVBQUUsS0FBSztLQUNuQjtJQUNEO1FBQ0UsVUFBVSxFQUFFLHNDQUFzQztRQUNsRCxNQUFNLEVBQUUsU0FBUztRQUNqQixvQkFBb0IsRUFBRSxJQUFJO1FBQzFCLFdBQVcsRUFBRSxLQUFLO0tBQ25CO0lBQ0Q7UUFDRSxVQUFVLEVBQUUsNEJBQTRCO1FBQ3hDLE1BQU0sRUFBRSxTQUFTO1FBQ2pCLG9CQUFvQixFQUFFLElBQUk7UUFDMUIsV0FBVyxFQUFFLEtBQUs7S0FDbkI7SUFDRDtRQUNFLFVBQVUsRUFBRSw2QkFBNkI7UUFDekMsTUFBTSxFQUFFLG9CQUFvQjtRQUM1QixvQkFBb0IsRUFBRSxLQUFLO1FBQzNCLFdBQVcsRUFBRSxJQUFJO0tBQ2xCO0NBQ0YsQ0FBQztBQWtDRixTQUF3QixVQUFVO0FBQ2hDLGlFQUFpRTtBQUNqRSxlQUE2QztJQUU3QyxPQUFPLFNBQVMsd0JBQXdCLENBQUMsS0FBbUI7UUFDMUQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQztRQUVwQixTQUFTLHNCQUFzQixDQUM3QixNQUF3QixFQUN4QixLQUFZLEVBQ1osUUFBZ0IsRUFDaEIsZ0JBQXlDO1lBRXpDLElBQUksT0FBTyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztZQUN0RSxJQUFJLFVBQVUsR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDO1lBQ2xDLElBQUksc0JBQThCLENBQUM7WUFFbkMsSUFBSSxPQUFPLENBQUMsbUJBQW1CLEVBQUU7Z0JBQy9CLElBQUk7b0JBQ0Ysc0JBQXNCLEdBQUcsVUFBVSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztpQkFDeEQ7Z0JBQUMsT0FBTyxLQUFLLEVBQUU7b0JBQ2QsTUFBTSxDQUFDLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsRUFBRSxhQUFhLEVBQUcsS0FBYSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFDdkYsT0FBTztpQkFDUjthQUNGO2lCQUFNO2dCQUNMLHNCQUFzQixHQUFHLFVBQVUsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFDeEQ7WUFFRCxJQUFJLG1CQUFtQixHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsMEJBQTBCLHNCQUFzQixHQUFHLEVBQUU7Z0JBQ3pGLE9BQU8sRUFBRSxLQUFLO2dCQUNkLFVBQVUsRUFBRSxLQUFLO2FBQ2xCLENBQVcsQ0FBQztZQUViLElBQUksa0JBQWtCLEdBQUksbUJBQW1CLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQTJCO2lCQUNwRixZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBb0IsQ0FBQztZQUV4QyxDQUFDLENBQUMsVUFBVSxDQUNWLGtCQUFrQixFQUNsQixTQUFTLEVBQ1QsT0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsSUFBSTtZQUM1QyxtQkFBbUIsQ0FBQyxLQUFLLENBQzFCLENBQUM7WUFFRixJQUFJLHlCQUF5QixHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUMvQyxNQUFNLEVBQ04sS0FBSyxDQUFDLGVBQWUsQ0FBQyxVQUFVLEVBQ2hDLEtBQUssQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUNqQyxDQUFDO1lBQ0YsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLHlCQUF5QixFQUFFLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDeEYsQ0FBQztRQUVELE9BQU87WUFDTCxPQUFPLEVBQUU7Z0JBQ1AsT0FBTyxFQUFFO29CQUNQLEtBQUssQ0FBQyxJQUF5QixFQUFFLEtBQVk7O3dCQUMzQyxJQUFJLFVBQVUsR0FBRyx5QkFBeUIsQ0FBQzt3QkFDM0MsSUFBSSxVQUFVLEdBQUcsdUJBQXVCLENBQUM7d0JBQ3pDLElBQUksU0FBUyxHQUFHLE1BQUEsTUFBQSxLQUFLLENBQUMsSUFBSSxDQUFDLHFCQUFxQiwwQ0FBRyxVQUFVLENBQUMsMENBQUcsVUFBVSxDQUFDLENBQUM7d0JBQzdFLEtBQUssQ0FBQyxlQUFlLEdBQUcsU0FBUzs0QkFDL0IsQ0FBQyxDQUFDLEVBQUUsVUFBVSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFVLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFOzRCQUN4RCxDQUFDLENBQUMsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLENBQUM7d0JBQy9CLEtBQUssQ0FBQyxJQUFJLEdBQUcsSUFBSSw4QkFBVSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQzt3QkFDckMsS0FBSyxDQUFDLFVBQVUsR0FBRyxlQUFlLENBQUMsS0FBSyxDQUFDLElBQVMsQ0FBQyxDQUFDO29CQUN0RCxDQUFDO29CQUNELElBQUksQ0FBQyxLQUEwQixFQUFFLEtBQVk7d0JBQzNDLEtBQUssSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLElBQUksaUJBQWlCLENBQUMsS0FBSyxDQUFDLEVBQUU7NEJBQ3ZFLEtBQUssQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsRUFBRSxVQUFVLENBQUMsQ0FBQzt5QkFDakQ7b0JBQ0gsQ0FBQztpQkFDRjtnQkFFRCx3QkFBd0IsQ0FBQyxJQUEwQyxFQUFFLEtBQVk7b0JBQy9FLElBQUksT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBRTlCLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFLEVBQUU7d0JBQzNCLE9BQU87cUJBQ1I7b0JBQ0QsSUFBSSxPQUFPLEdBQUcsd0JBQXdCLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO29CQUN2RCxJQUFJLENBQUMsT0FBTyxFQUFFO3dCQUNaLE9BQU87cUJBQ1I7b0JBRUQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxvQkFBb0IsRUFBRTt3QkFDakMsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQzVCLHNCQUFzQixPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksNkZBQTZGLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxrQkFBa0IsQ0FDeEssQ0FBQztxQkFDSDtvQkFFRCxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUU7d0JBQ3RDLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixDQUM1QixnRUFBZ0UsQ0FDakUsQ0FBQztxQkFDSDtvQkFFRCxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDbEYsc0JBQXNCLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQ3BELENBQUM7Z0JBRUQsY0FBYyxDQUFDLElBQWdDLEVBQUUsS0FBWTtvQkFDM0QsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztvQkFFcEMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLEVBQUUsRUFBRTt3QkFDOUIsT0FBTztxQkFDUjtvQkFDRCxJQUFJLE9BQU8sR0FBRyx3QkFBd0IsQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDLENBQUM7b0JBQzFELElBQUksQ0FBQyxPQUFPLEVBQUU7d0JBQ1osT0FBTztxQkFDUjtvQkFFRCxJQUFJLENBQUMsUUFBUSxFQUFFLFNBQVMsRUFBRSxHQUFHLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7b0JBRS9ELElBQUksUUFBUSxDQUFDO29CQUViLFFBQVEsUUFBUSxhQUFSLFFBQVEsdUJBQVIsUUFBUSxDQUFFLElBQUksQ0FBQyxJQUFJLEVBQUU7d0JBQzNCLEtBQUssZUFBZTs0QkFDbEIsUUFBUSxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDOzRCQUMvQixNQUFNO3dCQUNSLEtBQUssaUJBQWlCOzRCQUNwQixJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRTtnQ0FDcEMsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQzVCLHlEQUF5RCxDQUMxRCxDQUFDOzZCQUNIO2lDQUFNO2dDQUNMLFFBQVEsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDOzZCQUM3RTs0QkFDRCxNQUFNO3dCQUNSLEtBQUssMEJBQTBCOzRCQUM3QixNQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FDNUIsa0NBQWtDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxvQkFBb0IsQ0FDM0UsQ0FBQzt3QkFDSjs0QkFDRSxNQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FDNUIsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksMEVBQTBFLENBQ2xHLENBQUM7cUJBQ0w7b0JBRUQsSUFBSSxnQkFBeUMsQ0FBQztvQkFFOUMsSUFBSSxDQUFDLFNBQVMsRUFBRTt3QkFDZCxnQkFBZ0IsR0FBRyxFQUFFLENBQUM7cUJBQ3ZCO3lCQUFNO3dCQUNMLElBQUksQ0FBQyxTQUFTLENBQUMsa0JBQWtCLEVBQUUsRUFBRTs0QkFDbkMsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQzVCLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLG9GQUFvRixDQUM1RyxDQUFDO3lCQUNIO3dCQUVELGdCQUFnQixHQUFHLElBQUksb0NBQWdCLENBQUMsS0FBSyxDQUFDLENBQUMscUJBQXFCLENBQ2xFLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUNwQixTQUFTLEVBQ1QsSUFBSSxDQUNMLENBQUM7cUJBQ0g7b0JBQ0QsSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTt3QkFDdkIsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQzVCLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLG9GQUFvRixDQUM1RyxDQUFDO3FCQUNIO29CQUNELHNCQUFzQixDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLGdCQUFnQixDQUFDLENBQUM7Z0JBQ2xFLENBQUM7YUFDRjtTQUNGLENBQUM7SUFDSixDQUFDLENBQUM7QUFDSixDQUFDO0FBbktELDZCQW1LQztBQUVELFFBQVEsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLEtBQVk7O0lBQ3RDLEtBQUssSUFBSSxZQUFZLElBQUkseUJBQXlCLEVBQUU7UUFDbEQsSUFDRSxZQUFZLENBQUMsVUFBVSxLQUFLLDZCQUE2QjtZQUN6RCxDQUFDLENBQUEsTUFBQSxLQUFLLENBQUMsSUFBSSxDQUFDLG1CQUFtQiwwQ0FBRSxRQUFRLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFBLEVBQ2xFO1lBQ0EsU0FBUztTQUNWO1FBQ0QsTUFBTSxZQUFZLENBQUM7S0FDcEI7QUFDSCxDQUFDO0FBRUQsU0FBUyx3QkFBd0IsQ0FDL0IsSUFBNEIsRUFDNUIsS0FBWTtJQUVaLEtBQUssSUFBSSxZQUFZLElBQUksaUJBQWlCLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDakQsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxDQUFDLFVBQVUsRUFBRSxZQUFZLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDdkUsT0FBTyxZQUFZLENBQUM7U0FDckI7S0FDRjtJQUNELE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUM7QUFFRCxTQUFTLGdCQUFnQixDQUFDLEtBQW1CLEVBQUUsWUFBdUM7SUFDcEYsSUFBSSxTQUFTLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQywyREFBMkQsQ0FBQyxDQUN6RixZQUFZLENBQ1ksQ0FBQztJQUMzQixPQUFPLFNBQVMsQ0FBQyxVQUFVLENBQUM7QUFDOUIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgTm9kZVBhdGggfSBmcm9tICdAYmFiZWwvdHJhdmVyc2UnO1xuaW1wb3J0IHR5cGUgKiBhcyBCYWJlbCBmcm9tICdAYmFiZWwvY29yZSc7XG5pbXBvcnQgdHlwZSB7IHR5cGVzIGFzIHQgfSBmcm9tICdAYmFiZWwvY29yZSc7XG5pbXBvcnQgeyBJbXBvcnRVdGlsIH0gZnJvbSAnYmFiZWwtaW1wb3J0LXV0aWwnO1xuaW1wb3J0IHsgRXhwcmVzc2lvblBhcnNlciB9IGZyb20gJy4vZXhwcmVzc2lvbi1wYXJzZXInO1xuXG5leHBvcnQgdHlwZSBFbWJlclByZWNvbXBpbGUgPSAodGVtcGxhdGVTdHJpbmc6IHN0cmluZywgb3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pID0+IHN0cmluZztcblxuZXhwb3J0IHR5cGUgTGVnYWN5TW9kdWxlTmFtZSA9XG4gIHwgJ2VtYmVyLWNsaS1odG1sYmFycydcbiAgfCAnZW1iZXItY2xpLWh0bWxiYXJzLWlubGluZS1wcmVjb21waWxlJ1xuICB8ICdodG1sYmFycy1pbmxpbmUtcHJlY29tcGlsZSc7XG5cbnR5cGUgTW9kdWxlTmFtZSA9IExlZ2FjeU1vZHVsZU5hbWUgfCAnQGVtYmVyL3RlbXBsYXRlLWNvbXBpbGF0aW9uJztcblxuaW50ZXJmYWNlIE1vZHVsZUNvbmZpZyB7XG4gIG1vZHVsZU5hbWU6IE1vZHVsZU5hbWU7XG4gIGV4cG9ydDogc3RyaW5nO1xuICBhbGxvd1RlbXBsYXRlTGl0ZXJhbDogYm9vbGVhbjtcbiAgZW5hYmxlU2NvcGU6IGJvb2xlYW47XG59XG5cbmNvbnN0IElOTElORV9QUkVDT01QSUxFX01PRFVMRVM6IE1vZHVsZUNvbmZpZ1tdID0gW1xuICB7XG4gICAgbW9kdWxlTmFtZTogJ2VtYmVyLWNsaS1odG1sYmFycycsXG4gICAgZXhwb3J0OiAnaGJzJyxcbiAgICBhbGxvd1RlbXBsYXRlTGl0ZXJhbDogdHJ1ZSxcbiAgICBlbmFibGVTY29wZTogZmFsc2UsXG4gIH0sXG4gIHtcbiAgICBtb2R1bGVOYW1lOiAnZW1iZXItY2xpLWh0bWxiYXJzLWlubGluZS1wcmVjb21waWxlJyxcbiAgICBleHBvcnQ6ICdkZWZhdWx0JyxcbiAgICBhbGxvd1RlbXBsYXRlTGl0ZXJhbDogdHJ1ZSxcbiAgICBlbmFibGVTY29wZTogZmFsc2UsXG4gIH0sXG4gIHtcbiAgICBtb2R1bGVOYW1lOiAnaHRtbGJhcnMtaW5saW5lLXByZWNvbXBpbGUnLFxuICAgIGV4cG9ydDogJ2RlZmF1bHQnLFxuICAgIGFsbG93VGVtcGxhdGVMaXRlcmFsOiB0cnVlLFxuICAgIGVuYWJsZVNjb3BlOiBmYWxzZSxcbiAgfSxcbiAge1xuICAgIG1vZHVsZU5hbWU6ICdAZW1iZXIvdGVtcGxhdGUtY29tcGlsYXRpb24nLFxuICAgIGV4cG9ydDogJ3ByZWNvbXBpbGVUZW1wbGF0ZScsXG4gICAgYWxsb3dUZW1wbGF0ZUxpdGVyYWw6IGZhbHNlLFxuICAgIGVuYWJsZVNjb3BlOiB0cnVlLFxuICB9LFxuXTtcblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zIHtcbiAgLy8gQWxsb3dzIHlvdSB0byByZW1hcCB3aGF0IGltcG9ydHMgd2lsbCBiZSBlbWl0dGVkIGluIG91ciBjb21waWxlZCBvdXRwdXQuIEJ5XG4gIC8vIGV4YW1wbGU6XG4gIC8vXG4gIC8vICAgb3V0cHV0TW9kdWxlT3ZlcnJpZGVzOiB7XG4gIC8vICAgICAnQGVtYmVyL3RlbXBsYXRlLWZhY3RvcnknOiB7XG4gIC8vICAgICAgIGNyZWF0ZVRlbXBsYXRlRmFjdG9yeTogWydjcmVhdGVUZW1wbGF0ZUZhY3RvcnknLCAnQGdsaW1tZXIvY29yZSddLFxuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy9cbiAgLy8gTm9ybWFsIEVtYmVyIGFwcHMgc2hvdWxkbid0IG5lZWQgdGhpcywgaXQgZXhpc3RzIHRvIHN1cHBvcnQgb3RoZXJcbiAgLy8gZW52aXJvbm1lbnRzIGxpa2Ugc3RhbmRhbG9uZSBHbGltbWVySlNcbiAgb3V0cHV0TW9kdWxlT3ZlcnJpZGVzPzogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgW3N0cmluZywgc3RyaW5nXT4+O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIHRoaXMgcGx1Z2luIGltcGxlbWVudHMgb25seSBFbWJlcidzIHN0YWJsZSBwdWJsaWMgQVBJIGZvclxuICAvLyB0ZW1wbGF0ZSBjb21waWxhdGlvbiwgd2hpY2ggaXM6XG4gIC8vXG4gIC8vICAgIGltcG9ydCB7IHByZWNvbXBpbGVUZW1wbGF0ZSB9IGZyb20gJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxhdGlvbic7XG4gIC8vXG4gIC8vIEJ1dCBoaXN0b3JpY2FsbHkgdGhlcmUgYXJlIHNldmVyYWwgb3RoZXIgaW1wb3J0YWJsZSBzeW50YXhlcyBpbiB3aWRlc3ByZWFkXG4gIC8vIHVzZSwgYW5kIHdlIGNhbiBlbmFibGUgdGhvc2UgdG9vIGJ5IGluY2x1ZGluZyB0aGVpciBtb2R1bGUgbmFtZXMgaW4gdGhpc1xuICAvLyBsaXN0LlxuICBlbmFibGVMZWdhY3lNb2R1bGVzPzogTGVnYWN5TW9kdWxlTmFtZVtdO1xufVxuXG5pbnRlcmZhY2UgU3RhdGUge1xuICBvcHRzOiBPcHRpb25zO1xuICB1dGlsOiBJbXBvcnRVdGlsO1xuICBwcmVjb21waWxlOiBFbWJlclByZWNvbXBpbGU7XG4gIHRlbXBsYXRlRmFjdG9yeTogeyBtb2R1bGVOYW1lOiBzdHJpbmc7IGV4cG9ydE5hbWU6IHN0cmluZyB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYWtlUGx1Z2luPE8+KFxuICAvLyByZWNlaXZlcyB0aGUgQmFiZWwgcGx1Z2luIG9wdGlvbnMsIHJldHVybnMgRW1iZXIncyBwcmVjb21waWxlclxuICBsb2FkUHJlY29tcGlsZXI6IChvcHRzOiBPKSA9PiBFbWJlclByZWNvbXBpbGVcbikge1xuICByZXR1cm4gZnVuY3Rpb24gaHRtbGJhcnNJbmxpbmVQcmVjb21waWxlKGJhYmVsOiB0eXBlb2YgQmFiZWwpOiBCYWJlbC5QbHVnaW5PYmo8U3RhdGU+IHtcbiAgICBsZXQgdCA9IGJhYmVsLnR5cGVzO1xuXG4gICAgZnVuY3Rpb24gaW5zZXJ0Q29tcGlsZWRUZW1wbGF0ZShcbiAgICAgIHRhcmdldDogTm9kZVBhdGg8dC5Ob2RlPixcbiAgICAgIHN0YXRlOiBTdGF0ZSxcbiAgICAgIHRlbXBsYXRlOiBzdHJpbmcsXG4gICAgICB1c2VyVHlwZWRPcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICAgICk6IHZvaWQge1xuICAgICAgbGV0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgY29udGVudHM6IHRlbXBsYXRlIH0sIHVzZXJUeXBlZE9wdGlvbnMpO1xuICAgICAgbGV0IHByZWNvbXBpbGUgPSBzdGF0ZS5wcmVjb21waWxlO1xuICAgICAgbGV0IHByZWNvbXBpbGVSZXN1bHRTdHJpbmc6IHN0cmluZztcblxuICAgICAgaWYgKG9wdGlvbnMuaW5zZXJ0UnVudGltZUVycm9ycykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHByZWNvbXBpbGVSZXN1bHRTdHJpbmcgPSBwcmVjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0YXJnZXQucmVwbGFjZVdpdGgocnVudGltZUVycm9ySUlGRShiYWJlbCwgeyBFUlJPUl9NRVNTQUdFOiAoZXJyb3IgYXMgYW55KS5tZXNzYWdlIH0pKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWNvbXBpbGVSZXN1bHRTdHJpbmcgPSBwcmVjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHByZWNvbXBpbGVSZXN1bHRBU1QgPSBiYWJlbC5wYXJzZShgdmFyIHByZWNvbXBpbGVSZXN1bHQgPSAke3ByZWNvbXBpbGVSZXN1bHRTdHJpbmd9O2AsIHtcbiAgICAgICAgYmFiZWxyYzogZmFsc2UsXG4gICAgICAgIGNvbmZpZ0ZpbGU6IGZhbHNlLFxuICAgICAgfSkgYXMgdC5GaWxlO1xuXG4gICAgICBsZXQgdGVtcGxhdGVFeHByZXNzaW9uID0gKHByZWNvbXBpbGVSZXN1bHRBU1QucHJvZ3JhbS5ib2R5WzBdIGFzIHQuVmFyaWFibGVEZWNsYXJhdGlvbilcbiAgICAgICAgLmRlY2xhcmF0aW9uc1swXS5pbml0IGFzIHQuRXhwcmVzc2lvbjtcblxuICAgICAgdC5hZGRDb21tZW50KFxuICAgICAgICB0ZW1wbGF0ZUV4cHJlc3Npb24sXG4gICAgICAgICdsZWFkaW5nJyxcbiAgICAgICAgYFxcbiAgJHt0ZW1wbGF0ZS5yZXBsYWNlKC9cXCpcXC8vZywgJypcXFxcLycpfVxcbmAsXG4gICAgICAgIC8qIGxpbmUgY29tbWVudD8gKi8gZmFsc2VcbiAgICAgICk7XG5cbiAgICAgIGxldCB0ZW1wbGF0ZUZhY3RvcnlJZGVudGlmaWVyID0gc3RhdGUudXRpbC5pbXBvcnQoXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgc3RhdGUudGVtcGxhdGVGYWN0b3J5Lm1vZHVsZU5hbWUsXG4gICAgICAgIHN0YXRlLnRlbXBsYXRlRmFjdG9yeS5leHBvcnROYW1lXG4gICAgICApO1xuICAgICAgdGFyZ2V0LnJlcGxhY2VXaXRoKHQuY2FsbEV4cHJlc3Npb24odGVtcGxhdGVGYWN0b3J5SWRlbnRpZmllciwgW3RlbXBsYXRlRXhwcmVzc2lvbl0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmlzaXRvcjoge1xuICAgICAgICBQcm9ncmFtOiB7XG4gICAgICAgICAgZW50ZXIocGF0aDogTm9kZVBhdGg8dC5Qcm9ncmFtPiwgc3RhdGU6IFN0YXRlKSB7XG4gICAgICAgICAgICBsZXQgbW9kdWxlTmFtZSA9ICdAZW1iZXIvdGVtcGxhdGUtZmFjdG9yeSc7XG4gICAgICAgICAgICBsZXQgZXhwb3J0TmFtZSA9ICdjcmVhdGVUZW1wbGF0ZUZhY3RvcnknO1xuICAgICAgICAgICAgbGV0IG92ZXJyaWRlcyA9IHN0YXRlLm9wdHMub3V0cHV0TW9kdWxlT3ZlcnJpZGVzPy5bbW9kdWxlTmFtZV0/LltleHBvcnROYW1lXTtcbiAgICAgICAgICAgIHN0YXRlLnRlbXBsYXRlRmFjdG9yeSA9IG92ZXJyaWRlc1xuICAgICAgICAgICAgICA/IHsgZXhwb3J0TmFtZTogb3ZlcnJpZGVzWzBdLCBtb2R1bGVOYW1lOiBvdmVycmlkZXNbMV0gfVxuICAgICAgICAgICAgICA6IHsgZXhwb3J0TmFtZSwgbW9kdWxlTmFtZSB9O1xuICAgICAgICAgICAgc3RhdGUudXRpbCA9IG5ldyBJbXBvcnRVdGlsKHQsIHBhdGgpO1xuICAgICAgICAgICAgc3RhdGUucHJlY29tcGlsZSA9IGxvYWRQcmVjb21waWxlcihzdGF0ZS5vcHRzIGFzIE8pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXhpdChfcGF0aDogTm9kZVBhdGg8dC5Qcm9ncmFtPiwgc3RhdGU6IFN0YXRlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB7IG1vZHVsZU5hbWUsIGV4cG9ydDogZXhwb3J0TmFtZSB9IG9mIGNvbmZpZ3VyZWRNb2R1bGVzKHN0YXRlKSkge1xuICAgICAgICAgICAgICBzdGF0ZS51dGlsLnJlbW92ZUltcG9ydChtb2R1bGVOYW1lLCBleHBvcnROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihwYXRoOiBOb2RlUGF0aDx0LlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbj4sIHN0YXRlOiBTdGF0ZSkge1xuICAgICAgICAgIGxldCB0YWdQYXRoID0gcGF0aC5nZXQoJ3RhZycpO1xuXG4gICAgICAgICAgaWYgKCF0YWdQYXRoLmlzSWRlbnRpZmllcigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBvcHRpb25zID0gcmVmZXJlbmNlc0lubGluZUNvbXBpbGVyKHRhZ1BhdGgsIHN0YXRlKTtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dUZW1wbGF0ZUxpdGVyYWwpIHtcbiAgICAgICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICAgICAgYEF0dGVtcHRlZCB0byB1c2UgXFxgJHt0YWdQYXRoLm5vZGUubmFtZX1cXGAgYXMgYSB0ZW1wbGF0ZSB0YWcsIGJ1dCBpdCBjYW4gb25seSBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbiB3aXRoIGEgc3RyaW5nIHBhc3NlZCB0byBpdDogJHt0YWdQYXRoLm5vZGUubmFtZX0oJ2NvbnRlbnQgaGVyZScpYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aC5ub2RlLnF1YXNpLmV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgICAncGxhY2Vob2xkZXJzIGluc2lkZSBhIHRhZ2dlZCB0ZW1wbGF0ZSBzdHJpbmcgYXJlIG5vdCBzdXBwb3J0ZWQnXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCB0ZW1wbGF0ZSA9IHBhdGgubm9kZS5xdWFzaS5xdWFzaXMubWFwKChxdWFzaSkgPT4gcXVhc2kudmFsdWUuY29va2VkKS5qb2luKCcnKTtcbiAgICAgICAgICBpbnNlcnRDb21waWxlZFRlbXBsYXRlKHBhdGgsIHN0YXRlLCB0ZW1wbGF0ZSwge30pO1xuICAgICAgICB9LFxuXG4gICAgICAgIENhbGxFeHByZXNzaW9uKHBhdGg6IE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+LCBzdGF0ZTogU3RhdGUpIHtcbiAgICAgICAgICBsZXQgY2FsbGVlUGF0aCA9IHBhdGguZ2V0KCdjYWxsZWUnKTtcblxuICAgICAgICAgIGlmICghY2FsbGVlUGF0aC5pc0lkZW50aWZpZXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgb3B0aW9ucyA9IHJlZmVyZW5jZXNJbmxpbmVDb21waWxlcihjYWxsZWVQYXRoLCBzdGF0ZSk7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IFtmaXJzdEFyZywgc2Vjb25kQXJnLCAuLi5yZXN0QXJnc10gPSBwYXRoLmdldCgnYXJndW1lbnRzJyk7XG5cbiAgICAgICAgICBsZXQgdGVtcGxhdGU7XG5cbiAgICAgICAgICBzd2l0Y2ggKGZpcnN0QXJnPy5ub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ1N0cmluZ0xpdGVyYWwnOlxuICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IGZpcnN0QXJnLm5vZGUudmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVGVtcGxhdGVMaXRlcmFsJzpcbiAgICAgICAgICAgICAgaWYgKGZpcnN0QXJnLm5vZGUuZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgICAgICAgJ3BsYWNlaG9sZGVycyBpbnNpZGUgYSB0ZW1wbGF0ZSBzdHJpbmcgYXJlIG5vdCBzdXBwb3J0ZWQnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IGZpcnN0QXJnLm5vZGUucXVhc2lzLm1hcCgocXVhc2kpID0+IHF1YXNpLnZhbHVlLmNvb2tlZCkuam9pbignJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICAgICAgYHRhZ2dlZCB0ZW1wbGF0ZSBzdHJpbmdzIGluc2lkZSAke2NhbGxlZVBhdGgubm9kZS5uYW1lfSBhcmUgbm90IHN1cHBvcnRlZGBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICAgICAgICBgJHtjYWxsZWVQYXRoLm5vZGUubmFtZX0gc2hvdWxkIGJlIGludm9rZWQgd2l0aCBhdCBsZWFzdCBhIHNpbmdsZSBhcmd1bWVudCAodGhlIHRlbXBsYXRlIHN0cmluZylgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHVzZXJUeXBlZE9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuXG4gICAgICAgICAgaWYgKCFzZWNvbmRBcmcpIHtcbiAgICAgICAgICAgIHVzZXJUeXBlZE9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzZWNvbmRBcmcuaXNPYmplY3RFeHByZXNzaW9uKCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgICAgIGAke2NhbGxlZVBhdGgubm9kZS5uYW1lfSBjYW4gb25seSBiZSBpbnZva2VkIHdpdGggMiBhcmd1bWVudHM6IHRoZSB0ZW1wbGF0ZSBzdHJpbmcsIGFuZCBhbnkgc3RhdGljIG9wdGlvbnNgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVzZXJUeXBlZE9wdGlvbnMgPSBuZXcgRXhwcmVzc2lvblBhcnNlcihiYWJlbCkucGFyc2VPYmplY3RFeHByZXNzaW9uKFxuICAgICAgICAgICAgICBjYWxsZWVQYXRoLm5vZGUubmFtZSxcbiAgICAgICAgICAgICAgc2Vjb25kQXJnLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdEFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgICBgJHtjYWxsZWVQYXRoLm5vZGUubmFtZX0gY2FuIG9ubHkgYmUgaW52b2tlZCB3aXRoIDIgYXJndW1lbnRzOiB0aGUgdGVtcGxhdGUgc3RyaW5nLCBhbmQgYW55IHN0YXRpYyBvcHRpb25zYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5zZXJ0Q29tcGlsZWRUZW1wbGF0ZShwYXRoLCBzdGF0ZSwgdGVtcGxhdGUsIHVzZXJUeXBlZE9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiogY29uZmlndXJlZE1vZHVsZXMoc3RhdGU6IFN0YXRlKSB7XG4gIGZvciAobGV0IG1vZHVsZUNvbmZpZyBvZiBJTkxJTkVfUFJFQ09NUElMRV9NT0RVTEVTKSB7XG4gICAgaWYgKFxuICAgICAgbW9kdWxlQ29uZmlnLm1vZHVsZU5hbWUgIT09ICdAZW1iZXIvdGVtcGxhdGUtY29tcGlsYXRpb24nICYmXG4gICAgICAhc3RhdGUub3B0cy5lbmFibGVMZWdhY3lNb2R1bGVzPy5pbmNsdWRlcyhtb2R1bGVDb25maWcubW9kdWxlTmFtZSlcbiAgICApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB5aWVsZCBtb2R1bGVDb25maWc7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVmZXJlbmNlc0lubGluZUNvbXBpbGVyKFxuICBwYXRoOiBOb2RlUGF0aDx0LklkZW50aWZpZXI+LFxuICBzdGF0ZTogU3RhdGVcbik6IE1vZHVsZUNvbmZpZyB8IHVuZGVmaW5lZCB7XG4gIGZvciAobGV0IG1vZHVsZUNvbmZpZyBvZiBjb25maWd1cmVkTW9kdWxlcyhzdGF0ZSkpIHtcbiAgICBpZiAocGF0aC5yZWZlcmVuY2VzSW1wb3J0KG1vZHVsZUNvbmZpZy5tb2R1bGVOYW1lLCBtb2R1bGVDb25maWcuZXhwb3J0KSkge1xuICAgICAgcmV0dXJuIG1vZHVsZUNvbmZpZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcnVudGltZUVycm9ySUlGRShiYWJlbDogdHlwZW9mIEJhYmVsLCByZXBsYWNlbWVudHM6IHsgRVJST1JfTUVTU0FHRTogc3RyaW5nIH0pIHtcbiAgbGV0IHN0YXRlbWVudCA9IGJhYmVsLnRlbXBsYXRlKGAoZnVuY3Rpb24oKSB7XFxuICB0aHJvdyBuZXcgRXJyb3IoJ0VSUk9SX01FU1NBR0UnKTtcXG59KSgpO2ApKFxuICAgIHJlcGxhY2VtZW50c1xuICApIGFzIHQuRXhwcmVzc2lvblN0YXRlbWVudDtcbiAgcmV0dXJuIHN0YXRlbWVudC5leHByZXNzaW9uO1xufVxuIl19