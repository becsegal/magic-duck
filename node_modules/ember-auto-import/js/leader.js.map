{"version":3,"file":"leader.js","sourceRoot":"","sources":["../ts/leader.ts"],"names":[],"mappings":"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","sourcesContent":["import { gt, satisfies } from 'semver';\nimport type AutoImport from './auto-import';\nimport {\n  Project,\n  AddonInstance,\n  isDeepAddonInstance,\n} from '@embroider/shared-internals';\nimport type { Node } from 'broccoli-node-api';\nimport makeDebug from 'debug';\nconst debug = makeDebug('ember-auto-import:leader');\n\n/*\n  All versions of ember-auto-import use one of three leader election protocols.\n\n  Versions earlier than 1.8 used __ember_auto_import_protocol_v1__, which was\n  superseded because it only allowed one leader per node process, rather than\n  one per ember-cli project. We always preempt these versions from actually\n  choosing the leader via `v1ProtocolCompat` below.\n\n  Starting at 1.8, versions use __ember_auto_import_protocol_v2__ which can pick\n  a leader per project, and which always chooses the newest copy of\n  ember-auto-import that's present.\n\n  Starting at 2.0, we don't just choose the newest copy, we choose the newest\n  copy that is semver-compatible with the app's requested range of\n  ember-auto-import, and:\n\n    - it's mandatory that the app has ember-auto-import\n    - ember-auto-import >= 2.0 in an addon requires ember-auto-import >= 2.0 in the app\n\n  This allows addons to take advantage of compatible minor releases of\n  ember-auto-import without doing their own semver-breaking releases. These\n  versions use '__ember_auto_import_protocol_v3__' amongst themselves, while\n  also participating in protocol v2 (which is guaranteed to always choose one of\n  them as the leader, since protocol v2 always lets newest win, and all protocol\n  v3 versions are newer than all protocol v2 versions).\n*/\n\nconst protocolV1 = '__ember_auto_import_protocol_v1__';\nconst protocolV2 = '__ember_auto_import_protocol_v2__';\nconst protocolV3 = '__ember_auto_import_protocol_v3__';\n\nconst g = global as any as {\n  [protocolV1]: any;\n  [protocolV2]: WeakMap<Project, LeaderChooser> | undefined;\n  [protocolV3]: WeakMap<Project, LeaderChooser> | undefined;\n};\n\nexport class LeaderChooser {\n  static for(addon: AddonInstance): LeaderChooser {\n    let map: WeakMap<Project, LeaderChooser> | undefined = g[protocolV3];\n    if (!map) {\n      map = g[protocolV3] = new WeakMap();\n    }\n    // this needs to be based on project and not app instance because at the\n    // early stage where we're doing `register`, the app instance isn't\n    // available on the addons yet\n    let project = addon.project;\n    let chooser = map.get(project);\n    if (!chooser) {\n      // we are the first v3 copy to run, so we are in charge of the election\n      chooser = new this();\n      map.set(project, chooser);\n\n      // we need to preempt any subsequent v2 leader choosers and take over any\n      // already-started v2 elections. If there's already a v2 leader, it's OK\n      // to throw away all the state in it because none of the v2 copies are\n      // eligible to win anyway.\n      //\n      // This does mean that our LeaderChooser's public API needs to remain\n      // stable into the future so that v2 copies who see it here will not\n      // break.\n      let map2 = g[protocolV2];\n      if (!map2) {\n        map2 = g[protocolV2] = new WeakMap();\n      }\n      map2.set(project, chooser);\n    }\n    return chooser;\n  }\n\n  private addonCandidates: {\n    create: () => AutoImport;\n    version: string;\n    parentName: string;\n  }[] = [];\n  private appCandidate:\n    | { create: () => AutoImport; version: string; range: string }\n    | undefined;\n  private locked: AutoImport | undefined;\n\n  register(addon: AddonInstance, create: () => AutoImport) {\n    if (this.locked) {\n      throw new Error(`bug: LeaderChooser already locked`);\n    }\n    if (\n      !satisfies(addon.pkg.version, '>=2.0.0-alpha.0', {\n        includePrerelease: true,\n      })\n    ) {\n      // versions older than 2.0 are not eligible to lead\n      return;\n    }\n\n    if (isDeepAddonInstance(addon)) {\n      this.addonCandidates.push({\n        create,\n        version: addon.pkg.version,\n        parentName: addon.parent.name,\n      });\n    } else {\n      let { dependencies, devDependencies } = addon.project.pkg;\n      let range =\n        dependencies?.['ember-auto-import'] ??\n        devDependencies?.['ember-auto-import'];\n      if (!range && addon.project.pkg.name === 'ember-auto-import') {\n        range = addon.project.pkg.version;\n      }\n      if (!range) {\n        throw new Error(\n          `ember-auto-import cannot find itself in the app's package.json`\n        );\n      }\n      this.appCandidate = { create, version: addon.pkg.version, range };\n    }\n  }\n\n  get leader(): AutoImport {\n    if (!this.locked) {\n      if (!this.appCandidate) {\n        throw new Error(\n          `To use these addons, your app needs ember-auto-import >= 2: ${this.addonCandidates\n            .map((c) => c.parentName)\n            .sort()\n            .join(', ')}`\n        );\n      }\n      let eligible = [this.appCandidate, ...this.addonCandidates].filter((c) =>\n        satisfies(c.version, this.appCandidate!.range, {\n          includePrerelease: true,\n        })\n      );\n      if (eligible.length === 0) {\n        throw new Error(\n          `ember-auto-import was unable to find any copy of itself that satisfies the app's requested range of ${this.appCandidate.range}`\n        );\n      }\n      let [candidate, ...rest] = eligible;\n      for (let challenger of rest) {\n        if (gt(challenger.version, candidate.version)) {\n          candidate = challenger;\n        }\n      }\n      this.locked = candidate.create();\n      debug(\n        'elected %s from %s which satisfies %s',\n        candidate.version,\n        'parentName' in candidate ? candidate.parentName : 'the app',\n        this.appCandidate.range\n      );\n      let v1 = g[protocolV1];\n      if (v1?.isV1Placeholder) {\n        v1.leader = this.locked;\n      }\n    }\n    return this.locked;\n  }\n}\n\nclass V1Placeholder {\n  isV1Placeholder = true;\n  leader: AutoImport | undefined;\n\n  // we never want v1-speaking copies of ember-auto-import to consider\n  // themselves primary, so if they're asking here, the answer is no.\n  isPrimary() {\n    return false;\n  }\n\n  // this is the only method that is called after isPrimary returns false. So we\n  // need to implement this one and don't need to implement the other public API\n  // of AutoImport.\n  analyze(tree: Node, addon: AddonInstance) {\n    if (!this.leader) {\n      throw new Error(\n        `bug: expected some protcol v2 copy of ember-auto-import to take charge before any v1 copy started trying to analyze trees`\n      );\n    }\n    return this.leader.analyze(tree, addon);\n  }\n}\n\n// at module load time, preempt all earlier versions of ember-auto-import that\n// don't use our v2 leadership protocol. This ensures that the v2 protocol will\n// pick which version is in charge (and v1-speaking copies won't be eligible).\n(function v1ProtocolCompat() {\n  let v1 = g[protocolV1];\n  if (v1) {\n    if (!v1.isV1Placeholder) {\n      throw new Error(\n        `bug: an old version of ember-auto-import has already taken over. This is unexpected.`\n      );\n    }\n  } else {\n    g[protocolV1] = new V1Placeholder();\n  }\n})();\n"]}