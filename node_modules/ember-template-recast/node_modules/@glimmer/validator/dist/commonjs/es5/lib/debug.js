"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logTrackingStack = exports.markTagAsConsumed = exports.assertTagNotConsumed = exports.setTrackingTransactionEnv = exports.resetTrackingTransaction = exports.runInTrackingTransaction = exports.endTrackingTransaction = exports.beginTrackingTransaction = void 0;

var _env = require("@glimmer/env");

var _globalContext = require("@glimmer/global-context");

var beginTrackingTransaction;
exports.beginTrackingTransaction = beginTrackingTransaction;
var endTrackingTransaction;
exports.endTrackingTransaction = endTrackingTransaction;
var runInTrackingTransaction;
exports.runInTrackingTransaction = runInTrackingTransaction;
var resetTrackingTransaction;
exports.resetTrackingTransaction = resetTrackingTransaction;
var setTrackingTransactionEnv;
exports.setTrackingTransactionEnv = setTrackingTransactionEnv;
var assertTagNotConsumed;
exports.assertTagNotConsumed = assertTagNotConsumed;

var _markTagAsConsumed;

exports.markTagAsConsumed = _markTagAsConsumed;
var logTrackingStack;
exports.logTrackingStack = logTrackingStack;

if (_env.DEBUG) {
  var CONSUMED_TAGS = null;
  var TRANSACTION_STACK = []; /////////

  var TRANSACTION_ENV = {
    debugMessage: function debugMessage(obj, keyName) {
      var objName;

      if (typeof obj === 'function') {
        objName = obj.name;
      } else if (typeof obj === 'object' && obj !== null) {
        var className = obj.constructor && obj.constructor.name || '(unknown class)';
        objName = "(an instance of " + className + ")";
      } else if (obj === undefined) {
        objName = '(an unknown tag)';
      } else {
        objName = String(obj);
      }

      var dirtyString = keyName ? "`" + keyName + "` on `" + objName + "`" : "`" + objName + "`";
      return "You attempted to update " + dirtyString + ", but it had already been used previously in the same computation.  Attempting to update a value after using it in a computation can cause logical errors, infinite revalidation bugs, and performance issues, and is not supported.";
    }
  };

  exports.setTrackingTransactionEnv = setTrackingTransactionEnv = function setTrackingTransactionEnv(env) {
    return Object.assign(TRANSACTION_ENV, env);
  };

  exports.beginTrackingTransaction = beginTrackingTransaction = function beginTrackingTransaction(_debugLabel) {
    CONSUMED_TAGS = CONSUMED_TAGS || new WeakMap();
    var debugLabel = _debugLabel || undefined;
    var parent = TRANSACTION_STACK[TRANSACTION_STACK.length - 1] || null;
    TRANSACTION_STACK.push({
      parent: parent,
      debugLabel: debugLabel
    });
  };

  exports.endTrackingTransaction = endTrackingTransaction = function endTrackingTransaction() {
    if (TRANSACTION_STACK.length === 0) {
      throw new Error('attempted to close a tracking transaction, but one was not open');
    }

    TRANSACTION_STACK.pop();

    if (TRANSACTION_STACK.length === 0) {
      CONSUMED_TAGS = null;
    }
  };

  exports.resetTrackingTransaction = resetTrackingTransaction = function resetTrackingTransaction() {
    var stack = '';

    if (TRANSACTION_STACK.length > 0) {
      stack = logTrackingStack(TRANSACTION_STACK[TRANSACTION_STACK.length - 1]);
    }

    TRANSACTION_STACK = [];
    CONSUMED_TAGS = null;
    return stack;
  };
  /**
   * Creates a global autotracking transaction. This will prevent any backflow
   * in any `track` calls within the transaction, even if they are not
   * externally consumed.
   *
   * `runInAutotrackingTransaction` can be called within itself, and it will add
   * onto the existing transaction if one exists.
   *
   * TODO: Only throw an error if the `track` is consumed.
   */


  exports.runInTrackingTransaction = runInTrackingTransaction = function runInTrackingTransaction(fn, debugLabel) {
    beginTrackingTransaction(debugLabel);
    var didError = true;

    try {
      var value = fn();
      didError = false;
      return value;
    } finally {
      if (didError !== true) {
        endTrackingTransaction();
      }
    }
  };

  var nthIndex = function nthIndex(str, pattern, n, startingPos) {
    if (startingPos === void 0) {
      startingPos = -1;
    }

    var i = startingPos;

    while (n-- > 0 && i++ < str.length) {
      i = str.indexOf(pattern, i);
      if (i < 0) break;
    }

    return i;
  };

  var makeTrackingErrorMessage = function makeTrackingErrorMessage(transaction, obj, keyName) {
    var message = [TRANSACTION_ENV.debugMessage(obj, keyName && String(keyName))];
    message.push("`" + String(keyName) + "` was first used:");
    message.push(logTrackingStack(transaction));
    message.push("Stack trace for the update:");
    return message.join('\n\n');
  };

  exports.logTrackingStack = logTrackingStack = function logTrackingStack(transaction) {
    var trackingStack = [];
    var current = transaction || TRANSACTION_STACK[TRANSACTION_STACK.length - 1];
    if (current === undefined) return '';

    while (current) {
      if (current.debugLabel) {
        trackingStack.unshift(current.debugLabel);
      }

      current = current.parent;
    } // TODO: Use String.prototype.repeat here once we can drop support for IE11


    return trackingStack.map(function (label, index) {
      return Array(2 * index + 1).join(' ') + label;
    }).join('\n');
  };

  exports.markTagAsConsumed = _markTagAsConsumed = function markTagAsConsumed(_tag) {
    if (!CONSUMED_TAGS || CONSUMED_TAGS.has(_tag)) return;
    CONSUMED_TAGS.set(_tag, TRANSACTION_STACK[TRANSACTION_STACK.length - 1]); // We need to mark the tag and all of its subtags as consumed, so we need to
    // cast it and access its internals. In the future this shouldn't be necessary,
    // this is only for computed properties.

    var tag = _tag;

    if (tag.subtag) {
      _markTagAsConsumed(tag.subtag);
    }

    if (tag.subtags) {
      tag.subtags.forEach(function (tag) {
        return _markTagAsConsumed(tag);
      });
    }
  };

  exports.assertTagNotConsumed = assertTagNotConsumed = function assertTagNotConsumed(tag, obj, keyName) {
    if (CONSUMED_TAGS === null) return;
    var transaction = CONSUMED_TAGS.get(tag);
    if (!transaction) return; // This hack makes the assertion message nicer, we can cut off the first
    // few lines of the stack trace and let users know where the actual error
    // occurred.

    try {
      (0, _globalContext.assert)(false, makeTrackingErrorMessage(transaction, obj, keyName));
    } catch (e) {
      if (e.stack) {
        var updateStackBegin = e.stack.indexOf('Stack trace for the update:');

        if (updateStackBegin !== -1) {
          var start = nthIndex(e.stack, '\n', 1, updateStackBegin);
          var end = nthIndex(e.stack, '\n', 4, updateStackBegin);
          e.stack = e.stack.substr(0, start) + e.stack.substr(end);
        }
      }

      throw e;
    }
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3ZhbGlkYXRvci9saWIvZGVidWcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNBOztBQUNBOztBQUVPLElBQUEsd0JBQUE7O0FBR0EsSUFBQSxzQkFBQTs7QUFDQSxJQUFBLHdCQUFBOztBQUlBLElBQUEsd0JBQUE7O0FBQ0EsSUFBQSx5QkFBQTs7QUFJQSxJQUFBLG9CQUFBOzs7QUFJQSxJQUFBLGtCQUFBOzs7QUFFQSxJQUFBLGdCQUFBOzs7QUFPUCxJQUFBLFVBQUEsRUFBVztBQUNULE1BQUksYUFBYSxHQUFqQixJQUFBO0FBRUEsTUFBSSxpQkFBaUIsR0FIWixFQUdULENBSFMsQ0FLVDs7QUFFQSxNQUFJLGVBQWUsR0FBRztBQUNwQixJQUFBLFlBRG9CLEVBQUEsU0FBQSxZQUFBLENBQUEsR0FBQSxFQUFBLE9BQUEsRUFDd0I7QUFDMUMsVUFBQSxPQUFBOztBQUVBLFVBQUksT0FBQSxHQUFBLEtBQUosVUFBQSxFQUErQjtBQUM3QixRQUFBLE9BQU8sR0FBRyxHQUFHLENBQWIsSUFBQTtBQURGLE9BQUEsTUFFTyxJQUFJLE9BQUEsR0FBQSxLQUFBLFFBQUEsSUFBMkIsR0FBRyxLQUFsQyxJQUFBLEVBQTZDO0FBQ2xELFlBQUksU0FBUyxHQUFJLEdBQUcsQ0FBSCxXQUFBLElBQW1CLEdBQUcsQ0FBSCxXQUFBLENBQXBCLElBQUMsSUFBakIsaUJBQUE7QUFFQSxRQUFBLE9BQU8sR0FBQSxxQkFBUCxTQUFPLEdBQVAsR0FBQTtBQUhLLE9BQUEsTUFJQSxJQUFJLEdBQUcsS0FBUCxTQUFBLEVBQXVCO0FBQzVCLFFBQUEsT0FBTyxHQUFQLGtCQUFBO0FBREssT0FBQSxNQUVBO0FBQ0wsUUFBQSxPQUFPLEdBQUcsTUFBTSxDQUFoQixHQUFnQixDQUFoQjtBQUNEOztBQUVELFVBQUksV0FBVyxHQUFHLE9BQU8sR0FBQSxNQUFBLE9BQUEsR0FBQSxRQUFBLEdBQUEsT0FBQSxHQUFBLEdB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Q0FBRixLQUFBLEVBQUEsSUFBQSxFQUFBLENBQUEsRUFBcEIsZ0JBQW9CLENBQXBCO0FBQ0EsY0FBSSxHQUFHLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBRixLQUFBLEVBQUEsSUFBQSxFQUFBLENBQUEsRUFBbEIsZ0JBQWtCLENBQWxCO0FBQ0EsVUFBQSxDQUFDLENBQUQsS0FBQSxHQUFVLENBQUMsQ0FBRCxLQUFBLENBQUEsTUFBQSxDQUFBLENBQUEsRUFBQSxLQUFBLElBQTJCLENBQUMsQ0FBRCxLQUFBLENBQUEsTUFBQSxDQUFyQyxHQUFxQyxDQUFyQztBQUNEO0FBQ0Y7O0FBRUQsWUFBQSxDQUFBO0FBQ0Q7QUF4QkgsR0FBQTtBQTBCRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRhZyB9IGZyb20gJy4vdmFsaWRhdG9ycyc7XG5pbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZ2xpbW1lci9nbG9iYWwtY29udGV4dCc7XG5cbmV4cG9ydCBsZXQgYmVnaW5UcmFja2luZ1RyYW5zYWN0aW9uOlxuICB8IHVuZGVmaW5lZFxuICB8ICgoZGVidWdnaW5nQ29udGV4dD86IHN0cmluZyB8IGZhbHNlLCBkZXByZWNhdGU/OiBib29sZWFuKSA9PiB2b2lkKTtcbmV4cG9ydCBsZXQgZW5kVHJhY2tpbmdUcmFuc2FjdGlvbjogdW5kZWZpbmVkIHwgKCgpID0+IHZvaWQpO1xuZXhwb3J0IGxldCBydW5JblRyYWNraW5nVHJhbnNhY3Rpb246XG4gIHwgdW5kZWZpbmVkXG4gIHwgKDxUPihmbjogKCkgPT4gVCwgZGVidWdnaW5nQ29udGV4dD86IHN0cmluZyB8IGZhbHNlKSA9PiBUKTtcblxuZXhwb3J0IGxldCByZXNldFRyYWNraW5nVHJhbnNhY3Rpb246IHVuZGVmaW5lZCB8ICgoKSA9PiBzdHJpbmcpO1xuZXhwb3J0IGxldCBzZXRUcmFja2luZ1RyYW5zYWN0aW9uRW52OlxuICB8IHVuZGVmaW5lZFxuICB8ICgoZW52OiB7IGRlYnVnTWVzc2FnZT8ob2JqPzogdW5rbm93biwga2V5TmFtZT86IHN0cmluZyk6IHN0cmluZyB9KSA9PiB2b2lkKTtcblxuZXhwb3J0IGxldCBhc3NlcnRUYWdOb3RDb25zdW1lZDpcbiAgfCB1bmRlZmluZWRcbiAgfCAoPFQ+KHRhZzogVGFnLCBvYmo/OiBULCBrZXlOYW1lPzoga2V5b2YgVCB8IHN0cmluZyB8IHN5bWJvbCkgPT4gdm9pZCk7XG5cbmV4cG9ydCBsZXQgbWFya1RhZ0FzQ29uc3VtZWQ6IHVuZGVmaW5lZCB8ICgoX3RhZzogVGFnKSA9PiB2b2lkKTtcblxuZXhwb3J0IGxldCBsb2dUcmFja2luZ1N0YWNrOiB1bmRlZmluZWQgfCAoKHRyYW5zYWN0aW9uPzogVHJhbnNhY3Rpb24pID0+IHN0cmluZyk7XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvbiB7XG4gIHBhcmVudDogVHJhbnNhY3Rpb24gfCBudWxsO1xuICBkZWJ1Z0xhYmVsPzogc3RyaW5nO1xufVxuXG5pZiAoREVCVUcpIHtcbiAgbGV0IENPTlNVTUVEX1RBR1M6IFdlYWtNYXA8VGFnLCBUcmFuc2FjdGlvbj4gfCBudWxsID0gbnVsbDtcblxuICBsZXQgVFJBTlNBQ1RJT05fU1RBQ0s6IFRyYW5zYWN0aW9uW10gPSBbXTtcblxuICAvLy8vLy8vLy9cblxuICBsZXQgVFJBTlNBQ1RJT05fRU5WID0ge1xuICAgIGRlYnVnTWVzc2FnZShvYmo/OiB1bmtub3duLCBrZXlOYW1lPzogc3RyaW5nKSB7XG4gICAgICBsZXQgb2JqTmFtZTtcblxuICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JqTmFtZSA9IG9iai5uYW1lO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9IChvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUpIHx8ICcodW5rbm93biBjbGFzcyknO1xuXG4gICAgICAgIG9iak5hbWUgPSBgKGFuIGluc3RhbmNlIG9mICR7Y2xhc3NOYW1lfSlgO1xuICAgICAgfSBlbHNlIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvYmpOYW1lID0gJyhhbiB1bmtub3duIHRhZyknO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqTmFtZSA9IFN0cmluZyhvYmopO1xuICAgICAgfVxuXG4gICAgICBsZXQgZGlydHlTdHJpbmcgPSBrZXlOYW1lID8gYFxcYCR7a2V5TmFtZX1cXGAgb24gXFxgJHtvYmpOYW1lfVxcYGAgOiBgXFxgJHtvYmpOYW1lfVxcYGA7XG5cbiAgICAgIHJldHVybiBgWW91IGF0dGVtcHRlZCB0byB1cGRhdGUgJHtkaXJ0eVN0cmluZ30sIGJ1dCBpdCBoYWQgYWxyZWFkeSBiZWVuIHVzZWQgcHJldmlvdXNseSBpbiB0aGUgc2FtZSBjb21wdXRhdGlvbi4gIEF0dGVtcHRpbmcgdG8gdXBkYXRlIGEgdmFsdWUgYWZ0ZXIgdXNpbmcgaXQgaW4gYSBjb21wdXRhdGlvbiBjYW4gY2F1c2UgbG9naWNhbCBlcnJvcnMsIGluZmluaXRlIHJldmFsaWRhdGlvbiBidWdzLCBhbmQgcGVyZm9ybWFuY2UgaXNzdWVzLCBhbmQgaXMgbm90IHN1cHBvcnRlZC5gO1xuICAgIH0sXG4gIH07XG5cbiAgc2V0VHJhY2tpbmdUcmFuc2FjdGlvbkVudiA9IChlbnYpID0+IE9iamVjdC5hc3NpZ24oVFJBTlNBQ1RJT05fRU5WLCBlbnYpO1xuXG4gIGJlZ2luVHJhY2tpbmdUcmFuc2FjdGlvbiA9IChfZGVidWdMYWJlbD86IHN0cmluZyB8IGZhbHNlKSA9PiB7XG4gICAgQ09OU1VNRURfVEFHUyA9IENPTlNVTUVEX1RBR1MgfHwgbmV3IFdlYWtNYXAoKTtcblxuICAgIGxldCBkZWJ1Z0xhYmVsID0gX2RlYnVnTGFiZWwgfHwgdW5kZWZpbmVkO1xuXG4gICAgbGV0IHBhcmVudCA9IFRSQU5TQUNUSU9OX1NUQUNLW1RSQU5TQUNUSU9OX1NUQUNLLmxlbmd0aCAtIDFdIHx8IG51bGw7XG5cbiAgICBUUkFOU0FDVElPTl9TVEFDSy5wdXNoKHtcbiAgICAgIHBhcmVudCxcbiAgICAgIGRlYnVnTGFiZWwsXG4gICAgfSk7XG4gIH07XG5cbiAgZW5kVHJhY2tpbmdUcmFuc2FjdGlvbiA9ICgpID0+IHtcbiAgICBpZiAoVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F0dGVtcHRlZCB0byBjbG9zZSBhIHRyYWNraW5nIHRyYW5zYWN0aW9uLCBidXQgb25lIHdhcyBub3Qgb3BlbicpO1xuICAgIH1cblxuICAgIFRSQU5TQUNUSU9OX1NUQUNLLnBvcCgpO1xuXG4gICAgaWYgKFRSQU5TQUNUSU9OX1NUQUNLLmxlbmd0aCA9PT0gMCkge1xuICAgICAgQ09OU1VNRURfVEFHUyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHJlc2V0VHJhY2tpbmdUcmFuc2FjdGlvbiA9ICgpID0+IHtcbiAgICBsZXQgc3RhY2sgPSAnJztcblxuICAgIGlmIChUUkFOU0FDVElPTl9TVEFDSy5sZW5ndGggPiAwKSB7XG4gICAgICBzdGFjayA9IGxvZ1RyYWNraW5nU3RhY2shKFRSQU5TQUNUSU9OX1NUQUNLW1RSQU5TQUNUSU9OX1NUQUNLLmxlbmd0aCAtIDFdKTtcbiAgICB9XG5cbiAgICBUUkFOU0FDVElPTl9TVEFDSyA9IFtdO1xuICAgIENPTlNVTUVEX1RBR1MgPSBudWxsO1xuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZ2xvYmFsIGF1dG90cmFja2luZyB0cmFuc2FjdGlvbi4gVGhpcyB3aWxsIHByZXZlbnQgYW55IGJhY2tmbG93XG4gICAqIGluIGFueSBgdHJhY2tgIGNhbGxzIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24sIGV2ZW4gaWYgdGhleSBhcmUgbm90XG4gICAqIGV4dGVybmFsbHkgY29uc3VtZWQuXG4gICAqXG4gICAqIGBydW5JbkF1dG90cmFja2luZ1RyYW5zYWN0aW9uYCBjYW4gYmUgY2FsbGVkIHdpdGhpbiBpdHNlbGYsIGFuZCBpdCB3aWxsIGFkZFxuICAgKiBvbnRvIHRoZSBleGlzdGluZyB0cmFuc2FjdGlvbiBpZiBvbmUgZXhpc3RzLlxuICAgKlxuICAgKiBUT0RPOiBPbmx5IHRocm93IGFuIGVycm9yIGlmIHRoZSBgdHJhY2tgIGlzIGNvbnN1bWVkLlxuICAgKi9cbiAgcnVuSW5UcmFja2luZ1RyYW5zYWN0aW9uID0gPFQ+KGZuOiAoKSA9PiBULCBkZWJ1Z0xhYmVsPzogc3RyaW5nIHwgZmFsc2UpID0+IHtcbiAgICBiZWdpblRyYWNraW5nVHJhbnNhY3Rpb24hKGRlYnVnTGFiZWwpO1xuICAgIGxldCBkaWRFcnJvciA9IHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgbGV0IHZhbHVlID0gZm4oKTtcbiAgICAgIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChkaWRFcnJvciAhPT0gdHJ1ZSkge1xuICAgICAgICBlbmRUcmFja2luZ1RyYW5zYWN0aW9uISgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBsZXQgbnRoSW5kZXggPSAoc3RyOiBzdHJpbmcsIHBhdHRlcm46IHN0cmluZywgbjogbnVtYmVyLCBzdGFydGluZ1BvcyA9IC0xKSA9PiB7XG4gICAgbGV0IGkgPSBzdGFydGluZ1BvcztcblxuICAgIHdoaWxlIChuLS0gPiAwICYmIGkrKyA8IHN0ci5sZW5ndGgpIHtcbiAgICAgIGkgPSBzdHIuaW5kZXhPZihwYXR0ZXJuLCBpKTtcbiAgICAgIGlmIChpIDwgMCkgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGk7XG4gIH07XG5cbiAgbGV0IG1ha2VUcmFja2luZ0Vycm9yTWVzc2FnZSA9IDxUPihcbiAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24sXG4gICAgb2JqPzogVCxcbiAgICBrZXlOYW1lPzoga2V5b2YgVCB8IHN0cmluZyB8IHN5bWJvbFxuICApID0+IHtcbiAgICBsZXQgbWVzc2FnZSA9IFtUUkFOU0FDVElPTl9FTlYuZGVidWdNZXNzYWdlKG9iaiwga2V5TmFtZSAmJiBTdHJpbmcoa2V5TmFtZSkpXTtcblxuICAgIG1lc3NhZ2UucHVzaChgXFxgJHtTdHJpbmcoa2V5TmFtZSl9XFxgIHdhcyBmaXJzdCB1c2VkOmApO1xuXG4gICAgbWVzc2FnZS5wdXNoKGxvZ1RyYWNraW5nU3RhY2shKHRyYW5zYWN0aW9uKSk7XG5cbiAgICBtZXNzYWdlLnB1c2goYFN0YWNrIHRyYWNlIGZvciB0aGUgdXBkYXRlOmApO1xuXG4gICAgcmV0dXJuIG1lc3NhZ2Uuam9pbignXFxuXFxuJyk7XG4gIH07XG5cbiAgbG9nVHJhY2tpbmdTdGFjayA9ICh0cmFuc2FjdGlvbj86IFRyYW5zYWN0aW9uKSA9PiB7XG4gICAgbGV0IHRyYWNraW5nU3RhY2sgPSBbXTtcbiAgICBsZXQgY3VycmVudDogVHJhbnNhY3Rpb24gfCBudWxsIHwgdW5kZWZpbmVkID1cbiAgICAgIHRyYW5zYWN0aW9uIHx8IFRSQU5TQUNUSU9OX1NUQUNLW1RSQU5TQUNUSU9OX1NUQUNLLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGN1cnJlbnQgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuXG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgIGlmIChjdXJyZW50LmRlYnVnTGFiZWwpIHtcbiAgICAgICAgdHJhY2tpbmdTdGFjay51bnNoaWZ0KGN1cnJlbnQuZGVidWdMYWJlbCk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQgaGVyZSBvbmNlIHdlIGNhbiBkcm9wIHN1cHBvcnQgZm9yIElFMTFcbiAgICByZXR1cm4gdHJhY2tpbmdTdGFjay5tYXAoKGxhYmVsLCBpbmRleCkgPT4gQXJyYXkoMiAqIGluZGV4ICsgMSkuam9pbignICcpICsgbGFiZWwpLmpvaW4oJ1xcbicpO1xuICB9O1xuXG4gIG1hcmtUYWdBc0NvbnN1bWVkID0gKF90YWc6IFRhZykgPT4ge1xuICAgIGlmICghQ09OU1VNRURfVEFHUyB8fCBDT05TVU1FRF9UQUdTLmhhcyhfdGFnKSkgcmV0dXJuO1xuXG4gICAgQ09OU1VNRURfVEFHUy5zZXQoX3RhZywgVFJBTlNBQ1RJT05fU1RBQ0tbVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoIC0gMV0pO1xuXG4gICAgLy8gV2UgbmVlZCB0byBtYXJrIHRoZSB0YWcgYW5kIGFsbCBvZiBpdHMgc3VidGFncyBhcyBjb25zdW1lZCwgc28gd2UgbmVlZCB0b1xuICAgIC8vIGNhc3QgaXQgYW5kIGFjY2VzcyBpdHMgaW50ZXJuYWxzLiBJbiB0aGUgZnV0dXJlIHRoaXMgc2hvdWxkbid0IGJlIG5lY2Vzc2FyeSxcbiAgICAvLyB0aGlzIGlzIG9ubHkgZm9yIGNvbXB1dGVkIHByb3BlcnRpZXMuXG4gICAgbGV0IHRhZyA9IF90YWcgYXMgYW55O1xuXG4gICAgaWYgKHRhZy5zdWJ0YWcpIHtcbiAgICAgIG1hcmtUYWdBc0NvbnN1bWVkISh0YWcuc3VidGFnKTtcbiAgICB9XG5cbiAgICBpZiAodGFnLnN1YnRhZ3MpIHtcbiAgICAgIHRhZy5zdWJ0YWdzLmZvckVhY2goKHRhZzogVGFnKSA9PiBtYXJrVGFnQXNDb25zdW1lZCEodGFnKSk7XG4gICAgfVxuICB9O1xuXG4gIGFzc2VydFRhZ05vdENvbnN1bWVkID0gPFQ+KHRhZzogVGFnLCBvYmo/OiBULCBrZXlOYW1lPzoga2V5b2YgVCB8IHN0cmluZyB8IHN5bWJvbCkgPT4ge1xuICAgIGlmIChDT05TVU1FRF9UQUdTID09PSBudWxsKSByZXR1cm47XG5cbiAgICBsZXQgdHJhbnNhY3Rpb24gPSBDT05TVU1FRF9UQUdTLmdldCh0YWcpO1xuXG4gICAgaWYgKCF0cmFuc2FjdGlvbikgcmV0dXJuO1xuXG4gICAgLy8gVGhpcyBoYWNrIG1ha2VzIHRoZSBhc3NlcnRpb24gbWVzc2FnZSBuaWNlciwgd2UgY2FuIGN1dCBvZmYgdGhlIGZpcnN0XG4gICAgLy8gZmV3IGxpbmVzIG9mIHRoZSBzdGFjayB0cmFjZSBhbmQgbGV0IHVzZXJzIGtub3cgd2hlcmUgdGhlIGFjdHVhbCBlcnJvclxuICAgIC8vIG9jY3VycmVkLlxuICAgIHRyeSB7XG4gICAgICBhc3NlcnQoZmFsc2UsIG1ha2VUcmFja2luZ0Vycm9yTWVzc2FnZSh0cmFuc2FjdGlvbiwgb2JqLCBrZXlOYW1lKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuc3RhY2spIHtcbiAgICAgICAgbGV0IHVwZGF0ZVN0YWNrQmVnaW4gPSBlLnN0YWNrLmluZGV4T2YoJ1N0YWNrIHRyYWNlIGZvciB0aGUgdXBkYXRlOicpO1xuXG4gICAgICAgIGlmICh1cGRhdGVTdGFja0JlZ2luICE9PSAtMSkge1xuICAgICAgICAgIGxldCBzdGFydCA9IG50aEluZGV4KGUuc3RhY2ssICdcXG4nLCAxLCB1cGRhdGVTdGFja0JlZ2luKTtcbiAgICAgICAgICBsZXQgZW5kID0gbnRoSW5kZXgoZS5zdGFjaywgJ1xcbicsIDQsIHVwZGF0ZVN0YWNrQmVnaW4pO1xuICAgICAgICAgIGUuc3RhY2sgPSBlLnN0YWNrLnN1YnN0cigwLCBzdGFydCkgKyBlLnN0YWNrLnN1YnN0cihlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==