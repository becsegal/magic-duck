"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIteratorRef = createIteratorRef;
exports.createIteratorItemRef = createIteratorItemRef;

var _globalContext = require("@glimmer/global-context");

var _util = require("@glimmer/util");

var _env = require("@glimmer/env");

var _validator = require("@glimmer/validator");

var _reference = require("./reference");

const NULL_IDENTITY = {};

const KEY = (_, index) => index;

const INDEX = (_, index) => String(index);

const IDENTITY = item => {
  if (item === null) {
    // Returning null as an identity will cause failures since the iterator
    // can't tell that it's actually supposed to be null
    return NULL_IDENTITY;
  }

  return item;
};

function keyForPath(path) {
  if (_env.DEBUG && path[0] === '@') {
    throw new Error(`invalid keypath: '${path}', valid keys: @index, @identity, or a path`);
  }

  return uniqueKeyFor(item => (0, _globalContext.getPath)(item, path));
}

function makeKeyFor(key) {
  switch (key) {
    case '@key':
      return uniqueKeyFor(KEY);

    case '@index':
      return uniqueKeyFor(INDEX);

    case '@identity':
      return uniqueKeyFor(IDENTITY);

    default:
      return keyForPath(key);
  }
}

class WeakMapWithPrimitives {
  get weakMap() {
    if (this._weakMap === undefined) {
      this._weakMap = new WeakMap();
    }

    return this._weakMap;
  }

  get primitiveMap() {
    if (this._primitiveMap === undefined) {
      this._primitiveMap = new Map();
    }

    return this._primitiveMap;
  }

  set(key, value) {
    if ((0, _util.isObject)(key)) {
      this.weakMap.set(key, value);
    } else {
      this.primitiveMap.set(key, value);
    }
  }

  get(key) {
    if ((0, _util.isObject)(key)) {
      return this.weakMap.get(key);
    } else {
      return this.primitiveMap.get(key);
    }
  }

}

const IDENTITIES = new WeakMapWithPrimitives();

function identityForNthOccurence(value, count) {
  let identities = IDENTITIES.get(value);

  if (identities === undefined) {
    identities = [];
    IDENTITIES.set(value, identities);
  }

  let identity = identities[count];

  if (identity === undefined) {
    identity = {
      value,
      count
    };
    identities[count] = identity;
  }

  return identity;
}
/**
 * When iterating over a list, it's possible that an item with the same unique
 * key could be encountered twice:
 *
 * ```js
 * let arr = ['same', 'different', 'same', 'same'];
 * ```
 *
 * In general, we want to treat these items as _unique within the list_. To do
 * this, we track the occurences of every item as we iterate the list, and when
 * an item occurs more than once, we generate a new unique key just for that
 * item, and that occurence within the list. The next time we iterate the list,
 * and encounter an item for the nth time, we can get the _same_ key, and let
 * Glimmer know that it should reuse the DOM for the previous nth occurence.
 */


function uniqueKeyFor(keyFor) {
  let seen = new WeakMapWithPrimitives();
  return (value, memo) => {
    let key = keyFor(value, memo);
    let count = seen.get(key) || 0;
    seen.set(key, count + 1);

    if (count === 0) {
      return key;
    }

    return identityForNthOccurence(key, count);
  };
}

function createIteratorRef(listRef, key) {
  return (0, _reference.createComputeRef)(() => {
    let iterable = (0, _reference.valueForRef)(listRef);
    let keyFor = makeKeyFor(key);

    if (Array.isArray(iterable)) {
      return new ArrayIterator(iterable, keyFor);
    }

    let maybeIterator = (0, _globalContext.toIterator)(iterable);

    if (maybeIterator === null) {
      return new ArrayIterator(_util.EMPTY_ARRAY, () => null);
    }

    return new IteratorWrapper(maybeIterator, keyFor);
  });
}

function createIteratorItemRef(_value) {
  let value = _value;
  let tag = (0, _validator.createTag)();
  return (0, _reference.createComputeRef)(() => {
    (0, _validator.consumeTag)(tag);
    return value;
  }, newValue => {
    if (value !== newValue) {
      value = newValue;
      (0, _validator.dirtyTag)(tag);
    }
  });
}

class IteratorWrapper {
  constructor(inner, keyFor) {
    this.inner = inner;
    this.keyFor = keyFor;
  }

  isEmpty() {
    return this.inner.isEmpty();
  }

  next() {
    let nextValue = this.inner.next();

    if (nextValue !== null) {
      nextValue.key = this.keyFor(nextValue.value, nextValue.memo);
    }

    return nextValue;
  }

}

class ArrayIterator {
  constructor(iterator, keyFor) {
    this.iterator = iterator;
    this.keyFor = keyFor;
    this.pos = 0;

    if (iterator.length === 0) {
      this.current = {
        kind: 'empty'
      };
    } else {
      this.current = {
        kind: 'first',
        value: iterator[this.pos]
      };
    }
  }

  isEmpty() {
    return this.current.kind === 'empty';
  }

  next() {
    let value;
    let current = this.current;

    if (current.kind === 'first') {
      this.current = {
        kind: 'progress'
      };
      value = current.value;
    } else if (this.pos >= this.iterator.length - 1) {
      return null;
    } else {
      value = this.iterator[++this.pos];
    }

    let {
      keyFor
    } = this;
    let key = keyFor(value, this.pos);
    let memo = this.pos;
    return {
      key,
      value,
      memo
    };
  }

}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3JlZmVyZW5jZS9saWIvaXRlcmFibGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUE0QkEsTUFBTSxhQUFhLEdBQW5CLEVBQUE7O0FBRUEsTUFBTSxHQUFHLEdBQVcsQ0FBQSxDQUFBLEVBQUEsS0FBQSxLQUFwQixLQUFBOztBQUNBLE1BQU0sS0FBSyxHQUFXLENBQUEsQ0FBQSxFQUFBLEtBQUEsS0FBYyxNQUFNLENBQTFDLEtBQTBDLENBQTFDOztBQUNBLE1BQU0sUUFBUSxHQUFZLElBQUQsSUFBUztBQUNoQyxNQUFJLElBQUksS0FBUixJQUFBLEVBQW1CO0FBQ2pCO0FBQ0E7QUFDQSxXQUFBLGFBQUE7QUFDRDs7QUFFRCxTQUFBLElBQUE7QUFQRixDQUFBOztBQVVBLFNBQUEsVUFBQSxDQUFBLElBQUEsRUFBZ0M7QUFDOUIsTUFBSSxjQUFTLElBQUksQ0FBSixDQUFJLENBQUosS0FBYixHQUFBLEVBQThCO0FBQzVCLFVBQU0sSUFBQSxLQUFBLENBQVUscUJBQXFCLElBQXJDLDZDQUFNLENBQU47QUFDRDs7QUFDRCxTQUFPLFlBQVksQ0FBRSxJQUFELElBQVUsNEJBQU8sSUFBUCxFQUE5QixJQUE4QixDQUFYLENBQW5CO0FBQ0Q7O0FBRUQsU0FBQSxVQUFBLENBQUEsR0FBQSxFQUErQjtBQUM3QixVQUFBLEdBQUE7QUFDRSxTQUFBLE1BQUE7QUFDRSxhQUFPLFlBQVksQ0FBbkIsR0FBbUIsQ0FBbkI7O0FBQ0YsU0FBQSxRQUFBO0FBQ0UsYUFBTyxZQUFZLENBQW5CLEtBQW1CLENBQW5COztBQUNGLFNBQUEsV0FBQTtBQUNFLGFBQU8sWUFBWSxDQUFuQixRQUFtQixDQUFuQjs7QUFDRjtBQUNFLGFBQU8sVUFBVSxDQUFqQixHQUFpQixDQUFqQjtBQVJKO0FBVUQ7O0FBRUQsTUFBQSxxQkFBQSxDQUEyQjtBQUl6QixNQUFBLE9B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dFBhdGgsIHRvSXRlcmF0b3IgfSBmcm9tICdAZ2xpbW1lci9nbG9iYWwtY29udGV4dCc7XG5pbXBvcnQgeyBPcHRpb24sIERpY3QgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IEVNUFRZX0FSUkFZLCBpc09iamVjdCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHsgY3JlYXRlVGFnLCBjb25zdW1lVGFnLCBkaXJ0eVRhZyB9IGZyb20gJ0BnbGltbWVyL3ZhbGlkYXRvcic7XG5pbXBvcnQgeyBSZWZlcmVuY2UsIFJlZmVyZW5jZUVudmlyb25tZW50LCB2YWx1ZUZvclJlZiwgY3JlYXRlQ29tcHV0ZVJlZiB9IGZyb20gJy4vcmVmZXJlbmNlJztcblxuZXhwb3J0IGludGVyZmFjZSBJdGVyYXRpb25JdGVtPFQsIFU+IHtcbiAga2V5OiB1bmtub3duO1xuICB2YWx1ZTogVDtcbiAgbWVtbzogVTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBYnN0cmFjdEl0ZXJhdG9yPFQsIFUsIFYgZXh0ZW5kcyBJdGVyYXRpb25JdGVtPFQsIFU+PiB7XG4gIGlzRW1wdHkoKTogYm9vbGVhbjtcbiAgbmV4dCgpOiBPcHRpb248Vj47XG59XG5cbmV4cG9ydCB0eXBlIE9wYXF1ZUl0ZXJhdGlvbkl0ZW0gPSBJdGVyYXRpb25JdGVtPHVua25vd24sIHVua25vd24+O1xuZXhwb3J0IHR5cGUgT3BhcXVlSXRlcmF0b3IgPSBBYnN0cmFjdEl0ZXJhdG9yPHVua25vd24sIHVua25vd24sIE9wYXF1ZUl0ZXJhdGlvbkl0ZW0+O1xuXG5leHBvcnQgaW50ZXJmYWNlIEl0ZXJhdG9yRGVsZWdhdGUge1xuICBpc0VtcHR5KCk6IGJvb2xlYW47XG4gIG5leHQoKTogeyB2YWx1ZTogdW5rbm93bjsgbWVtbzogdW5rbm93biB9IHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJdGVyYXRvclJlZmVyZW5jZUVudmlyb25tZW50IGV4dGVuZHMgUmVmZXJlbmNlRW52aXJvbm1lbnQge1xuICBnZXRQYXRoKG9iajogdW5rbm93biwgcGF0aDogc3RyaW5nKTogdW5rbm93bjtcbiAgdG9JdGVyYXRvcihvYmo6IHVua25vd24pOiBPcHRpb248SXRlcmF0b3JEZWxlZ2F0ZT47XG59XG5cbnR5cGUgS2V5Rm9yID0gKGl0ZW06IHVua25vd24sIGluZGV4OiB1bmtub3duKSA9PiB1bmtub3duO1xuXG5jb25zdCBOVUxMX0lERU5USVRZID0ge307XG5cbmNvbnN0IEtFWTogS2V5Rm9yID0gKF8sIGluZGV4KSA9PiBpbmRleDtcbmNvbnN0IElOREVYOiBLZXlGb3IgPSAoXywgaW5kZXgpID0+IFN0cmluZyhpbmRleCk7XG5jb25zdCBJREVOVElUWTogS2V5Rm9yID0gKGl0ZW0pID0+IHtcbiAgaWYgKGl0ZW0gPT09IG51bGwpIHtcbiAgICAvLyBSZXR1cm5pbmcgbnVsbCBhcyBhbiBpZGVudGl0eSB3aWxsIGNhdXNlIGZhaWx1cmVzIHNpbmNlIHRoZSBpdGVyYXRvclxuICAgIC8vIGNhbid0IHRlbGwgdGhhdCBpdCdzIGFjdHVhbGx5IHN1cHBvc2VkIHRvIGJlIG51bGxcbiAgICByZXR1cm4gTlVMTF9JREVOVElUWTtcbiAgfVxuXG4gIHJldHVybiBpdGVtO1xufTtcblxuZnVuY3Rpb24ga2V5Rm9yUGF0aChwYXRoOiBzdHJpbmcpOiBLZXlGb3Ige1xuICBpZiAoREVCVUcgJiYgcGF0aFswXSA9PT0gJ0AnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGtleXBhdGg6ICcke3BhdGh9JywgdmFsaWQga2V5czogQGluZGV4LCBAaWRlbnRpdHksIG9yIGEgcGF0aGApO1xuICB9XG4gIHJldHVybiB1bmlxdWVLZXlGb3IoKGl0ZW0pID0+IGdldFBhdGgoaXRlbSBhcyBvYmplY3QsIHBhdGgpKTtcbn1cblxuZnVuY3Rpb24gbWFrZUtleUZvcihrZXk6IHN0cmluZykge1xuICBzd2l0Y2ggKGtleSkge1xuICAgIGNhc2UgJ0BrZXknOlxuICAgICAgcmV0dXJuIHVuaXF1ZUtleUZvcihLRVkpO1xuICAgIGNhc2UgJ0BpbmRleCc6XG4gICAgICByZXR1cm4gdW5pcXVlS2V5Rm9yKElOREVYKTtcbiAgICBjYXNlICdAaWRlbnRpdHknOlxuICAgICAgcmV0dXJuIHVuaXF1ZUtleUZvcihJREVOVElUWSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBrZXlGb3JQYXRoKGtleSk7XG4gIH1cbn1cblxuY2xhc3MgV2Vha01hcFdpdGhQcmltaXRpdmVzPFQ+IHtcbiAgcHJpdmF0ZSBfd2Vha01hcD86IFdlYWtNYXA8b2JqZWN0LCBUPjtcbiAgcHJpdmF0ZSBfcHJpbWl0aXZlTWFwPzogTWFwPHVua25vd24sIFQ+O1xuXG4gIHByaXZhdGUgZ2V0IHdlYWtNYXAoKSB7XG4gICAgaWYgKHRoaXMuX3dlYWtNYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fd2Vha01hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dlYWtNYXA7XG4gIH1cblxuICBwcml2YXRlIGdldCBwcmltaXRpdmVNYXAoKSB7XG4gICAgaWYgKHRoaXMuX3ByaW1pdGl2ZU1hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcmltaXRpdmVNYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3ByaW1pdGl2ZU1hcDtcbiAgfVxuXG4gIHNldChrZXk6IHVua25vd24sIHZhbHVlOiBUKSB7XG4gICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgIHRoaXMud2Vha01hcC5zZXQoa2V5IGFzIG9iamVjdCwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByaW1pdGl2ZU1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0KGtleTogdW5rbm93bik6IFQgfCB1bmRlZmluZWQge1xuICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy53ZWFrTWFwLmdldChrZXkgYXMgb2JqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucHJpbWl0aXZlTWFwLmdldChrZXkpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBJREVOVElUSUVTID0gbmV3IFdlYWtNYXBXaXRoUHJpbWl0aXZlczxvYmplY3RbXT4oKTtcblxuZnVuY3Rpb24gaWRlbnRpdHlGb3JOdGhPY2N1cmVuY2UodmFsdWU6IGFueSwgY291bnQ6IG51bWJlcikge1xuICBsZXQgaWRlbnRpdGllcyA9IElERU5USVRJRVMuZ2V0KHZhbHVlKTtcblxuICBpZiAoaWRlbnRpdGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWRlbnRpdGllcyA9IFtdO1xuICAgIElERU5USVRJRVMuc2V0KHZhbHVlLCBpZGVudGl0aWVzKTtcbiAgfVxuXG4gIGxldCBpZGVudGl0eSA9IGlkZW50aXRpZXNbY291bnRdO1xuXG4gIGlmIChpZGVudGl0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWRlbnRpdHkgPSB7IHZhbHVlLCBjb3VudCB9O1xuICAgIGlkZW50aXRpZXNbY291bnRdID0gaWRlbnRpdHk7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpdHk7XG59XG5cbi8qKlxuICogV2hlbiBpdGVyYXRpbmcgb3ZlciBhIGxpc3QsIGl0J3MgcG9zc2libGUgdGhhdCBhbiBpdGVtIHdpdGggdGhlIHNhbWUgdW5pcXVlXG4gKiBrZXkgY291bGQgYmUgZW5jb3VudGVyZWQgdHdpY2U6XG4gKlxuICogYGBganNcbiAqIGxldCBhcnIgPSBbJ3NhbWUnLCAnZGlmZmVyZW50JywgJ3NhbWUnLCAnc2FtZSddO1xuICogYGBgXG4gKlxuICogSW4gZ2VuZXJhbCwgd2Ugd2FudCB0byB0cmVhdCB0aGVzZSBpdGVtcyBhcyBfdW5pcXVlIHdpdGhpbiB0aGUgbGlzdF8uIFRvIGRvXG4gKiB0aGlzLCB3ZSB0cmFjayB0aGUgb2NjdXJlbmNlcyBvZiBldmVyeSBpdGVtIGFzIHdlIGl0ZXJhdGUgdGhlIGxpc3QsIGFuZCB3aGVuXG4gKiBhbiBpdGVtIG9jY3VycyBtb3JlIHRoYW4gb25jZSwgd2UgZ2VuZXJhdGUgYSBuZXcgdW5pcXVlIGtleSBqdXN0IGZvciB0aGF0XG4gKiBpdGVtLCBhbmQgdGhhdCBvY2N1cmVuY2Ugd2l0aGluIHRoZSBsaXN0LiBUaGUgbmV4dCB0aW1lIHdlIGl0ZXJhdGUgdGhlIGxpc3QsXG4gKiBhbmQgZW5jb3VudGVyIGFuIGl0ZW0gZm9yIHRoZSBudGggdGltZSwgd2UgY2FuIGdldCB0aGUgX3NhbWVfIGtleSwgYW5kIGxldFxuICogR2xpbW1lciBrbm93IHRoYXQgaXQgc2hvdWxkIHJldXNlIHRoZSBET00gZm9yIHRoZSBwcmV2aW91cyBudGggb2NjdXJlbmNlLlxuICovXG5mdW5jdGlvbiB1bmlxdWVLZXlGb3Ioa2V5Rm9yOiBLZXlGb3IpIHtcbiAgbGV0IHNlZW4gPSBuZXcgV2Vha01hcFdpdGhQcmltaXRpdmVzPG51bWJlcj4oKTtcblxuICByZXR1cm4gKHZhbHVlOiB1bmtub3duLCBtZW1vOiB1bmtub3duKSA9PiB7XG4gICAgbGV0IGtleSA9IGtleUZvcih2YWx1ZSwgbWVtbyk7XG4gICAgbGV0IGNvdW50ID0gc2Vlbi5nZXQoa2V5KSB8fCAwO1xuXG4gICAgc2Vlbi5zZXQoa2V5LCBjb3VudCArIDEpO1xuXG4gICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cblxuICAgIHJldHVybiBpZGVudGl0eUZvck50aE9jY3VyZW5jZShrZXksIGNvdW50KTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUl0ZXJhdG9yUmVmKGxpc3RSZWY6IFJlZmVyZW5jZSwga2V5OiBzdHJpbmcpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbXB1dGVSZWYoKCkgPT4ge1xuICAgIGxldCBpdGVyYWJsZSA9IHZhbHVlRm9yUmVmKGxpc3RSZWYpIGFzIHsgW1N5bWJvbC5pdGVyYXRvcl06IGFueSB9IHwgbnVsbCB8IGZhbHNlO1xuXG4gICAgbGV0IGtleUZvciA9IG1ha2VLZXlGb3Ioa2V5KTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZXJhYmxlKSkge1xuICAgICAgcmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKGl0ZXJhYmxlLCBrZXlGb3IpO1xuICAgIH1cblxuICAgIGxldCBtYXliZUl0ZXJhdG9yID0gdG9JdGVyYXRvcihpdGVyYWJsZSk7XG5cbiAgICBpZiAobWF5YmVJdGVyYXRvciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKEVNUFRZX0FSUkFZLCAoKSA9PiBudWxsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yV3JhcHBlcihtYXliZUl0ZXJhdG9yLCBrZXlGb3IpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUl0ZXJhdG9ySXRlbVJlZihfdmFsdWU6IHVua25vd24pIHtcbiAgbGV0IHZhbHVlID0gX3ZhbHVlO1xuICBsZXQgdGFnID0gY3JlYXRlVGFnKCk7XG5cbiAgcmV0dXJuIGNyZWF0ZUNvbXB1dGVSZWYoXG4gICAgKCkgPT4ge1xuICAgICAgY29uc3VtZVRhZyh0YWcpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIGRpcnR5VGFnKHRhZyk7XG4gICAgICB9XG4gICAgfVxuICApO1xufVxuXG5jbGFzcyBJdGVyYXRvcldyYXBwZXIgaW1wbGVtZW50cyBPcGFxdWVJdGVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5uZXI6IEl0ZXJhdG9yRGVsZWdhdGUsIHByaXZhdGUga2V5Rm9yOiBLZXlGb3IpIHt9XG5cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbm5lci5pc0VtcHR5KCk7XG4gIH1cblxuICBuZXh0KCkge1xuICAgIGxldCBuZXh0VmFsdWUgPSB0aGlzLmlubmVyLm5leHQoKSBhcyBPcGFxdWVJdGVyYXRpb25JdGVtO1xuXG4gICAgaWYgKG5leHRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgbmV4dFZhbHVlLmtleSA9IHRoaXMua2V5Rm9yKG5leHRWYWx1ZS52YWx1ZSwgbmV4dFZhbHVlLm1lbW8pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0VmFsdWU7XG4gIH1cbn1cblxuY2xhc3MgQXJyYXlJdGVyYXRvciBpbXBsZW1lbnRzIE9wYXF1ZUl0ZXJhdG9yIHtcbiAgcHJpdmF0ZSBjdXJyZW50OiB7IGtpbmQ6ICdlbXB0eScgfSB8IHsga2luZDogJ2ZpcnN0JzsgdmFsdWU6IHVua25vd24gfSB8IHsga2luZDogJ3Byb2dyZXNzJyB9O1xuICBwcml2YXRlIHBvcyA9IDA7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpdGVyYXRvcjogdW5rbm93bltdIHwgcmVhZG9ubHkgdW5rbm93bltdLCBwcml2YXRlIGtleUZvcjogS2V5Rm9yKSB7XG4gICAgaWYgKGl0ZXJhdG9yLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5jdXJyZW50ID0geyBraW5kOiAnZW1wdHknIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3VycmVudCA9IHsga2luZDogJ2ZpcnN0JywgdmFsdWU6IGl0ZXJhdG9yW3RoaXMucG9zXSB9O1xuICAgIH1cbiAgfVxuXG4gIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudC5raW5kID09PSAnZW1wdHknO1xuICB9XG5cbiAgbmV4dCgpOiBPcHRpb248SXRlcmF0aW9uSXRlbTx1bmtub3duLCBudW1iZXI+PiB7XG4gICAgbGV0IHZhbHVlOiB1bmtub3duO1xuXG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgaWYgKGN1cnJlbnQua2luZCA9PT0gJ2ZpcnN0Jykge1xuICAgICAgdGhpcy5jdXJyZW50ID0geyBraW5kOiAncHJvZ3Jlc3MnIH07XG4gICAgICB2YWx1ZSA9IGN1cnJlbnQudmFsdWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBvcyA+PSB0aGlzLml0ZXJhdG9yLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuaXRlcmF0b3JbKyt0aGlzLnBvc107XG4gICAgfVxuXG4gICAgbGV0IHsga2V5Rm9yIH0gPSB0aGlzO1xuXG4gICAgbGV0IGtleSA9IGtleUZvcih2YWx1ZSBhcyBEaWN0LCB0aGlzLnBvcyk7XG4gICAgbGV0IG1lbW8gPSB0aGlzLnBvcztcblxuICAgIHJldHVybiB7IGtleSwgdmFsdWUsIG1lbW8gfTtcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==