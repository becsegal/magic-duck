define('@glimmer/util', ['exports', '@glimmer/env'], function (exports, env) { 'use strict';

  var EMPTY_ARRAY = Object.freeze([]);
  function emptyArray() {
    return EMPTY_ARRAY;
  }
  var EMPTY_STRING_ARRAY = emptyArray();
  var EMPTY_NUMBER_ARRAY = emptyArray();
  /**
   * This function returns `true` if the input array is the special empty array sentinel,
   * which is sometimes used for optimizations.
   */

  function isEmptyArray(input) {
    return input === EMPTY_ARRAY;
  }

  // import Logger from './logger';

  function debugAssert(test, msg) {
    // if (!alreadyWarned) {
    //   alreadyWarned = true;
    //   Logger.warn("Don't leave debug assertions on in public builds");
    // }
    if (!test) {
      throw new Error(msg || 'assertion failure');
    }
  }
  function deprecate(desc) {
    LOCAL_LOGGER.warn("DEPRECATION: " + desc);
  }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function dict() {
    return Object.create(null);
  }
  function isDict(u) {
    return u !== null && u !== undefined;
  }
  function isObject(u) {
    return typeof u === 'function' || typeof u === 'object' && u !== null;
  }
  var StackImpl = /*#__PURE__*/function () {
    function StackImpl(values) {
      if (values === void 0) {
        values = [];
      }

      this.current = null;
      this.stack = values;
    }

    var _proto = StackImpl.prototype;

    _proto.push = function push(item) {
      this.current = item;
      this.stack.push(item);
    };

    _proto.pop = function pop() {
      var item = this.stack.pop();
      var len = this.stack.length;
      this.current = len === 0 ? null : this.stack[len - 1];
      return item === undefined ? null : item;
    };

    _proto.nth = function nth(from) {
      var len = this.stack.length;
      return len < from ? null : this.stack[len - from];
    };

    _proto.isEmpty = function isEmpty() {
      return this.stack.length === 0;
    };

    _proto.toArray = function toArray() {
      return this.stack;
    };

    _createClass(StackImpl, [{
      key: "size",
      get: function get() {
        return this.stack.length;
      }
    }]);

    return StackImpl;
  }();

  function clearElement(parent) {
    var current = parent.firstChild;

    while (current) {
      var next = current.nextSibling;
      parent.removeChild(current);
      current = next;
    }
  }

  var SERIALIZATION_FIRST_NODE_STRING = '%+b:0%';
  function isSerializationFirstNode(node) {
    return node.nodeValue === SERIALIZATION_FIRST_NODE_STRING;
  }

  var _a;

  var objKeys = Object.keys;

  function assignFn(obj) {
    for (var i = 1; i < arguments.length; i++) {
      var assignment = arguments[i];
      if (assignment === null || typeof assignment !== 'object') continue;
      var keys = objKeys(assignment);

      for (var j = 0; j < keys.length; j++) {
        var key = keys[j];
        obj[key] = assignment[key];
      }
    }

    return obj;
  }

  var assign = (_a = Object.assign) !== null && _a !== void 0 ? _a : assignFn;
  function fillNulls(count) {
    var arr = new Array(count);

    for (var i = 0; i < count; i++) {
      arr[i] = null;
    }

    return arr;
  }
  function values(obj) {
    var vals = [];

    for (var key in obj) {
      vals.push(obj[key]);
    }

    return vals;
  }

  /**
    Strongly hint runtimes to intern the provided string.

    When do I need to use this function?

    For the most part, never. Pre-mature optimization is bad, and often the
    runtime does exactly what you need it to, and more often the trade-off isn't
    worth it.

    Why?

    Runtimes store strings in at least 2 different representations:
    Ropes and Symbols (interned strings). The Rope provides a memory efficient
    data-structure for strings created from concatenation or some other string
    manipulation like splitting.

    Unfortunately checking equality of different ropes can be quite costly as
    runtimes must resort to clever string comparison algorithms. These
    algorithms typically cost in proportion to the length of the string.
    Luckily, this is where the Symbols (interned strings) shine. As Symbols are
    unique by their string content, equality checks can be done by pointer
    comparison.

    How do I know if my string is a rope or symbol?

    Typically (warning general sweeping statement, but truthy in runtimes at
    present) static strings created as part of the JS source are interned.
    Strings often used for comparisons can be interned at runtime if some
    criteria are met.  One of these criteria can be the size of the entire rope.
    For example, in chrome 38 a rope longer then 12 characters will not
    intern, nor will segments of that rope.

    Some numbers: http://jsperf.com/eval-vs-keys/8

    Known Trickâ„¢

    @private
    @return {String} interned version of the provided string
  */
  function intern(str) {
    var obj = {};
    obj[str] = 1;

    for (var key in obj) {
      if (key === str) {
        return key;
      }
    }

    return str;
  }

  var HAS_NATIVE_PROXY = typeof Proxy === 'function';
  var HAS_NATIVE_SYMBOL = function () {
    if (typeof Symbol !== 'function') {
      return false;
    } // eslint-disable-next-line symbol-description


    return typeof Symbol() === 'symbol';
  }();
  function keys(obj) {
    return Object.keys(obj);
  }
  function unwrap(val) {
    if (val === null || val === undefined) throw new Error("Expected value to be present");
    return val;
  }
  function expect(val, message) {
    if (val === null || val === undefined) throw new Error(message);
    return val;
  }
  function unreachable(message) {
    if (message === void 0) {
      message = 'unreachable';
    }

    return new Error(message);
  }
  function exhausted(value) {
    throw new Error("Exhausted " + value);
  }
  var tuple = function tuple() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return args;
  };
  function enumerableSymbol(key) {
    return intern("__" + key + Math.floor(Math.random() * Date.now()) + "__");
  }
  var symbol = HAS_NATIVE_SYMBOL ? Symbol : enumerableSymbol;

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function strip(strings) {
    var out = '';

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    for (var i = 0; i < strings.length; i++) {
      var string = strings[i];
      var dynamic = args[i] !== undefined ? String(args[i]) : '';
      out += "" + string + dynamic;
    }

    var lines = out.split('\n');

    while (lines.length && lines[0].match(/^\s*$/)) {
      lines.shift();
    }

    while (lines.length && lines[lines.length - 1].match(/^\s*$/)) {
      lines.pop();
    }

    var min = Infinity;

    for (var _iterator = _createForOfIteratorHelperLoose(lines), _step; !(_step = _iterator()).done;) {
      var line = _step.value;
      var leading = line.match(/^\s*/)[0].length;
      min = Math.min(min, leading);
    }

    var stripped = [];

    for (var _iterator2 = _createForOfIteratorHelperLoose(lines), _step2; !(_step2 = _iterator2()).done;) {
      var _line = _step2.value;
      stripped.push(_line.slice(min));
    }

    return stripped.join('\n');
  }

  function isHandle(value) {
    return value >= 0;
  }
  function isNonPrimitiveHandle(value) {
    return value > 3
    /* ENCODED_UNDEFINED_HANDLE */
    ;
  }
  function constants() {
    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }

    return [false, true, null, undefined].concat(values);
  }
  function isSmallInt(value) {
    return value % 1 === 0 && value <= 536870911
    /* MAX_INT */
    && value >= -536870912
    /* MIN_INT */
    ;
  }
  function encodeNegative(num) {

    return num & -536870913
    /* SIGN_BIT */
    ;
  }
  function decodeNegative(num) {

    return num | ~-536870913
    /* SIGN_BIT */
    ;
  }
  function encodePositive(num) {

    return ~num;
  }
  function decodePositive(num) {

    return ~num;
  }
  function encodeHandle(num) {

    return num;
  }
  function decodeHandle(num) {

    return num;
  }
  function encodeImmediate(num) {
    num |= 0;
    return num < 0 ? encodeNegative(num) : encodePositive(num);
  }
  function decodeImmediate(num) {
    num |= 0;
    return num > -536870913
    /* SIGN_BIT */
    ? decodePositive(num) : decodeNegative(num);
  } // Warm
  [1, -1].forEach(function (x) {
    return decodeImmediate(encodeImmediate(x));
  });

  function unwrapHandle(handle) {
    if (typeof handle === 'number') {
      return handle;
    } else {
      var error = handle.errors[0];
      throw new Error("Compile Error: " + error.problem + " @ " + error.span.start + ".." + error.span.end);
    }
  }
  function unwrapTemplate(template) {
    if (template.result === 'error') {
      throw new Error("Compile Error: " + template.problem + " @ " + template.span.start + ".." + template.span.end);
    }

    return template;
  }
  function extractHandle(handle) {
    if (typeof handle === 'number') {
      return handle;
    } else {
      return handle.handle;
    }
  }
  function isOkHandle(handle) {
    return typeof handle === 'number';
  }
  function isErrHandle(handle) {
    return typeof handle === 'number';
  }

  var weakSet = typeof WeakSet === 'function' ? WeakSet : /*#__PURE__*/function () {
    function WeakSetPolyFill() {
      this._map = new WeakMap();
    }

    var _proto = WeakSetPolyFill.prototype;

    _proto.add = function add(val) {
      this._map.set(val, true);

      return this;
    };

    _proto["delete"] = function _delete(val) {
      return this._map["delete"](val);
    };

    _proto.has = function has(val) {
      return this._map.has(val);
    };

    return WeakSetPolyFill;
  }();

  function castToSimple(node) {
    if (isDocument(node)) {
      return node;
    } else if (isElement(node)) {
      return node;
    } else {
      return node;
    }
  }
  function castToBrowser(node, sugaryCheck) {
    if (node === null || node === undefined) {
      return null;
    }

    if (typeof document === undefined) {
      throw new Error('Attempted to cast to a browser node in a non-browser context');
    }

    if (isDocument(node)) {
      return node;
    }

    if (node.ownerDocument !== document) {
      throw new Error('Attempted to cast to a browser node with a node that was not created from this document');
    }

    return checkNode(node, sugaryCheck);
  }

  function checkError(from, check) {
    return new Error("cannot cast a " + from + " into " + check);
  }

  function isDocument(node) {
    return node.nodeType === 9
    /* DOCUMENT_NODE */
    ;
  }

  function isElement(node) {
    return node.nodeType === 1
    /* ELEMENT_NODE */
    ;
  }

  function checkNode(node, check) {
    var isMatch = false;

    if (node !== null) {
      if (typeof check === 'string') {
        isMatch = stringCheckNode(node, check);
      } else if (Array.isArray(check)) {
        isMatch = check.some(function (c) {
          return stringCheckNode(node, c);
        });
      } else {
        throw unreachable();
      }
    }

    if (isMatch) {
      return node;
    } else {
      throw checkError("SimpleElement(" + node + ")", check);
    }
  }

  function stringCheckNode(node, check) {
    switch (check) {
      case 'NODE':
        return true;

      case 'HTML':
        return node instanceof HTMLElement;

      case 'SVG':
        return node instanceof SVGElement;

      case 'ELEMENT':
        return node instanceof Element;

      default:
        if (check.toUpperCase() === check) {
          throw new Error("BUG: this code is missing handling for a generic node type");
        }

        return node instanceof Element && node.tagName.toLowerCase() === check;
    }
  }

  function _createForOfIteratorHelperLoose$1(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

  function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

  function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function isPresent(list) {
    return list.length > 0;
  }
  function ifPresent(list, ifPresent, otherwise) {
    if (isPresent(list)) {
      return ifPresent(list);
    } else {
      return otherwise();
    }
  }
  function toPresentOption(list) {
    if (isPresent(list)) {
      return list;
    } else {
      return null;
    }
  }
  function assertPresent(list, message) {
    if (message === void 0) {
      message = "unexpected empty list";
    }

    if (!isPresent(list)) {
      throw new Error(message);
    }
  }
  function mapPresent(list, callback) {
    if (list === null) {
      return null;
    }

    var out = [];

    for (var _iterator = _createForOfIteratorHelperLoose$1(list), _step; !(_step = _iterator()).done;) {
      var item = _step.value;
      out.push(callback(item));
    }

    return out;
  }

  function buildUntouchableThis(source) {
    var context = null;

    if (env.DEBUG && HAS_NATIVE_PROXY) {
      var assertOnProperty = function assertOnProperty(property) {
        throw new Error("You accessed `this." + String(property) + "` from a function passed to the " + source + ", but the function itself was not bound to a valid `this` context. Consider updating to use a bound function (for instance, use an arrow function, `() => {}`).");
      };

      context = new Proxy({}, {
        get: function get(_target, property) {
          assertOnProperty(property);
        },
        set: function set(_target, property) {
          assertOnProperty(property);
          return false;
        },
        has: function has(_target, property) {
          assertOnProperty(property);
          return false;
        }
      });
    }

    return context;
  }

  var debugToString;

  if (env.DEBUG) {
    var getFunctionName = function getFunctionName(fn) {
      var functionName = fn.name;

      if (functionName === undefined) {
        var match = Function.prototype.toString.call(fn).match(/function (\w+)\s*\(/);
        functionName = match && match[1] || '';
      }

      return functionName.replace(/^bound /, '');
    };

    var getObjectName = function getObjectName(obj) {
      var name;
      var className;

      if (obj.constructor && typeof obj.constructor === 'function') {
        className = getFunctionName(obj.constructor);
      }

      if ('toString' in obj && obj.toString !== Object.prototype.toString && obj.toString !== Function.prototype.toString) {
        name = obj.toString();
      } // If the class has a decent looking name, and the `toString` is one of the
      // default Ember toStrings, replace the constructor portion of the toString
      // with the class name. We check the length of the class name to prevent doing
      // this when the value is minified.


      if (name && name.match(/<.*:ember\d+>/) && className && className[0] !== '_' && className.length > 2 && className !== 'Class') {
        return name.replace(/<.*:/, "<" + className + ":");
      }

      return name || className;
    };

    var getPrimitiveName = function getPrimitiveName(value) {
      return String(value);
    };

    debugToString = function debugToString(value) {
      if (typeof value === 'function') {
        return getFunctionName(value) || "(unknown function)";
      } else if (typeof value === 'object' && value !== null) {
        return getObjectName(value) || "(unknown object)";
      } else {
        return getPrimitiveName(value);
      }
    };
  }

  var debugToString$1 = debugToString;

  var beginTestSteps;
  var endTestSteps;
  var verifySteps;
  var logStep;

  /**
   * This constant exists to make it easier to differentiate normal logs from
   * errant console.logs. LOCAL_LOGGER should only be used inside a
   * LOCAL_SHOULD_LOG check.
   *
   * It does not alleviate the need to check LOCAL_SHOULD_LOG, which is used
   * for stripping.
   */

  var LOCAL_LOGGER = console;
  /**
   * This constant exists to make it easier to differentiate normal logs from
   * errant console.logs. LOGGER can be used outside of LOCAL_SHOULD_LOG checks,
   * and is meant to be used in the rare situation where a console.* call is
   * actually appropriate.
   */

  var LOGGER = console;
  function assertNever(value, desc) {
    if (desc === void 0) {
      desc = 'unexpected unreachable branch';
    }

    LOGGER.log('unreachable', value);
    LOGGER.log(desc + " :: " + JSON.stringify(value) + " (" + value + ")");
    throw new Error("code reached unreachable");
  }

  exports.EMPTY_ARRAY = EMPTY_ARRAY;
  exports.EMPTY_NUMBER_ARRAY = EMPTY_NUMBER_ARRAY;
  exports.EMPTY_STRING_ARRAY = EMPTY_STRING_ARRAY;
  exports.HAS_NATIVE_PROXY = HAS_NATIVE_PROXY;
  exports.HAS_NATIVE_SYMBOL = HAS_NATIVE_SYMBOL;
  exports.LOCAL_LOGGER = LOCAL_LOGGER;
  exports.LOGGER = LOGGER;
  exports.SERIALIZATION_FIRST_NODE_STRING = SERIALIZATION_FIRST_NODE_STRING;
  exports.Stack = StackImpl;
  exports._WeakSet = weakSet;
  exports.assert = debugAssert;
  exports.assertNever = assertNever;
  exports.assertPresent = assertPresent;
  exports.assign = assign;
  exports.beginTestSteps = beginTestSteps;
  exports.buildUntouchableThis = buildUntouchableThis;
  exports.castToBrowser = castToBrowser;
  exports.castToSimple = castToSimple;
  exports.checkNode = checkNode;
  exports.clearElement = clearElement;
  exports.constants = constants;
  exports.debugToString = debugToString$1;
  exports.decodeHandle = decodeHandle;
  exports.decodeImmediate = decodeImmediate;
  exports.decodeNegative = decodeNegative;
  exports.decodePositive = decodePositive;
  exports.deprecate = deprecate;
  exports.dict = dict;
  exports.emptyArray = emptyArray;
  exports.encodeHandle = encodeHandle;
  exports.encodeImmediate = encodeImmediate;
  exports.encodeNegative = encodeNegative;
  exports.encodePositive = encodePositive;
  exports.endTestSteps = endTestSteps;
  exports.enumerableSymbol = enumerableSymbol;
  exports.exhausted = exhausted;
  exports.expect = expect;
  exports.extractHandle = extractHandle;
  exports.fillNulls = fillNulls;
  exports.ifPresent = ifPresent;
  exports.intern = intern;
  exports.isDict = isDict;
  exports.isEmptyArray = isEmptyArray;
  exports.isErrHandle = isErrHandle;
  exports.isHandle = isHandle;
  exports.isNonPrimitiveHandle = isNonPrimitiveHandle;
  exports.isObject = isObject;
  exports.isOkHandle = isOkHandle;
  exports.isPresent = isPresent;
  exports.isSerializationFirstNode = isSerializationFirstNode;
  exports.isSmallInt = isSmallInt;
  exports.keys = keys;
  exports.logStep = logStep;
  exports.mapPresent = mapPresent;
  exports.strip = strip;
  exports.symbol = symbol;
  exports.toPresentOption = toPresentOption;
  exports.tuple = tuple;
  exports.unreachable = unreachable;
  exports.unwrap = unwrap;
  exports.unwrapHandle = unwrapHandle;
  exports.unwrapTemplate = unwrapTemplate;
  exports.values = values;
  exports.verifySteps = verifySteps;

  Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xpbW1lci11dGlsLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9hcnJheS11dGlscy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2Fzc2VydC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2NvbGxlY3Rpb25zLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvdXRpbC9saWIvZG9tLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvdXRpbC9saWIvaXMtc2VyaWFsaXphdGlvbi1maXJzdC1ub2RlLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvdXRpbC9saWIvb2JqZWN0LXV0aWxzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvdXRpbC9saWIvaW50ZXJuLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvdXRpbC9saWIvcGxhdGZvcm0tdXRpbHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9zdHJpbmcudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9pbW1lZGlhdGUudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi90ZW1wbGF0ZS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL3dlYWstc2V0LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvdXRpbC9saWIvc2ltcGxlLWNhc3QudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9wcmVzZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvdXRpbC9saWIvdW50b3VjaGFibGUtdGhpcy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2RlYnVnLXRvLXN0cmluZy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2RlYnVnLXN0ZXBzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvdXRpbC9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgRU1QVFlfQVJSQVk6IHJlYWRvbmx5IHVua25vd25bXSA9IE9iamVjdC5mcmVlemUoW10pIGFzIHJlYWRvbmx5IHVua25vd25bXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5QXJyYXk8VCBleHRlbmRzIHVua25vd24+KCk6IFRbXSB7XG4gIHJldHVybiBFTVBUWV9BUlJBWSBhcyBUW107XG59XG5cbmV4cG9ydCBjb25zdCBFTVBUWV9TVFJJTkdfQVJSQVkgPSBlbXB0eUFycmF5PHN0cmluZz4oKTtcbmV4cG9ydCBjb25zdCBFTVBUWV9OVU1CRVJfQVJSQVkgPSBlbXB0eUFycmF5PG51bWJlcj4oKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgIGlmIHRoZSBpbnB1dCBhcnJheSBpcyB0aGUgc3BlY2lhbCBlbXB0eSBhcnJheSBzZW50aW5lbCxcbiAqIHdoaWNoIGlzIHNvbWV0aW1lcyB1c2VkIGZvciBvcHRpbWl6YXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eUFycmF5KGlucHV0OiB1bmtub3duW10gfCByZWFkb25seSB1bmtub3duW10pOiBib29sZWFuIHtcbiAgcmV0dXJuIGlucHV0ID09PSBFTVBUWV9BUlJBWTtcbn1cbiIsIi8vIGltcG9ydCBMb2dnZXIgZnJvbSAnLi9sb2dnZXInO1xuXG5pbXBvcnQgeyBMT0NBTF9MT0dHRVIgfSBmcm9tICcuLi9pbmRleCc7XG5cbi8vIGxldCBhbHJlYWR5V2FybmVkID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJ1Z0Fzc2VydCh0ZXN0OiBhbnksIG1zZzogc3RyaW5nKTogYXNzZXJ0cyB0ZXN0IHtcbiAgLy8gaWYgKCFhbHJlYWR5V2FybmVkKSB7XG4gIC8vICAgYWxyZWFkeVdhcm5lZCA9IHRydWU7XG4gIC8vICAgTG9nZ2VyLndhcm4oXCJEb24ndCBsZWF2ZSBkZWJ1ZyBhc3NlcnRpb25zIG9uIGluIHB1YmxpYyBidWlsZHNcIik7XG4gIC8vIH1cblxuICBpZiAoIXRlc3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdhc3NlcnRpb24gZmFpbHVyZScpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9kQXNzZXJ0KCkge31cblxuZXhwb3J0IGZ1bmN0aW9uIGRlcHJlY2F0ZShkZXNjOiBzdHJpbmcpIHtcbiAgTE9DQUxfTE9HR0VSLndhcm4oYERFUFJFQ0FUSU9OOiAke2Rlc2N9YCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlYnVnQXNzZXJ0O1xuIiwiaW1wb3J0IHsgRGljdCwgT3B0aW9uLCBTdGFjayB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZGljdDxUID0gdW5rbm93bj4oKTogRGljdDxUPiB7XG4gIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEaWN0PFQ+KHU6IFQpOiB1IGlzIERpY3QgJiBUIHtcbiAgcmV0dXJuIHUgIT09IG51bGwgJiYgdSAhPT0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3Q8VD4odTogVCk6IHUgaXMgb2JqZWN0ICYgVCB7XG4gIHJldHVybiB0eXBlb2YgdSA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIHUgPT09ICdvYmplY3QnICYmIHUgIT09IG51bGwpO1xufVxuXG5leHBvcnQgY2xhc3MgU3RhY2tJbXBsPFQ+IGltcGxlbWVudHMgU3RhY2s8VD4ge1xuICBwcml2YXRlIHN0YWNrOiBUW107XG4gIHB1YmxpYyBjdXJyZW50OiBPcHRpb248VD4gPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKHZhbHVlczogVFtdID0gW10pIHtcbiAgICB0aGlzLnN0YWNrID0gdmFsdWVzO1xuICB9XG5cbiAgcHVibGljIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgfVxuXG4gIHB1c2goaXRlbTogVCkge1xuICAgIHRoaXMuY3VycmVudCA9IGl0ZW07XG4gICAgdGhpcy5zdGFjay5wdXNoKGl0ZW0pO1xuICB9XG5cbiAgcG9wKCk6IE9wdGlvbjxUPiB7XG4gICAgbGV0IGl0ZW0gPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIGxldCBsZW4gPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICB0aGlzLmN1cnJlbnQgPSBsZW4gPT09IDAgPyBudWxsIDogdGhpcy5zdGFja1tsZW4gLSAxXTtcblxuICAgIHJldHVybiBpdGVtID09PSB1bmRlZmluZWQgPyBudWxsIDogaXRlbTtcbiAgfVxuXG4gIG50aChmcm9tOiBudW1iZXIpOiBPcHRpb248VD4ge1xuICAgIGxldCBsZW4gPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICByZXR1cm4gbGVuIDwgZnJvbSA/IG51bGwgOiB0aGlzLnN0YWNrW2xlbiAtIGZyb21dO1xuICB9XG5cbiAgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjay5sZW5ndGggPT09IDA7XG4gIH1cblxuICB0b0FycmF5KCk6IFRbXSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2s7XG4gIH1cbn1cbiIsImltcG9ydCB7IE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgU2ltcGxlRWxlbWVudCwgU2ltcGxlTm9kZSB9IGZyb20gJ0BzaW1wbGUtZG9tL2ludGVyZmFjZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckVsZW1lbnQocGFyZW50OiBTaW1wbGVFbGVtZW50KSB7XG4gIGxldCBjdXJyZW50OiBPcHRpb248U2ltcGxlTm9kZT4gPSBwYXJlbnQuZmlyc3RDaGlsZDtcblxuICB3aGlsZSAoY3VycmVudCkge1xuICAgIGxldCBuZXh0ID0gY3VycmVudC5uZXh0U2libGluZztcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY3VycmVudCk7XG4gICAgY3VycmVudCA9IG5leHQ7XG4gIH1cbn1cbiIsImltcG9ydCB7IFNpbXBsZU5vZGUgfSBmcm9tICdAc2ltcGxlLWRvbS9pbnRlcmZhY2UnO1xuXG5leHBvcnQgY29uc3QgU0VSSUFMSVpBVElPTl9GSVJTVF9OT0RFX1NUUklORyA9ICclK2I6MCUnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTZXJpYWxpemF0aW9uRmlyc3ROb2RlKG5vZGU6IFNpbXBsZU5vZGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIG5vZGUubm9kZVZhbHVlID09PSBTRVJJQUxJWkFUSU9OX0ZJUlNUX05PREVfU1RSSU5HO1xufVxuIiwiY29uc3QgeyBrZXlzOiBvYmpLZXlzIH0gPSBPYmplY3Q7XG5cbmZ1bmN0aW9uIGFzc2lnbkZuPFQsIFU+KG9iajogVCwgYXNzaWdubWVudHM6IFUpOiBUICYgVTtcbmZ1bmN0aW9uIGFzc2lnbkZuPFQsIFUsIFY+KG9iajogVCwgYTogVSwgYjogVik6IFQgJiBVICYgVjtcbmZ1bmN0aW9uIGFzc2lnbkZuPFQsIFUsIFYsIFc+KG9iajogVCwgYTogVSwgYjogViwgYzogVyk6IFQgJiBVICYgViAmIFc7XG5mdW5jdGlvbiBhc3NpZ25GbjxULCBVLCBWLCBXLCBYPihvYmo6IFQsIGE6IFUsIGI6IFYsIGM6IFcsIGQ6IFgpOiBUICYgVSAmIFYgJiBXICYgWDtcbmZ1bmN0aW9uIGFzc2lnbkZuPFQsIFUsIFYsIFcsIFgsIFk+KG9iajogVCwgYTogVSwgYjogViwgYzogVywgZDogWCwgZTogWSk6IFQgJiBVICYgViAmIFcgJiBYICYgWTtcbmZ1bmN0aW9uIGFzc2lnbkZuPFQsIFUsIFYsIFcsIFgsIFksIFo+KFxuICBvYmo6IFQsXG4gIGE6IFUsXG4gIGI6IFYsXG4gIGM6IFcsXG4gIGQ6IFgsXG4gIGU6IFksXG4gIGY6IFpcbik6IFQgJiBVICYgViAmIFcgJiBYICYgWSAmIFo7XG5mdW5jdGlvbiBhc3NpZ25Gbih0YXJnZXQ6IGFueSwgLi4uYXJnczogYW55W10pOiBhbnk7XG5mdW5jdGlvbiBhc3NpZ25GbihvYmo6IGFueSkge1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBhc3NpZ25tZW50ID0gYXJndW1lbnRzW2ldO1xuICAgIGlmIChhc3NpZ25tZW50ID09PSBudWxsIHx8IHR5cGVvZiBhc3NpZ25tZW50ICE9PSAnb2JqZWN0JykgY29udGludWU7XG4gICAgbGV0IGtleXMgPSBvYmpLZXlzKGFzc2lnbm1lbnQpO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgbGV0IGtleSA9IGtleXNbal07XG4gICAgICBvYmpba2V5XSA9IGFzc2lnbm1lbnRba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZXhwb3J0IGxldCBhc3NpZ24gPSBPYmplY3QuYXNzaWduID8/IGFzc2lnbkZuO1xuXG5leHBvcnQgZnVuY3Rpb24gZmlsbE51bGxzPFQ+KGNvdW50OiBudW1iZXIpOiBUW10ge1xuICBsZXQgYXJyID0gbmV3IEFycmF5KGNvdW50KTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICBhcnJbaV0gPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlczxUPihvYmo6IHsgW3M6IHN0cmluZ106IFQgfSk6IFRbXSB7XG4gIGNvbnN0IHZhbHMgPSBbXTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgdmFscy5wdXNoKG9ialtrZXldKTtcbiAgfVxuICByZXR1cm4gdmFscztcbn1cbiIsIi8qKlxuICBTdHJvbmdseSBoaW50IHJ1bnRpbWVzIHRvIGludGVybiB0aGUgcHJvdmlkZWQgc3RyaW5nLlxuXG4gIFdoZW4gZG8gSSBuZWVkIHRvIHVzZSB0aGlzIGZ1bmN0aW9uP1xuXG4gIEZvciB0aGUgbW9zdCBwYXJ0LCBuZXZlci4gUHJlLW1hdHVyZSBvcHRpbWl6YXRpb24gaXMgYmFkLCBhbmQgb2Z0ZW4gdGhlXG4gIHJ1bnRpbWUgZG9lcyBleGFjdGx5IHdoYXQgeW91IG5lZWQgaXQgdG8sIGFuZCBtb3JlIG9mdGVuIHRoZSB0cmFkZS1vZmYgaXNuJ3RcbiAgd29ydGggaXQuXG5cbiAgV2h5P1xuXG4gIFJ1bnRpbWVzIHN0b3JlIHN0cmluZ3MgaW4gYXQgbGVhc3QgMiBkaWZmZXJlbnQgcmVwcmVzZW50YXRpb25zOlxuICBSb3BlcyBhbmQgU3ltYm9scyAoaW50ZXJuZWQgc3RyaW5ncykuIFRoZSBSb3BlIHByb3ZpZGVzIGEgbWVtb3J5IGVmZmljaWVudFxuICBkYXRhLXN0cnVjdHVyZSBmb3Igc3RyaW5ncyBjcmVhdGVkIGZyb20gY29uY2F0ZW5hdGlvbiBvciBzb21lIG90aGVyIHN0cmluZ1xuICBtYW5pcHVsYXRpb24gbGlrZSBzcGxpdHRpbmcuXG5cbiAgVW5mb3J0dW5hdGVseSBjaGVja2luZyBlcXVhbGl0eSBvZiBkaWZmZXJlbnQgcm9wZXMgY2FuIGJlIHF1aXRlIGNvc3RseSBhc1xuICBydW50aW1lcyBtdXN0IHJlc29ydCB0byBjbGV2ZXIgc3RyaW5nIGNvbXBhcmlzb24gYWxnb3JpdGhtcy4gVGhlc2VcbiAgYWxnb3JpdGhtcyB0eXBpY2FsbHkgY29zdCBpbiBwcm9wb3J0aW9uIHRvIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZy5cbiAgTHVja2lseSwgdGhpcyBpcyB3aGVyZSB0aGUgU3ltYm9scyAoaW50ZXJuZWQgc3RyaW5ncykgc2hpbmUuIEFzIFN5bWJvbHMgYXJlXG4gIHVuaXF1ZSBieSB0aGVpciBzdHJpbmcgY29udGVudCwgZXF1YWxpdHkgY2hlY2tzIGNhbiBiZSBkb25lIGJ5IHBvaW50ZXJcbiAgY29tcGFyaXNvbi5cblxuICBIb3cgZG8gSSBrbm93IGlmIG15IHN0cmluZyBpcyBhIHJvcGUgb3Igc3ltYm9sP1xuXG4gIFR5cGljYWxseSAod2FybmluZyBnZW5lcmFsIHN3ZWVwaW5nIHN0YXRlbWVudCwgYnV0IHRydXRoeSBpbiBydW50aW1lcyBhdFxuICBwcmVzZW50KSBzdGF0aWMgc3RyaW5ncyBjcmVhdGVkIGFzIHBhcnQgb2YgdGhlIEpTIHNvdXJjZSBhcmUgaW50ZXJuZWQuXG4gIFN0cmluZ3Mgb2Z0ZW4gdXNlZCBmb3IgY29tcGFyaXNvbnMgY2FuIGJlIGludGVybmVkIGF0IHJ1bnRpbWUgaWYgc29tZVxuICBjcml0ZXJpYSBhcmUgbWV0LiAgT25lIG9mIHRoZXNlIGNyaXRlcmlhIGNhbiBiZSB0aGUgc2l6ZSBvZiB0aGUgZW50aXJlIHJvcGUuXG4gIEZvciBleGFtcGxlLCBpbiBjaHJvbWUgMzggYSByb3BlIGxvbmdlciB0aGVuIDEyIGNoYXJhY3RlcnMgd2lsbCBub3RcbiAgaW50ZXJuLCBub3Igd2lsbCBzZWdtZW50cyBvZiB0aGF0IHJvcGUuXG5cbiAgU29tZSBudW1iZXJzOiBodHRwOi8vanNwZXJmLmNvbS9ldmFsLXZzLWtleXMvOFxuXG4gIEtub3duIFRyaWNr4oSiXG5cbiAgQHByaXZhdGVcbiAgQHJldHVybiB7U3RyaW5nfSBpbnRlcm5lZCB2ZXJzaW9uIG9mIHRoZSBwcm92aWRlZCBzdHJpbmdcbiovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbnRlcm4oc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICBsZXQgb2JqOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gIG9ialtzdHJdID0gMTtcbiAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgIGlmIChrZXkgPT09IHN0cikge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbiIsImltcG9ydCB7IE1heWJlIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgaW50ZXJuIGZyb20gJy4vaW50ZXJuJztcblxuZXhwb3J0IHR5cGUgRmFjdG9yeTxUPiA9IG5ldyAoLi4uYXJnczogdW5rbm93bltdKSA9PiBUO1xuXG5leHBvcnQgY29uc3QgSEFTX05BVElWRV9QUk9YWSA9IHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJztcblxuZXhwb3J0IGNvbnN0IEhBU19OQVRJVkVfU1lNQk9MID0gKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc3ltYm9sLWRlc2NyaXB0aW9uXG4gIHJldHVybiB0eXBlb2YgU3ltYm9sKCkgPT09ICdzeW1ib2wnO1xufSkoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGtleXM8VD4ob2JqOiBUKTogQXJyYXk8a2V5b2YgVD4ge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKSBhcyBBcnJheTxrZXlvZiBUPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcDxUPih2YWw6IE1heWJlPFQ+KTogVCB7XG4gIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgdmFsdWUgdG8gYmUgcHJlc2VudGApO1xuICByZXR1cm4gdmFsIGFzIFQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBlY3Q8VD4odmFsOiBNYXliZTxUPiwgbWVzc2FnZTogc3RyaW5nKTogVCB7XG4gIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIHZhbCBhcyBUO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5yZWFjaGFibGUobWVzc2FnZSA9ICd1bnJlYWNoYWJsZScpOiBFcnJvciB7XG4gIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleGhhdXN0ZWQodmFsdWU6IG5ldmVyKTogbmV2ZXIge1xuICB0aHJvdyBuZXcgRXJyb3IoYEV4aGF1c3RlZCAke3ZhbHVlfWApO1xufVxuXG5leHBvcnQgdHlwZSBMaXQgPSBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgdW5kZWZpbmVkIHwgbnVsbCB8IHZvaWQgfCB7fTtcblxuZXhwb3J0IGNvbnN0IHR1cGxlID0gPFQgZXh0ZW5kcyBMaXRbXT4oLi4uYXJnczogVCkgPT4gYXJncztcblxuZXhwb3J0IGZ1bmN0aW9uIGVudW1lcmFibGVTeW1ib2woa2V5OiBzdHJpbmcpOiBhbnkge1xuICByZXR1cm4gaW50ZXJuKGBfXyR7a2V5fSR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogRGF0ZS5ub3coKSl9X19gKTtcbn1cblxuZXhwb3J0IGNvbnN0IHN5bWJvbCA9IEhBU19OQVRJVkVfU1lNQk9MID8gU3ltYm9sIDogZW51bWVyYWJsZVN5bWJvbDtcbiIsImV4cG9ydCBmdW5jdGlvbiBzdHJpcChzdHJpbmdzOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSwgLi4uYXJnczogdW5rbm93bltdKSB7XG4gIGxldCBvdXQgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHN0cmluZyA9IHN0cmluZ3NbaV07XG4gICAgbGV0IGR5bmFtaWMgPSBhcmdzW2ldICE9PSB1bmRlZmluZWQgPyBTdHJpbmcoYXJnc1tpXSkgOiAnJztcblxuICAgIG91dCArPSBgJHtzdHJpbmd9JHtkeW5hbWljfWA7XG4gIH1cblxuICBsZXQgbGluZXMgPSBvdXQuc3BsaXQoJ1xcbicpO1xuXG4gIHdoaWxlIChsaW5lcy5sZW5ndGggJiYgbGluZXNbMF0ubWF0Y2goL15cXHMqJC8pKSB7XG4gICAgbGluZXMuc2hpZnQoKTtcbiAgfVxuXG4gIHdoaWxlIChsaW5lcy5sZW5ndGggJiYgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubWF0Y2goL15cXHMqJC8pKSB7XG4gICAgbGluZXMucG9wKCk7XG4gIH1cblxuICBsZXQgbWluID0gSW5maW5pdHk7XG5cbiAgZm9yIChsZXQgbGluZSBvZiBsaW5lcykge1xuICAgIGxldCBsZWFkaW5nID0gbGluZS5tYXRjaCgvXlxccyovKSFbMF0ubGVuZ3RoO1xuXG4gICAgbWluID0gTWF0aC5taW4obWluLCBsZWFkaW5nKTtcbiAgfVxuXG4gIGxldCBzdHJpcHBlZCA9IFtdO1xuXG4gIGZvciAobGV0IGxpbmUgb2YgbGluZXMpIHtcbiAgICBzdHJpcHBlZC5wdXNoKGxpbmUuc2xpY2UobWluKSk7XG4gIH1cblxuICByZXR1cm4gc3RyaXBwZWQuam9pbignXFxuJyk7XG59XG4iLCJpbXBvcnQgeyBMT0NBTF9ERUJVRyB9IGZyb20gJ0BnbGltbWVyL2xvY2FsLWRlYnVnLWZsYWdzJztcbmltcG9ydCB7IGRlYnVnQXNzZXJ0IGFzIGFzc2VydCB9IGZyb20gJy4vYXNzZXJ0JztcblxuLypcbiAgRW5jb2Rpbmcgbm90ZXNcblxuICBXZSB1c2UgMzAgYml0IGludGVnZXJzIGZvciBlbmNvZGluZywgc28gdGhhdCB3ZSBkb24ndCBldmVyIGVuY29kZSBhIG5vbi1TTUlcbiAgaW50ZWdlciB0byBwdXNoIG9uIHRoZSBzdGFjay5cblxuICBIYW5kbGVzIGFyZSA+PSAwXG4gIEltbWVkaWF0ZXMgYXJlIDwgMFxuXG4gIFRydWUsIEZhbHNlLCBVbmRlZmluZWQgYW5kIE51bGwgYXJlIHB1c2hlZCBhcyBoYW5kbGVzIGludG8gdGhlIHN5bWJvbCB0YWJsZSxcbiAgd2l0aCB3ZWxsIGtub3duIGhhbmRsZXMgKDAsIDEsIDIsIDMpXG5cbiAgVGhlIG5lZ2F0aXZlIHNwYWNlIGlzIGRpdmlkZWQgaW50byBwb3NpdGl2ZXMgYW5kIG5lZ2F0aXZlcy4gUG9zaXRpdmVzIGFyZVxuICBoaWdoZXIgbnVtYmVycyAoLTEsIC0yLCAtMywgZXRjKSwgbmVnYXRpdmVzIGFyZSBsb3dlci5cblxuICBXZSBvbmx5IGVuY29kZSBpbW1lZGlhdGVzIGZvciB0d28gcmVhc29uczpcblxuICAxLiBUbyB0cmFuc2ZlciBvdmVyIHRoZSB3aXJlLCBzbyB0aGV5J3JlIHNtYWxsZXIgaW4gZ2VuZXJhbFxuICAyLiBXaGVuIHB1c2hpbmcgdmFsdWVzIG9udG8gdGhlIHN0YWNrIGZyb20gdGhlIGxvdyBsZXZlbC9pbm5lciBWTSwgd2hpY2ggbWF5XG4gICAgIGJlIGNvbnZlcnRlZCBpbnRvIFdBU00gb25lIGRheS5cblxuICBUaGlzIGFsbG93cyB0aGUgbG93LWxldmVsIFZNIHRvIGFsd2F5cyB1c2UgU01JcywgYW5kIHRvIG1pbmltaXplIHVzaW5nIEpTXG4gIHZhbHVlcyB2aWEgaGFuZGxlcyBmb3IgdGhpbmdzIGxpa2UgdGhlIHN0YWNrIHBvaW50ZXIgYW5kIGZyYW1lIHBvaW50ZXIuXG4gIEV4dGVybmFsbHksIG1vc3QgY29kZSBwdXNoZXMgdmFsdWVzIGFzIEpTIHZhbHVlcywgZXhjZXB0IHdoZW4gYmVpbmcgcHVsbGVkXG4gIGZyb20gdGhlIGFwcGVuZCBieXRlIGNvZGUgd2hlcmUgaXQgd2FzIGFscmVhZHkgZW5jb2RlZC5cblxuICBMb2dpY2FsbHksIHRoaXMgaXMgYmVjYXVzZSB0aGUgbG93IGxldmVsIFZNIGRvZXNuJ3QgcmVhbGx5IGNhcmUgYWJvdXQgdGhlc2VcbiAgaGlnaGVyIGxldmVsIHZhbHVlcy4gRm9yIGluc3RhbmNlLCB0aGUgcmVzdWx0IG9mIGEgdXNlcmxhbmQgaGVscGVyIG1heSBiZSBhXG4gIG51bWJlciwgb3IgYSBib29sZWFuLCBvciB1bmRlZmluZWQvbnVsbCwgYnV0IGl0J3MgZXh0cmEgd29yayB0byBmaWd1cmUgdGhhdFxuICBvdXQgYW5kIHB1c2ggaXQgY29ycmVjdGx5LCB2cy4ganVzdCBwdXNoaW5nIHRoZSB2YWx1ZSBhcyBhIEpTIHZhbHVlIHdpdGggYVxuICBoYW5kbGUuXG5cbiAgTm90ZTogVGhlIGRldGFpbHMgY291bGQgY2hhbmdlIGhlcmUgaW4gdGhlIGZ1dHVyZSwgdGhpcyBpcyBqdXN0IHRoZSBjdXJyZW50XG4gIHN0cmF0ZWd5LlxuKi9cblxuZXhwb3J0IGNvbnN0IGVudW0gSW1tZWRpYXRlQ29uc3RhbnRzIHtcbiAgTUFYX1NNSSA9IDIgKiogMzAgLSAxLFxuICBNSU5fU01JID0gfk1BWF9TTUksXG4gIFNJR05fQklUID0gfigyICoqIDI5KSxcbiAgTUFYX0lOVCA9IH5TSUdOX0JJVCAtIDEsXG4gIE1JTl9JTlQgPSB+TUFYX0lOVCxcblxuICBGQUxTRV9IQU5ETEUgPSAwLFxuICBUUlVFX0hBTkRMRSA9IDEsXG4gIE5VTExfSEFORExFID0gMixcbiAgVU5ERUZJTkVEX0hBTkRMRSA9IDMsXG5cbiAgRU5DT0RFRF9GQUxTRV9IQU5ETEUgPSBGQUxTRV9IQU5ETEUsXG4gIEVOQ09ERURfVFJVRV9IQU5ETEUgPSBUUlVFX0hBTkRMRSxcbiAgRU5DT0RFRF9OVUxMX0hBTkRMRSA9IE5VTExfSEFORExFLFxuICBFTkNPREVEX1VOREVGSU5FRF9IQU5ETEUgPSBVTkRFRklORURfSEFORExFLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNIYW5kbGUodmFsdWU6IG51bWJlcikge1xuICByZXR1cm4gdmFsdWUgPj0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9uUHJpbWl0aXZlSGFuZGxlKHZhbHVlOiBudW1iZXIpIHtcbiAgcmV0dXJuIHZhbHVlID4gSW1tZWRpYXRlQ29uc3RhbnRzLkVOQ09ERURfVU5ERUZJTkVEX0hBTkRMRTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0YW50cyguLi52YWx1ZXM6IHVua25vd25bXSk6IHVua25vd25bXSB7XG4gIHJldHVybiBbZmFsc2UsIHRydWUsIG51bGwsIHVuZGVmaW5lZCwgLi4udmFsdWVzXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU21hbGxJbnQodmFsdWU6IG51bWJlcikge1xuICByZXR1cm4gKFxuICAgIHZhbHVlICUgMSA9PT0gMCAmJiB2YWx1ZSA8PSBJbW1lZGlhdGVDb25zdGFudHMuTUFYX0lOVCAmJiB2YWx1ZSA+PSBJbW1lZGlhdGVDb25zdGFudHMuTUlOX0lOVFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlTmVnYXRpdmUobnVtOiBudW1iZXIpIHtcbiAgaWYgKExPQ0FMX0RFQlVHKSB7XG4gICAgYXNzZXJ0KFxuICAgICAgbnVtICUgMSA9PT0gMCAmJiBudW0gPj0gSW1tZWRpYXRlQ29uc3RhbnRzLk1JTl9JTlQgJiYgbnVtIDwgMCxcbiAgICAgIGBDb3VsZCBub3QgZW5jb2RlIG5lZ2F0aXZlOiAke251bX1gXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBudW0gJiBJbW1lZGlhdGVDb25zdGFudHMuU0lHTl9CSVQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVOZWdhdGl2ZShudW06IG51bWJlcikge1xuICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICBhc3NlcnQoXG4gICAgICBudW0gJSAxID09PSAwICYmIG51bSA8IH5JbW1lZGlhdGVDb25zdGFudHMuTUFYX0lOVCAmJiBudW0gPj0gSW1tZWRpYXRlQ29uc3RhbnRzLk1JTl9TTUksXG4gICAgICBgQ291bGQgbm90IGRlY29kZSBuZWdhdGl2ZTogJHtudW19YFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbnVtIHwgfkltbWVkaWF0ZUNvbnN0YW50cy5TSUdOX0JJVDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVBvc2l0aXZlKG51bTogbnVtYmVyKSB7XG4gIGlmIChMT0NBTF9ERUJVRykge1xuICAgIGFzc2VydChcbiAgICAgIG51bSAlIDEgPT09IDAgJiYgbnVtID49IDAgJiYgbnVtIDw9IEltbWVkaWF0ZUNvbnN0YW50cy5NQVhfSU5ULFxuICAgICAgYENvdWxkIG5vdCBlbmNvZGUgcG9zaXRpdmU6ICR7bnVtfWBcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIH5udW07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVQb3NpdGl2ZShudW06IG51bWJlcikge1xuICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICBhc3NlcnQoXG4gICAgICBudW0gJSAxID09PSAwICYmIG51bSA8PSAwICYmIG51bSA+PSB+SW1tZWRpYXRlQ29uc3RhbnRzLk1BWF9JTlQsXG4gICAgICBgQ291bGQgbm90IGRlY29kZSBwb3NpdGl2ZTogJHtudW19YFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gfm51bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUhhbmRsZShudW06IG51bWJlcikge1xuICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICBhc3NlcnQoXG4gICAgICBudW0gJSAxID09PSAwICYmIG51bSA+PSAwICYmIG51bSA8PSBJbW1lZGlhdGVDb25zdGFudHMuTUFYX1NNSSxcbiAgICAgIGBDb3VsZCBub3QgZW5jb2RlIGhhbmRsZTogJHtudW19YFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbnVtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlSGFuZGxlKG51bTogbnVtYmVyKSB7XG4gIGlmIChMT0NBTF9ERUJVRykge1xuICAgIGFzc2VydChcbiAgICAgIG51bSAlIDEgPT09IDAgJiYgbnVtIDw9IEltbWVkaWF0ZUNvbnN0YW50cy5NQVhfU01JICYmIG51bSA+PSAwLFxuICAgICAgYENvdWxkIG5vdCBkZWNvZGUgaGFuZGxlOiAke251bX1gXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBudW07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVJbW1lZGlhdGUobnVtOiBudW1iZXIpIHtcbiAgbnVtIHw9IDA7XG4gIHJldHVybiBudW0gPCAwID8gZW5jb2RlTmVnYXRpdmUobnVtKSA6IGVuY29kZVBvc2l0aXZlKG51bSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVJbW1lZGlhdGUobnVtOiBudW1iZXIpIHtcbiAgbnVtIHw9IDA7XG4gIHJldHVybiBudW0gPiBJbW1lZGlhdGVDb25zdGFudHMuU0lHTl9CSVQgPyBkZWNvZGVQb3NpdGl2ZShudW0pIDogZGVjb2RlTmVnYXRpdmUobnVtKTtcbn1cblxuLy8gV2FybVxuWzEsIDIsIDNdLmZvckVhY2goKHgpID0+IGRlY29kZUhhbmRsZShlbmNvZGVIYW5kbGUoeCkpKTtcblsxLCAtMV0uZm9yRWFjaCgoeCkgPT4gZGVjb2RlSW1tZWRpYXRlKGVuY29kZUltbWVkaWF0ZSh4KSkpO1xuIiwiaW1wb3J0IHsgSGFuZGxlUmVzdWx0LCBUZW1wbGF0ZSwgVGVtcGxhdGVPaywgT2tIYW5kbGUsIEVyckhhbmRsZSB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwSGFuZGxlKGhhbmRsZTogSGFuZGxlUmVzdWx0KTogbnVtYmVyIHtcbiAgaWYgKHR5cGVvZiBoYW5kbGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGhhbmRsZTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZXJyb3IgPSBoYW5kbGUuZXJyb3JzWzBdO1xuICAgIHRocm93IG5ldyBFcnJvcihgQ29tcGlsZSBFcnJvcjogJHtlcnJvci5wcm9ibGVtfSBAICR7ZXJyb3Iuc3Bhbi5zdGFydH0uLiR7ZXJyb3Iuc3Bhbi5lbmR9YCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcFRlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZSk6IFRlbXBsYXRlT2sge1xuICBpZiAodGVtcGxhdGUucmVzdWx0ID09PSAnZXJyb3InKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENvbXBpbGUgRXJyb3I6ICR7dGVtcGxhdGUucHJvYmxlbX0gQCAke3RlbXBsYXRlLnNwYW4uc3RhcnR9Li4ke3RlbXBsYXRlLnNwYW4uZW5kfWBcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHRlbXBsYXRlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdEhhbmRsZShoYW5kbGU6IEhhbmRsZVJlc3VsdCk6IG51bWJlciB7XG4gIGlmICh0eXBlb2YgaGFuZGxlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBoYW5kbGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGhhbmRsZS5oYW5kbGU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT2tIYW5kbGUoaGFuZGxlOiBIYW5kbGVSZXN1bHQpOiBoYW5kbGUgaXMgT2tIYW5kbGUge1xuICByZXR1cm4gdHlwZW9mIGhhbmRsZSA9PT0gJ251bWJlcic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VyckhhbmRsZShoYW5kbGU6IEhhbmRsZVJlc3VsdCk6IGhhbmRsZSBpcyBFcnJIYW5kbGUge1xuICByZXR1cm4gdHlwZW9mIGhhbmRsZSA9PT0gJ251bWJlcic7XG59XG4iLCJleHBvcnQgZGVmYXVsdCAodHlwZW9mIFdlYWtTZXQgPT09ICdmdW5jdGlvbidcbiAgPyBXZWFrU2V0XG4gIDogY2xhc3MgV2Vha1NldFBvbHlGaWxsPFQgZXh0ZW5kcyBvYmplY3Q+IHtcbiAgICAgIHByaXZhdGUgX21hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgICAgIGFkZCh2YWw6IFQpOiB0aGlzIHtcbiAgICAgICAgdGhpcy5fbWFwLnNldCh2YWwsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgZGVsZXRlKHZhbDogVCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmRlbGV0ZSh2YWwpO1xuICAgICAgfVxuXG4gICAgICBoYXModmFsOiBUKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKHZhbCk7XG4gICAgICB9XG4gICAgfSkgYXMgV2Vha1NldENvbnN0cnVjdG9yO1xuIiwiaW1wb3J0IHsgdW5yZWFjaGFibGUgfSBmcm9tICcuL3BsYXRmb3JtLXV0aWxzJztcbmltcG9ydCB7IE5vZGVUeXBlLCBTaW1wbGVEb2N1bWVudCwgU2ltcGxlRWxlbWVudCwgU2ltcGxlTm9kZSB9IGZyb20gJ0BzaW1wbGUtZG9tL2ludGVyZmFjZSc7XG5cbmludGVyZmFjZSBHZW5lcmljRWxlbWVudFRhZ3Mge1xuICBIVE1MOiBIVE1MRWxlbWVudDtcbiAgU1ZHOiBTVkdFbGVtZW50O1xuICBFTEVNRU5UOiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQ7XG59XG5cbmludGVyZmFjZSBHZW5lcmljTm9kZVRhZ3Mge1xuICBOT0RFOiBOb2RlO1xufVxuXG50eXBlIEdlbmVyaWNOb2RlVGFnID0ga2V5b2YgR2VuZXJpY05vZGVUYWdzO1xuXG5pbnRlcmZhY2UgQnJvd3NlckVsZW1lbnRUYWdzIGV4dGVuZHMgSFRNTEVsZW1lbnRUYWdOYW1lTWFwLCBHZW5lcmljRWxlbWVudFRhZ3Mge31cbnR5cGUgQnJvd3NlckVsZW1lbnRUYWcgPSBrZXlvZiBCcm93c2VyRWxlbWVudFRhZ3M7XG5cbmludGVyZmFjZSBCcm93c2VyVGFncyBleHRlbmRzIEJyb3dzZXJFbGVtZW50VGFncywgR2VuZXJpY05vZGVUYWdzIHt9XG50eXBlIEJyb3dzZXJUYWcgPSBrZXlvZiBCcm93c2VyVGFncztcblxudHlwZSBOb2RlQ2hlY2s8TiBleHRlbmRzIE5vZGU+ID0gKG5vZGU6IE5vZGUpID0+IG5vZGUgaXMgTjtcbnR5cGUgU3VnYXJ5Tm9kZUNoZWNrPEsgZXh0ZW5kcyBCcm93c2VyVGFnID0gQnJvd3NlclRhZz4gPSBOb2RlQ2hlY2s8QnJvd3NlclRhZ3NbS10+IHwgSyB8IEtbXTtcbnR5cGUgTm9kZUZvclN1Z2FyeUNoZWNrPFMgZXh0ZW5kcyBTdWdhcnlOb2RlQ2hlY2s8QnJvd3NlclRhZz4+ID0gUyBleHRlbmRzIE5vZGVDaGVjazxpbmZlciBOPlxuICA/IE5cbiAgOiBTIGV4dGVuZHMga2V5b2YgQnJvd3NlclRhZ3NcbiAgPyBCcm93c2VyVGFnc1tTXVxuICA6IFMgZXh0ZW5kcyAoa2V5b2YgQnJvd3NlclRhZ3MpW11cbiAgPyBCcm93c2VyVGFnc1tTW251bWJlcl1dXG4gIDogbmV2ZXI7XG5cbnR5cGUgQnJvd3Nlck5vZGUgPSBFbGVtZW50IHwgRG9jdW1lbnQgfCBEb2N1bWVudEZyYWdtZW50IHwgVGV4dCB8IENvbW1lbnQgfCBOb2RlO1xuXG5leHBvcnQgZnVuY3Rpb24gY2FzdFRvU2ltcGxlKGRvYzogRG9jdW1lbnQgfCBTaW1wbGVEb2N1bWVudCk6IFNpbXBsZURvY3VtZW50O1xuZXhwb3J0IGZ1bmN0aW9uIGNhc3RUb1NpbXBsZShlbGVtOiBFbGVtZW50IHwgU2ltcGxlRWxlbWVudCk6IFNpbXBsZUVsZW1lbnQ7XG5leHBvcnQgZnVuY3Rpb24gY2FzdFRvU2ltcGxlKG5vZGU6IE5vZGUgfCBTaW1wbGVOb2RlKTogU2ltcGxlTm9kZTtcbmV4cG9ydCBmdW5jdGlvbiBjYXN0VG9TaW1wbGUoXG4gIG5vZGU6IERvY3VtZW50IHwgRWxlbWVudCB8IE5vZGUgfCBTaW1wbGVEb2N1bWVudCB8IFNpbXBsZUVsZW1lbnQgfCBTaW1wbGVOb2RlXG4pIHtcbiAgaWYgKGlzRG9jdW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZSBhcyBTaW1wbGVEb2N1bWVudDtcbiAgfSBlbHNlIGlmIChpc0VsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZSBhcyBTaW1wbGVFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2RlIGFzIFNpbXBsZU5vZGU7XG4gIH1cbn1cblxuLy8gSWYgcGFzc2VkIGEgZG9jdW1lbnQsIHZlcmlmeSB3ZSdyZSBpbiB0aGUgYnJvd3NlciBhbmQgcmV0dXJuIGl0IGFzIGEgRG9jdW1lbnRcbmV4cG9ydCBmdW5jdGlvbiBjYXN0VG9Ccm93c2VyKGRvYzogRG9jdW1lbnQgfCBTaW1wbGVEb2N1bWVudCk6IERvY3VtZW50O1xuLy8gSWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoaXMgaXMsIGJ1dCB0aGUgY2hlY2sgcmVxdWlyZXMgaXQgdG8gYmUgYW4gZWxlbWVudCxcbi8vIHRoZSBjYXN0IHdpbGwgbWFuZGF0ZSB0aGF0IGl0J3MgYSBicm93c2VyIGVsZW1lbnRcbmV4cG9ydCBmdW5jdGlvbiBjYXN0VG9Ccm93c2VyPFMgZXh0ZW5kcyBTdWdhcnlOb2RlQ2hlY2s8QnJvd3NlckVsZW1lbnRUYWc+PihcbiAgbm9kZTogQnJvd3Nlck5vZGUgfCBTaW1wbGVOb2RlLFxuICBjaGVjazogU1xuKTogTm9kZUZvclN1Z2FyeUNoZWNrPFM+O1xuLy8gRmluYWxseSwgaWYgaXQncyBhIG1vcmUgZ2VuZXJpYyBjaGVjaywgdGhlIGNhc3Qgd2lsbCBtYW5kYXRlIHRoYXQgaXQncyBhXG4vLyBicm93c2VyIG5vZGUgYW5kIHJldHVybiBhIEJyb3dzZXJOb2RlVXRpbHMgY29ycmVzcG9uZGluZyB0byB0aGUgY2hlY2tcbmV4cG9ydCBmdW5jdGlvbiBjYXN0VG9Ccm93c2VyPFMgZXh0ZW5kcyBTdWdhcnlOb2RlQ2hlY2s8R2VuZXJpY05vZGVUYWc+PihcbiAgZWxlbWVudDogQnJvd3Nlck5vZGUgfCBTaW1wbGVOb2RlLFxuICBjaGVjazogU1xuKTogTm9kZUZvclN1Z2FyeUNoZWNrPFM+O1xuZXhwb3J0IGZ1bmN0aW9uIGNhc3RUb0Jyb3dzZXI8SyBleHRlbmRzIGtleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcD4oXG4gIGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQgfCBFbGVtZW50LFxuICBjaGVjazogS1xuKTogSFRNTEVsZW1lbnRUYWdOYW1lTWFwW0tdO1xuZXhwb3J0IGZ1bmN0aW9uIGNhc3RUb0Jyb3dzZXI8UyBleHRlbmRzIFN1Z2FyeU5vZGVDaGVjaz4oXG4gIG5vZGU6IFNpbXBsZU5vZGUgfCBCcm93c2VyTm9kZSB8IG51bGwgfCB1bmRlZmluZWQsXG4gIHN1Z2FyeUNoZWNrPzogU1xuKTogRG9jdW1lbnQgfCBOb2RlRm9yU3VnYXJ5Q2hlY2s8Uz4gfCBudWxsIHtcbiAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBjYXN0IHRvIGEgYnJvd3NlciBub2RlIGluIGEgbm9uLWJyb3dzZXIgY29udGV4dCcpO1xuICB9XG5cbiAgaWYgKGlzRG9jdW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZSBhcyBEb2N1bWVudDtcbiAgfVxuXG4gIGlmIChub2RlLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0F0dGVtcHRlZCB0byBjYXN0IHRvIGEgYnJvd3NlciBub2RlIHdpdGggYSBub2RlIHRoYXQgd2FzIG5vdCBjcmVhdGVkIGZyb20gdGhpcyBkb2N1bWVudCdcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGNoZWNrTm9kZTxTPihub2RlLCBzdWdhcnlDaGVjayEpO1xufVxuXG5mdW5jdGlvbiBjaGVja0Vycm9yKGZyb206IHN0cmluZywgY2hlY2s6IFN1Z2FyeU5vZGVDaGVjayk6IEVycm9yIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihgY2Fubm90IGNhc3QgYSAke2Zyb219IGludG8gJHtjaGVja31gKTtcbn1cblxuZnVuY3Rpb24gaXNEb2N1bWVudChub2RlOiBOb2RlIHwgU2ltcGxlTm9kZSB8IFNpbXBsZURvY3VtZW50KTogbm9kZSBpcyBEb2N1bWVudCB8IFNpbXBsZURvY3VtZW50IHtcbiAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IE5vZGVUeXBlLkRPQ1VNRU5UX05PREU7XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlOiBOb2RlIHwgU2ltcGxlTm9kZSB8IFNpbXBsZUVsZW1lbnQpOiBub2RlIGlzIEVsZW1lbnQgfCBTaW1wbGVFbGVtZW50IHtcbiAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IE5vZGVUeXBlLkVMRU1FTlRfTk9ERTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrTm9kZTxTIGV4dGVuZHMgU3VnYXJ5Tm9kZUNoZWNrPihcbiAgbm9kZTogTm9kZSB8IG51bGwsXG4gIGNoZWNrOiBTXG4pOiBOb2RlRm9yU3VnYXJ5Q2hlY2s8Uz4ge1xuICBsZXQgaXNNYXRjaCA9IGZhbHNlO1xuXG4gIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBjaGVjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlzTWF0Y2ggPSBzdHJpbmdDaGVja05vZGUobm9kZSwgY2hlY2sgYXMgQnJvd3NlclRhZyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoZWNrKSkge1xuICAgICAgaXNNYXRjaCA9IGNoZWNrLnNvbWUoKGMpID0+IHN0cmluZ0NoZWNrTm9kZShub2RlLCBjIGFzIEJyb3dzZXJUYWcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgdW5yZWFjaGFibGUoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNNYXRjaCkge1xuICAgIHJldHVybiBub2RlIGFzIE5vZGVGb3JTdWdhcnlDaGVjazxTPjtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBjaGVja0Vycm9yKGBTaW1wbGVFbGVtZW50KCR7bm9kZX0pYCwgY2hlY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmluZ0NoZWNrTm9kZTxTIGV4dGVuZHMgQnJvd3NlclRhZz4obm9kZTogTm9kZSwgY2hlY2s6IFMpOiBub2RlIGlzIEJyb3dzZXJUYWdzW1NdIHtcbiAgc3dpdGNoIChjaGVjaykge1xuICAgIGNhc2UgJ05PREUnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnSFRNTCc6XG4gICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIGNhc2UgJ1NWRyc6XG4gICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7XG4gICAgY2FzZSAnRUxFTUVOVCc6XG4gICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjaGVjay50b1VwcGVyQ2FzZSgpID09PSBjaGVjaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJVRzogdGhpcyBjb2RlIGlzIG1pc3NpbmcgaGFuZGxpbmcgZm9yIGEgZ2VuZXJpYyBub2RlIHR5cGVgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gY2hlY2s7XG4gIH1cbn1cbiIsImltcG9ydCB7IE9wdGlvbiwgUHJlc2VudEFycmF5IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ByZXNlbnQ8VD4obGlzdDogcmVhZG9ubHkgVFtdKTogbGlzdCBpcyBQcmVzZW50QXJyYXk8VD4ge1xuICByZXR1cm4gbGlzdC5sZW5ndGggPiAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaWZQcmVzZW50PFQsIFUsIFY+KFxuICBsaXN0OiBUW10sXG4gIGlmUHJlc2VudDogKGlucHV0OiBQcmVzZW50QXJyYXk8VD4pID0+IFUsXG4gIG90aGVyd2lzZTogKCkgPT4gVlxuKTogVSB8IFYge1xuICBpZiAoaXNQcmVzZW50KGxpc3QpKSB7XG4gICAgcmV0dXJuIGlmUHJlc2VudChsaXN0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb3RoZXJ3aXNlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUHJlc2VudE9wdGlvbjxUPihsaXN0OiBUW10pOiBPcHRpb248UHJlc2VudEFycmF5PFQ+PiB7XG4gIGlmIChpc1ByZXNlbnQobGlzdCkpIHtcbiAgICByZXR1cm4gbGlzdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UHJlc2VudDxUPihcbiAgbGlzdDogVFtdLFxuICBtZXNzYWdlID0gYHVuZXhwZWN0ZWQgZW1wdHkgbGlzdGBcbik6IGFzc2VydHMgbGlzdCBpcyBQcmVzZW50QXJyYXk8VD4ge1xuICBpZiAoIWlzUHJlc2VudChsaXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwUHJlc2VudDxULCBVPihsaXN0OiBQcmVzZW50QXJyYXk8VD4sIGNhbGxiYWNrOiAoaW5wdXQ6IFQpID0+IFUpOiBQcmVzZW50QXJyYXk8VT47XG5leHBvcnQgZnVuY3Rpb24gbWFwUHJlc2VudDxULCBVPihcbiAgbGlzdDogUHJlc2VudEFycmF5PFQ+IHwgbnVsbCxcbiAgY2FsbGJhY2s6IChpbnB1dDogVCkgPT4gVVxuKTogUHJlc2VudEFycmF5PFU+IHwgbnVsbDtcbmV4cG9ydCBmdW5jdGlvbiBtYXBQcmVzZW50PFQsIFU+KFxuICBsaXN0OiBQcmVzZW50QXJyYXk8VD4gfCBudWxsLFxuICBjYWxsYmFjazogKGlucHV0OiBUKSA9PiBVXG4pOiBQcmVzZW50QXJyYXk8VT4gfCBudWxsIHtcbiAgaWYgKGxpc3QgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgb3V0OiBVW10gPSBbXTtcblxuICBmb3IgKGxldCBpdGVtIG9mIGxpc3QpIHtcbiAgICBvdXQucHVzaChjYWxsYmFjayhpdGVtKSk7XG4gIH1cblxuICByZXR1cm4gb3V0IGFzIFByZXNlbnRBcnJheTxVPjtcbn1cbiIsImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IEhBU19OQVRJVkVfUFJPWFkgfSBmcm9tICcuL3BsYXRmb3JtLXV0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRVbnRvdWNoYWJsZVRoaXMoc291cmNlOiBzdHJpbmcpOiBudWxsIHwgb2JqZWN0IHtcbiAgbGV0IGNvbnRleHQ6IG51bGwgfCBvYmplY3QgPSBudWxsO1xuICBpZiAoREVCVUcgJiYgSEFTX05BVElWRV9QUk9YWSkge1xuICAgIGxldCBhc3NlcnRPblByb3BlcnR5ID0gKHByb3BlcnR5OiBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFlvdSBhY2Nlc3NlZCBcXGB0aGlzLiR7U3RyaW5nKFxuICAgICAgICAgIHByb3BlcnR5XG4gICAgICAgICl9XFxgIGZyb20gYSBmdW5jdGlvbiBwYXNzZWQgdG8gdGhlICR7c291cmNlfSwgYnV0IHRoZSBmdW5jdGlvbiBpdHNlbGYgd2FzIG5vdCBib3VuZCB0byBhIHZhbGlkIFxcYHRoaXNcXGAgY29udGV4dC4gQ29uc2lkZXIgdXBkYXRpbmcgdG8gdXNlIGEgYm91bmQgZnVuY3Rpb24gKGZvciBpbnN0YW5jZSwgdXNlIGFuIGFycm93IGZ1bmN0aW9uLCBcXGAoKSA9PiB7fVxcYCkuYFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgY29udGV4dCA9IG5ldyBQcm94eShcbiAgICAgIHt9LFxuICAgICAge1xuICAgICAgICBnZXQoX3RhcmdldDoge30sIHByb3BlcnR5OiBzdHJpbmcgfCBzeW1ib2wpIHtcbiAgICAgICAgICBhc3NlcnRPblByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQoX3RhcmdldDoge30sIHByb3BlcnR5OiBzdHJpbmcgfCBzeW1ib2wpIHtcbiAgICAgICAgICBhc3NlcnRPblByb3BlcnR5KHByb3BlcnR5KTtcblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYXMoX3RhcmdldDoge30sIHByb3BlcnR5OiBzdHJpbmcgfCBzeW1ib2wpIHtcbiAgICAgICAgICBhc3NlcnRPblByb3BlcnR5KHByb3BlcnR5KTtcblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG4iLCJpbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5cbmxldCBkZWJ1Z1RvU3RyaW5nOiB1bmRlZmluZWQgfCAoKHZhbHVlOiB1bmtub3duKSA9PiBzdHJpbmcpO1xuXG5pZiAoREVCVUcpIHtcbiAgbGV0IGdldEZ1bmN0aW9uTmFtZSA9IChmbjogRnVuY3Rpb24pID0+IHtcbiAgICBsZXQgZnVuY3Rpb25OYW1lID0gZm4ubmFtZTtcblxuICAgIGlmIChmdW5jdGlvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IG1hdGNoID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZm4pLm1hdGNoKC9mdW5jdGlvbiAoXFx3KylcXHMqXFwoLyk7XG5cbiAgICAgIGZ1bmN0aW9uTmFtZSA9IChtYXRjaCAmJiBtYXRjaFsxXSkgfHwgJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uTmFtZS5yZXBsYWNlKC9eYm91bmQgLywgJycpO1xuICB9O1xuXG4gIGxldCBnZXRPYmplY3ROYW1lID0gKG9iajogb2JqZWN0KSA9PiB7XG4gICAgbGV0IG5hbWU7XG4gICAgbGV0IGNsYXNzTmFtZTtcblxuICAgIGlmIChvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2xhc3NOYW1lID0gZ2V0RnVuY3Rpb25OYW1lKG9iai5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgJ3RvU3RyaW5nJyBpbiBvYmogJiZcbiAgICAgIG9iai50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAmJlxuICAgICAgb2JqLnRvU3RyaW5nICE9PSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmdcbiAgICApIHtcbiAgICAgIG5hbWUgPSBvYmoudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgY2xhc3MgaGFzIGEgZGVjZW50IGxvb2tpbmcgbmFtZSwgYW5kIHRoZSBgdG9TdHJpbmdgIGlzIG9uZSBvZiB0aGVcbiAgICAvLyBkZWZhdWx0IEVtYmVyIHRvU3RyaW5ncywgcmVwbGFjZSB0aGUgY29uc3RydWN0b3IgcG9ydGlvbiBvZiB0aGUgdG9TdHJpbmdcbiAgICAvLyB3aXRoIHRoZSBjbGFzcyBuYW1lLiBXZSBjaGVjayB0aGUgbGVuZ3RoIG9mIHRoZSBjbGFzcyBuYW1lIHRvIHByZXZlbnQgZG9pbmdcbiAgICAvLyB0aGlzIHdoZW4gdGhlIHZhbHVlIGlzIG1pbmlmaWVkLlxuICAgIGlmIChcbiAgICAgIG5hbWUgJiZcbiAgICAgIG5hbWUubWF0Y2goLzwuKjplbWJlclxcZCs+LykgJiZcbiAgICAgIGNsYXNzTmFtZSAmJlxuICAgICAgY2xhc3NOYW1lWzBdICE9PSAnXycgJiZcbiAgICAgIGNsYXNzTmFtZS5sZW5ndGggPiAyICYmXG4gICAgICBjbGFzc05hbWUgIT09ICdDbGFzcydcbiAgICApIHtcbiAgICAgIHJldHVybiBuYW1lLnJlcGxhY2UoLzwuKjovLCBgPCR7Y2xhc3NOYW1lfTpgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZSB8fCBjbGFzc05hbWU7XG4gIH07XG5cbiAgbGV0IGdldFByaW1pdGl2ZU5hbWUgPSAodmFsdWU6IGFueSkgPT4ge1xuICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICB9O1xuXG4gIGRlYnVnVG9TdHJpbmcgPSAodmFsdWU6IHVua25vd24pID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZ2V0RnVuY3Rpb25OYW1lKHZhbHVlKSB8fCBgKHVua25vd24gZnVuY3Rpb24pYDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBnZXRPYmplY3ROYW1lKHZhbHVlKSB8fCBgKHVua25vd24gb2JqZWN0KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXRQcmltaXRpdmVOYW1lKHZhbHVlKTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlYnVnVG9TdHJpbmc7XG4iLCJpbXBvcnQgeyBMT0NBTF9ERUJVRyB9IGZyb20gJ0BnbGltbWVyL2xvY2FsLWRlYnVnLWZsYWdzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi9hc3NlcnQnO1xuaW1wb3J0IHsgZXhwZWN0IH0gZnJvbSAnLi9wbGF0Zm9ybS11dGlscyc7XG5cbmV4cG9ydCBsZXQgYmVnaW5UZXN0U3RlcHM6ICgoKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgZW5kVGVzdFN0ZXBzOiAoKCkgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XG5cbmV4cG9ydCBsZXQgdmVyaWZ5U3RlcHM6XG4gIHwgKCh0eXBlOiBzdHJpbmcsIHN0ZXBzOiB1bmtub3duW10gfCAoKHN0ZXBzOiB1bmtub3duW10pID0+IHZvaWQpLCBtZXNzYWdlPzogc3RyaW5nKSA9PiB2b2lkKVxuICB8IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgbG9nU3RlcDogKCh0eXBlOiBzdHJpbmcsIHN0ZXBzOiB1bmtub3duKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcblxuaWYgKExPQ0FMX0RFQlVHKSB7XG4gIGxldCBMT0dHRURfU1RFUFM6IFJlY29yZDxzdHJpbmcsIHVua25vd25bXT4gfCBudWxsID0gbnVsbDtcblxuICBiZWdpblRlc3RTdGVwcyA9ICgpID0+IHtcbiAgICBhc3NlcnQoTE9HR0VEX1NURVBTID09PSBudWxsLCAnYXR0ZW1wdGVkIHRvIHN0YXJ0IHN0ZXBzLCBidXQgaXQgYWxyZWFkeSBiZWdhbicpO1xuXG4gICAgTE9HR0VEX1NURVBTID0ge307XG4gIH07XG5cbiAgZW5kVGVzdFN0ZXBzID0gKCkgPT4ge1xuICAgIGFzc2VydChMT0dHRURfU1RFUFMsICdhdHRlbXB0ZWQgdG8gZW5kIHN0ZXBzLCBidXQgdGhleSB3ZXJlIG5vdCBzdGFydGVkJyk7XG5cbiAgICBMT0dHRURfU1RFUFMgPSBudWxsO1xuICB9O1xuXG4gIGxvZ1N0ZXAgPSAodHlwZTogc3RyaW5nLCBzdGVwOiB1bmtub3duKSA9PiB7XG4gICAgaWYgKExPR0dFRF9TVEVQUyA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgTE9HR0VEX1NURVBTW3R5cGVdID0gTE9HR0VEX1NURVBTW3R5cGVdIHx8IFtdO1xuICAgIExPR0dFRF9TVEVQU1t0eXBlXS5wdXNoKHN0ZXApO1xuICB9O1xuXG4gIHZlcmlmeVN0ZXBzID0gKFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBleHBlY3RlZFN0ZXBzOiB1bmtub3duW10gfCAoKHN0ZXBzOiB1bmtub3duW10pID0+IHZvaWQpLFxuICAgIG1lc3NhZ2U/OiBzdHJpbmdcbiAgKSA9PiB7XG4gICAgbGV0IGxvZ2dlZFN0ZXBzID0gZXhwZWN0KExPR0dFRF9TVEVQUywgJ2F0dGVtcGV0ZCB0byB2ZXJpZnkgc3RlcHMsIGJ1dCBzdGVwcyB3ZXJlIG5vdCBzdGFydGVkJyk7XG5cbiAgICBsZXQgc3RlcHMgPSBsb2dnZWRTdGVwc1t0eXBlXSB8fCBbXTtcblxuICAgIGxvZ2dlZFN0ZXBzW3R5cGVdID0gW107XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZFN0ZXBzKSkge1xuICAgICAgUVVuaXQuY29uZmlnLmN1cnJlbnQuYXNzZXJ0LmRlZXBFcXVhbChzdGVwcywgZXhwZWN0ZWRTdGVwcywgbWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGVjdGVkU3RlcHMoc3RlcHMpO1xuICAgIH1cbiAgfTtcbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vbGliL2FycmF5LXV0aWxzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXNzZXJ0LCBkZXByZWNhdGUgfSBmcm9tICcuL2xpYi9hc3NlcnQnO1xuZXhwb3J0IHsgZGljdCwgaXNEaWN0LCBpc09iamVjdCwgU3RhY2tJbXBsIGFzIFN0YWNrIH0gZnJvbSAnLi9saWIvY29sbGVjdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvZG9tJztcbmV4cG9ydCB7XG4gIGlzU2VyaWFsaXphdGlvbkZpcnN0Tm9kZSxcbiAgU0VSSUFMSVpBVElPTl9GSVJTVF9OT0RFX1NUUklORyxcbn0gZnJvbSAnLi9saWIvaXMtc2VyaWFsaXphdGlvbi1maXJzdC1ub2RlJztcbmV4cG9ydCB7IGFzc2lnbiwgZmlsbE51bGxzLCB2YWx1ZXMgfSBmcm9tICcuL2xpYi9vYmplY3QtdXRpbHMnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvcGxhdGZvcm0tdXRpbHMnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvc3RyaW5nJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL2ltbWVkaWF0ZSc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi90ZW1wbGF0ZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIF9XZWFrU2V0IH0gZnJvbSAnLi9saWIvd2Vhay1zZXQnO1xuZXhwb3J0IHsgY2FzdFRvU2ltcGxlLCBjYXN0VG9Ccm93c2VyLCBjaGVja05vZGUgfSBmcm9tICcuL2xpYi9zaW1wbGUtY2FzdCc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9wcmVzZW50JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaW50ZXJuIH0gZnJvbSAnLi9saWIvaW50ZXJuJztcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBidWlsZFVudG91Y2hhYmxlVGhpcyB9IGZyb20gJy4vbGliL3VudG91Y2hhYmxlLXRoaXMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBkZWJ1Z1RvU3RyaW5nIH0gZnJvbSAnLi9saWIvZGVidWctdG8tc3RyaW5nJztcbmV4cG9ydCB7IGJlZ2luVGVzdFN0ZXBzLCBlbmRUZXN0U3RlcHMsIGxvZ1N0ZXAsIHZlcmlmeVN0ZXBzIH0gZnJvbSAnLi9saWIvZGVidWctc3RlcHMnO1xuXG5leHBvcnQgdHlwZSBGSVhNRTxULCBTIGV4dGVuZHMgc3RyaW5nPiA9IChUICYgUykgfCBUO1xuXG4vKipcbiAqIFRoaXMgY29uc3RhbnQgZXhpc3RzIHRvIG1ha2UgaXQgZWFzaWVyIHRvIGRpZmZlcmVudGlhdGUgbm9ybWFsIGxvZ3MgZnJvbVxuICogZXJyYW50IGNvbnNvbGUubG9ncy4gTE9DQUxfTE9HR0VSIHNob3VsZCBvbmx5IGJlIHVzZWQgaW5zaWRlIGFcbiAqIExPQ0FMX1NIT1VMRF9MT0cgY2hlY2suXG4gKlxuICogSXQgZG9lcyBub3QgYWxsZXZpYXRlIHRoZSBuZWVkIHRvIGNoZWNrIExPQ0FMX1NIT1VMRF9MT0csIHdoaWNoIGlzIHVzZWRcbiAqIGZvciBzdHJpcHBpbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBMT0NBTF9MT0dHRVIgPSBjb25zb2xlO1xuXG4vKipcbiAqIFRoaXMgY29uc3RhbnQgZXhpc3RzIHRvIG1ha2UgaXQgZWFzaWVyIHRvIGRpZmZlcmVudGlhdGUgbm9ybWFsIGxvZ3MgZnJvbVxuICogZXJyYW50IGNvbnNvbGUubG9ncy4gTE9HR0VSIGNhbiBiZSB1c2VkIG91dHNpZGUgb2YgTE9DQUxfU0hPVUxEX0xPRyBjaGVja3MsXG4gKiBhbmQgaXMgbWVhbnQgdG8gYmUgdXNlZCBpbiB0aGUgcmFyZSBzaXR1YXRpb24gd2hlcmUgYSBjb25zb2xlLiogY2FsbCBpc1xuICogYWN0dWFsbHkgYXBwcm9wcmlhdGUuXG4gKi9cbmV4cG9ydCBjb25zdCBMT0dHRVIgPSBjb25zb2xlO1xuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIodmFsdWU6IG5ldmVyLCBkZXNjID0gJ3VuZXhwZWN0ZWQgdW5yZWFjaGFibGUgYnJhbmNoJyk6IG5ldmVyIHtcbiAgTE9HR0VSLmxvZygndW5yZWFjaGFibGUnLCB2YWx1ZSk7XG4gIExPR0dFUi5sb2coYCR7ZGVzY30gOjogJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9ICgke3ZhbHVlfSlgKTtcblxuICB0aHJvdyBuZXcgRXJyb3IoYGNvZGUgcmVhY2hlZCB1bnJlYWNoYWJsZWApO1xufVxuIl0sIm5hbWVzIjpbIkRFQlVHIl0sIm1hcHBpbmdzIjoiOztNQUFhLFdBQVcsR0FBdUIsTUFBTSxDQUFOLE1BQUEsQ0FBeEMsRUFBd0M7RUFFekMsU0FBQSxVQUFBLEdBQW9CO0VBQ3hCLFNBQUEsV0FBQTtFQUNEO01BRVksa0JBQWtCLEdBQUcsVUFBM0I7TUFDTSxrQkFBa0IsR0FBRyxVQUEzQjtFQUVQOzs7OztFQUlNLFNBQUEsWUFBQSxDQUFBLEtBQUEsRUFBNEQ7RUFDaEUsU0FBTyxLQUFLLEtBQVosV0FBQTtFQUNEOztFQ2ZEO0FBRUE7QUFJQSxFQUFNLFNBQUEsV0FBQSxDQUFBLElBQUEsRUFBQSxHQUFBLEVBQTRDO0VBQ2hEO0VBQ0E7RUFDQTtFQUNBO0VBRUEsTUFBSSxDQUFKLElBQUEsRUFBVztFQUNULFVBQU0sSUFBQSxLQUFBLENBQVUsR0FBRyxJQUFuQixtQkFBTSxDQUFO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
