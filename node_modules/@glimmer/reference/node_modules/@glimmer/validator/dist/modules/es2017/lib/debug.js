import { DEBUG } from '@glimmer/env';
import { assert } from '@glimmer/global-context';
export let beginTrackingTransaction;
export let endTrackingTransaction;
export let runInTrackingTransaction;
export let resetTrackingTransaction;
export let setTrackingTransactionEnv;
export let assertTagNotConsumed;
export let markTagAsConsumed;
export let logTrackingStack;

if (DEBUG) {
  let CONSUMED_TAGS = null;
  let TRANSACTION_STACK = []; /////////

  let TRANSACTION_ENV = {
    debugMessage(obj, keyName) {
      let objName;

      if (typeof obj === 'function') {
        objName = obj.name;
      } else if (typeof obj === 'object' && obj !== null) {
        let className = obj.constructor && obj.constructor.name || '(unknown class)';
        objName = `(an instance of ${className})`;
      } else if (obj === undefined) {
        objName = '(an unknown tag)';
      } else {
        objName = String(obj);
      }

      let dirtyString = keyName ? `\`${keyName}\` on \`${objName}\`` : `\`${objName}\``;
      return `You attempted to update ${dirtyString}, but it had already been used previously in the same computation.  Attempting to update a value after using it in a computation can cause logical errors, infinite revalidation bugs, and performance issues, and is not supported.`;
    }

  };

  setTrackingTransactionEnv = env => Object.assign(TRANSACTION_ENV, env);

  beginTrackingTransaction = _debugLabel => {
    CONSUMED_TAGS = CONSUMED_TAGS || new WeakMap();
    let debugLabel = _debugLabel || undefined;
    let parent = TRANSACTION_STACK[TRANSACTION_STACK.length - 1] || null;
    TRANSACTION_STACK.push({
      parent,
      debugLabel
    });
  };

  endTrackingTransaction = () => {
    if (TRANSACTION_STACK.length === 0) {
      throw new Error('attempted to close a tracking transaction, but one was not open');
    }

    TRANSACTION_STACK.pop();

    if (TRANSACTION_STACK.length === 0) {
      CONSUMED_TAGS = null;
    }
  };

  resetTrackingTransaction = () => {
    let stack = '';

    if (TRANSACTION_STACK.length > 0) {
      stack = logTrackingStack(TRANSACTION_STACK[TRANSACTION_STACK.length - 1]);
    }

    TRANSACTION_STACK = [];
    CONSUMED_TAGS = null;
    return stack;
  };
  /**
   * Creates a global autotracking transaction. This will prevent any backflow
   * in any `track` calls within the transaction, even if they are not
   * externally consumed.
   *
   * `runInAutotrackingTransaction` can be called within itself, and it will add
   * onto the existing transaction if one exists.
   *
   * TODO: Only throw an error if the `track` is consumed.
   */


  runInTrackingTransaction = (fn, debugLabel) => {
    beginTrackingTransaction(debugLabel);
    let didError = true;

    try {
      let value = fn();
      didError = false;
      return value;
    } finally {
      if (didError !== true) {
        endTrackingTransaction();
      }
    }
  };

  let nthIndex = (str, pattern, n, startingPos = -1) => {
    let i = startingPos;

    while (n-- > 0 && i++ < str.length) {
      i = str.indexOf(pattern, i);
      if (i < 0) break;
    }

    return i;
  };

  let makeTrackingErrorMessage = (transaction, obj, keyName) => {
    let message = [TRANSACTION_ENV.debugMessage(obj, keyName && String(keyName))];
    message.push(`\`${String(keyName)}\` was first used:`);
    message.push(logTrackingStack(transaction));
    message.push(`Stack trace for the update:`);
    return message.join('\n\n');
  };

  logTrackingStack = transaction => {
    let trackingStack = [];
    let current = transaction || TRANSACTION_STACK[TRANSACTION_STACK.length - 1];
    if (current === undefined) return '';

    while (current) {
      if (current.debugLabel) {
        trackingStack.unshift(current.debugLabel);
      }

      current = current.parent;
    } // TODO: Use String.prototype.repeat here once we can drop support for IE11


    return trackingStack.map((label, index) => Array(2 * index + 1).join(' ') + label).join('\n');
  };

  markTagAsConsumed = _tag => {
    if (!CONSUMED_TAGS || CONSUMED_TAGS.has(_tag)) return;
    CONSUMED_TAGS.set(_tag, TRANSACTION_STACK[TRANSACTION_STACK.length - 1]); // We need to mark the tag and all of its subtags as consumed, so we need to
    // cast it and access its internals. In the future this shouldn't be necessary,
    // this is only for computed properties.

    let tag = _tag;

    if (tag.subtag) {
      markTagAsConsumed(tag.subtag);
    }

    if (tag.subtags) {
      tag.subtags.forEach(tag => markTagAsConsumed(tag));
    }
  };

  assertTagNotConsumed = (tag, obj, keyName) => {
    if (CONSUMED_TAGS === null) return;
    let transaction = CONSUMED_TAGS.get(tag);
    if (!transaction) return; // This hack makes the assertion message nicer, we can cut off the first
    // few lines of the stack trace and let users know where the actual error
    // occurred.

    try {
      assert(false, makeTrackingErrorMessage(transaction, obj, keyName));
    } catch (e) {
      if (e.stack) {
        let updateStackBegin = e.stack.indexOf('Stack trace for the update:');

        if (updateStackBegin !== -1) {
          let start = nthIndex(e.stack, '\n', 1, updateStackBegin);
          let end = nthIndex(e.stack, '\n', 4, updateStackBegin);
          e.stack = e.stack.substr(0, start) + e.stack.substr(end);
        }
      }

      throw e;
    }
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3ZhbGlkYXRvci9saWIvZGVidWcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsU0FBUyxLQUFULFFBQXNCLGNBQXRCO0FBQ0EsU0FBUyxNQUFULFFBQXVCLHlCQUF2QjtBQUVBLE9BQU8sSUFBSSx3QkFBSjtBQUdQLE9BQU8sSUFBSSxzQkFBSjtBQUNQLE9BQU8sSUFBSSx3QkFBSjtBQUlQLE9BQU8sSUFBSSx3QkFBSjtBQUNQLE9BQU8sSUFBSSx5QkFBSjtBQUlQLE9BQU8sSUFBSSxvQkFBSjtBQUlQLE9BQU8sSUFBSSxpQkFBSjtBQUVQLE9BQU8sSUFBSSxnQkFBSjs7QUFPUCxJQUFJLEtBQUosRUFBVztBQUNULE1BQUksYUFBYSxHQUFxQyxJQUF0RDtBQUVBLE1BQUksaUJBQWlCLEdBQWtCLEVBQXZDLENBSFMsQ0FLVDs7QUFFQSxNQUFJLGVBQWUsR0FBRztBQUNwQixJQUFBLFlBQVksQ0FBQyxHQUFELEVBQWdCLE9BQWhCLEVBQWdDO0FBQzFDLFVBQUksT0FBSjs7QUFFQSxVQUFJLE9BQU8sR0FBUCxLQUFlLFVBQW5CLEVBQStCO0FBQzdCLFFBQUEsT0FBTyxHQUFHLEdBQUcsQ0FBQyxJQUFkO0FBQ0QsT0FGRCxNQUVPLElBQUksT0FBTyxHQUFQLEtBQWUsUUFBZixJQUEyQixHQUFHLEtBQUssSUFBdkMsRUFBNkM7QUFDbEQsWUFBSSxTQUFTLEdBQUksR0FBRyxDQUFDLFdBQUosSUFBbUIsR0FBRyxDQUFDLFdBQUosQ0FBZ0IsSUFBcEMsSUFBNkMsaUJBQTdEO0FBRUEsUUFBQSxPQUFPLEdBQUcsbUJBQW1CLFNBQVMsR0FBdEM7QUFDRCxPQUpNLE1BSUEsSUFBSSxHQUFHLEtBQUssU0FBWixFQUF1QjtBQUM1QixRQUFBLE9BQU8sR0FBRyxrQkFBVjtBQUNELE9BRk0sTUFFQTtBQUNMLFFBQUEsT0FBTyxHQUFHLE1BQU0sQ0FBQyxHQUFELENBQWhCO0FBQ0Q7O0FBRUQsVUFBSSxXQUFX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Q0FBQyxDQUFDLEtBQUYsQ0FBUSxNQUFSLENBQWUsR0FBZixDQUFyQztBQUNEO0FBQ0Y7O0FBRUQsWUFBTSxDQUFOO0FBQ0Q7QUFDRixHQXpCRDtBQTBCRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRhZyB9IGZyb20gJy4vdmFsaWRhdG9ycyc7XG5pbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZ2xpbW1lci9nbG9iYWwtY29udGV4dCc7XG5cbmV4cG9ydCBsZXQgYmVnaW5UcmFja2luZ1RyYW5zYWN0aW9uOlxuICB8IHVuZGVmaW5lZFxuICB8ICgoZGVidWdnaW5nQ29udGV4dD86IHN0cmluZyB8IGZhbHNlLCBkZXByZWNhdGU/OiBib29sZWFuKSA9PiB2b2lkKTtcbmV4cG9ydCBsZXQgZW5kVHJhY2tpbmdUcmFuc2FjdGlvbjogdW5kZWZpbmVkIHwgKCgpID0+IHZvaWQpO1xuZXhwb3J0IGxldCBydW5JblRyYWNraW5nVHJhbnNhY3Rpb246XG4gIHwgdW5kZWZpbmVkXG4gIHwgKDxUPihmbjogKCkgPT4gVCwgZGVidWdnaW5nQ29udGV4dD86IHN0cmluZyB8IGZhbHNlKSA9PiBUKTtcblxuZXhwb3J0IGxldCByZXNldFRyYWNraW5nVHJhbnNhY3Rpb246IHVuZGVmaW5lZCB8ICgoKSA9PiBzdHJpbmcpO1xuZXhwb3J0IGxldCBzZXRUcmFja2luZ1RyYW5zYWN0aW9uRW52OlxuICB8IHVuZGVmaW5lZFxuICB8ICgoZW52OiB7IGRlYnVnTWVzc2FnZT8ob2JqPzogdW5rbm93biwga2V5TmFtZT86IHN0cmluZyk6IHN0cmluZyB9KSA9PiB2b2lkKTtcblxuZXhwb3J0IGxldCBhc3NlcnRUYWdOb3RDb25zdW1lZDpcbiAgfCB1bmRlZmluZWRcbiAgfCAoPFQ+KHRhZzogVGFnLCBvYmo/OiBULCBrZXlOYW1lPzoga2V5b2YgVCB8IHN0cmluZyB8IHN5bWJvbCkgPT4gdm9pZCk7XG5cbmV4cG9ydCBsZXQgbWFya1RhZ0FzQ29uc3VtZWQ6IHVuZGVmaW5lZCB8ICgoX3RhZzogVGFnKSA9PiB2b2lkKTtcblxuZXhwb3J0IGxldCBsb2dUcmFja2luZ1N0YWNrOiB1bmRlZmluZWQgfCAoKHRyYW5zYWN0aW9uPzogVHJhbnNhY3Rpb24pID0+IHN0cmluZyk7XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvbiB7XG4gIHBhcmVudDogVHJhbnNhY3Rpb24gfCBudWxsO1xuICBkZWJ1Z0xhYmVsPzogc3RyaW5nO1xufVxuXG5pZiAoREVCVUcpIHtcbiAgbGV0IENPTlNVTUVEX1RBR1M6IFdlYWtNYXA8VGFnLCBUcmFuc2FjdGlvbj4gfCBudWxsID0gbnVsbDtcblxuICBsZXQgVFJBTlNBQ1RJT05fU1RBQ0s6IFRyYW5zYWN0aW9uW10gPSBbXTtcblxuICAvLy8vLy8vLy9cblxuICBsZXQgVFJBTlNBQ1RJT05fRU5WID0ge1xuICAgIGRlYnVnTWVzc2FnZShvYmo/OiB1bmtub3duLCBrZXlOYW1lPzogc3RyaW5nKSB7XG4gICAgICBsZXQgb2JqTmFtZTtcblxuICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JqTmFtZSA9IG9iai5uYW1lO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9IChvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUpIHx8ICcodW5rbm93biBjbGFzcyknO1xuXG4gICAgICAgIG9iak5hbWUgPSBgKGFuIGluc3RhbmNlIG9mICR7Y2xhc3NOYW1lfSlgO1xuICAgICAgfSBlbHNlIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvYmpOYW1lID0gJyhhbiB1bmtub3duIHRhZyknO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqTmFtZSA9IFN0cmluZyhvYmopO1xuICAgICAgfVxuXG4gICAgICBsZXQgZGlydHlTdHJpbmcgPSBrZXlOYW1lID8gYFxcYCR7a2V5TmFtZX1cXGAgb24gXFxgJHtvYmpOYW1lfVxcYGAgOiBgXFxgJHtvYmpOYW1lfVxcYGA7XG5cbiAgICAgIHJldHVybiBgWW91IGF0dGVtcHRlZCB0byB1cGRhdGUgJHtkaXJ0eVN0cmluZ30sIGJ1dCBpdCBoYWQgYWxyZWFkeSBiZWVuIHVzZWQgcHJldmlvdXNseSBpbiB0aGUgc2FtZSBjb21wdXRhdGlvbi4gIEF0dGVtcHRpbmcgdG8gdXBkYXRlIGEgdmFsdWUgYWZ0ZXIgdXNpbmcgaXQgaW4gYSBjb21wdXRhdGlvbiBjYW4gY2F1c2UgbG9naWNhbCBlcnJvcnMsIGluZmluaXRlIHJldmFsaWRhdGlvbiBidWdzLCBhbmQgcGVyZm9ybWFuY2UgaXNzdWVzLCBhbmQgaXMgbm90IHN1cHBvcnRlZC5gO1xuICAgIH0sXG4gIH07XG5cbiAgc2V0VHJhY2tpbmdUcmFuc2FjdGlvbkVudiA9IChlbnYpID0+IE9iamVjdC5hc3NpZ24oVFJBTlNBQ1RJT05fRU5WLCBlbnYpO1xuXG4gIGJlZ2luVHJhY2tpbmdUcmFuc2FjdGlvbiA9IChfZGVidWdMYWJlbD86IHN0cmluZyB8IGZhbHNlKSA9PiB7XG4gICAgQ09OU1VNRURfVEFHUyA9IENPTlNVTUVEX1RBR1MgfHwgbmV3IFdlYWtNYXAoKTtcblxuICAgIGxldCBkZWJ1Z0xhYmVsID0gX2RlYnVnTGFiZWwgfHwgdW5kZWZpbmVkO1xuXG4gICAgbGV0IHBhcmVudCA9IFRSQU5TQUNUSU9OX1NUQUNLW1RSQU5TQUNUSU9OX1NUQUNLLmxlbmd0aCAtIDFdIHx8IG51bGw7XG5cbiAgICBUUkFOU0FDVElPTl9TVEFDSy5wdXNoKHtcbiAgICAgIHBhcmVudCxcbiAgICAgIGRlYnVnTGFiZWwsXG4gICAgfSk7XG4gIH07XG5cbiAgZW5kVHJhY2tpbmdUcmFuc2FjdGlvbiA9ICgpID0+IHtcbiAgICBpZiAoVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F0dGVtcHRlZCB0byBjbG9zZSBhIHRyYWNraW5nIHRyYW5zYWN0aW9uLCBidXQgb25lIHdhcyBub3Qgb3BlbicpO1xuICAgIH1cblxuICAgIFRSQU5TQUNUSU9OX1NUQUNLLnBvcCgpO1xuXG4gICAgaWYgKFRSQU5TQUNUSU9OX1NUQUNLLmxlbmd0aCA9PT0gMCkge1xuICAgICAgQ09OU1VNRURfVEFHUyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHJlc2V0VHJhY2tpbmdUcmFuc2FjdGlvbiA9ICgpID0+IHtcbiAgICBsZXQgc3RhY2sgPSAnJztcblxuICAgIGlmIChUUkFOU0FDVElPTl9TVEFDSy5sZW5ndGggPiAwKSB7XG4gICAgICBzdGFjayA9IGxvZ1RyYWNraW5nU3RhY2shKFRSQU5TQUNUSU9OX1NUQUNLW1RSQU5TQUNUSU9OX1NUQUNLLmxlbmd0aCAtIDFdKTtcbiAgICB9XG5cbiAgICBUUkFOU0FDVElPTl9TVEFDSyA9IFtdO1xuICAgIENPTlNVTUVEX1RBR1MgPSBudWxsO1xuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZ2xvYmFsIGF1dG90cmFja2luZyB0cmFuc2FjdGlvbi4gVGhpcyB3aWxsIHByZXZlbnQgYW55IGJhY2tmbG93XG4gICAqIGluIGFueSBgdHJhY2tgIGNhbGxzIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24sIGV2ZW4gaWYgdGhleSBhcmUgbm90XG4gICAqIGV4dGVybmFsbHkgY29uc3VtZWQuXG4gICAqXG4gICAqIGBydW5JbkF1dG90cmFja2luZ1RyYW5zYWN0aW9uYCBjYW4gYmUgY2FsbGVkIHdpdGhpbiBpdHNlbGYsIGFuZCBpdCB3aWxsIGFkZFxuICAgKiBvbnRvIHRoZSBleGlzdGluZyB0cmFuc2FjdGlvbiBpZiBvbmUgZXhpc3RzLlxuICAgKlxuICAgKiBUT0RPOiBPbmx5IHRocm93IGFuIGVycm9yIGlmIHRoZSBgdHJhY2tgIGlzIGNvbnN1bWVkLlxuICAgKi9cbiAgcnVuSW5UcmFja2luZ1RyYW5zYWN0aW9uID0gPFQ+KGZuOiAoKSA9PiBULCBkZWJ1Z0xhYmVsPzogc3RyaW5nIHwgZmFsc2UpID0+IHtcbiAgICBiZWdpblRyYWNraW5nVHJhbnNhY3Rpb24hKGRlYnVnTGFiZWwpO1xuICAgIGxldCBkaWRFcnJvciA9IHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgbGV0IHZhbHVlID0gZm4oKTtcbiAgICAgIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChkaWRFcnJvciAhPT0gdHJ1ZSkge1xuICAgICAgICBlbmRUcmFja2luZ1RyYW5zYWN0aW9uISgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBsZXQgbnRoSW5kZXggPSAoc3RyOiBzdHJpbmcsIHBhdHRlcm46IHN0cmluZywgbjogbnVtYmVyLCBzdGFydGluZ1BvcyA9IC0xKSA9PiB7XG4gICAgbGV0IGkgPSBzdGFydGluZ1BvcztcblxuICAgIHdoaWxlIChuLS0gPiAwICYmIGkrKyA8IHN0ci5sZW5ndGgpIHtcbiAgICAgIGkgPSBzdHIuaW5kZXhPZihwYXR0ZXJuLCBpKTtcbiAgICAgIGlmIChpIDwgMCkgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGk7XG4gIH07XG5cbiAgbGV0IG1ha2VUcmFja2luZ0Vycm9yTWVzc2FnZSA9IDxUPihcbiAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24sXG4gICAgb2JqPzogVCxcbiAgICBrZXlOYW1lPzoga2V5b2YgVCB8IHN0cmluZyB8IHN5bWJvbFxuICApID0+IHtcbiAgICBsZXQgbWVzc2FnZSA9IFtUUkFOU0FDVElPTl9FTlYuZGVidWdNZXNzYWdlKG9iaiwga2V5TmFtZSAmJiBTdHJpbmcoa2V5TmFtZSkpXTtcblxuICAgIG1lc3NhZ2UucHVzaChgXFxgJHtTdHJpbmcoa2V5TmFtZSl9XFxgIHdhcyBmaXJzdCB1c2VkOmApO1xuXG4gICAgbWVzc2FnZS5wdXNoKGxvZ1RyYWNraW5nU3RhY2shKHRyYW5zYWN0aW9uKSk7XG5cbiAgICBtZXNzYWdlLnB1c2goYFN0YWNrIHRyYWNlIGZvciB0aGUgdXBkYXRlOmApO1xuXG4gICAgcmV0dXJuIG1lc3NhZ2Uuam9pbignXFxuXFxuJyk7XG4gIH07XG5cbiAgbG9nVHJhY2tpbmdTdGFjayA9ICh0cmFuc2FjdGlvbj86IFRyYW5zYWN0aW9uKSA9PiB7XG4gICAgbGV0IHRyYWNraW5nU3RhY2sgPSBbXTtcbiAgICBsZXQgY3VycmVudDogVHJhbnNhY3Rpb24gfCBudWxsIHwgdW5kZWZpbmVkID1cbiAgICAgIHRyYW5zYWN0aW9uIHx8IFRSQU5TQUNUSU9OX1NUQUNLW1RSQU5TQUNUSU9OX1NUQUNLLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGN1cnJlbnQgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuXG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgIGlmIChjdXJyZW50LmRlYnVnTGFiZWwpIHtcbiAgICAgICAgdHJhY2tpbmdTdGFjay51bnNoaWZ0KGN1cnJlbnQuZGVidWdMYWJlbCk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQgaGVyZSBvbmNlIHdlIGNhbiBkcm9wIHN1cHBvcnQgZm9yIElFMTFcbiAgICByZXR1cm4gdHJhY2tpbmdTdGFjay5tYXAoKGxhYmVsLCBpbmRleCkgPT4gQXJyYXkoMiAqIGluZGV4ICsgMSkuam9pbignICcpICsgbGFiZWwpLmpvaW4oJ1xcbicpO1xuICB9O1xuXG4gIG1hcmtUYWdBc0NvbnN1bWVkID0gKF90YWc6IFRhZykgPT4ge1xuICAgIGlmICghQ09OU1VNRURfVEFHUyB8fCBDT05TVU1FRF9UQUdTLmhhcyhfdGFnKSkgcmV0dXJuO1xuXG4gICAgQ09OU1VNRURfVEFHUy5zZXQoX3RhZywgVFJBTlNBQ1RJT05fU1RBQ0tbVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoIC0gMV0pO1xuXG4gICAgLy8gV2UgbmVlZCB0byBtYXJrIHRoZSB0YWcgYW5kIGFsbCBvZiBpdHMgc3VidGFncyBhcyBjb25zdW1lZCwgc28gd2UgbmVlZCB0b1xuICAgIC8vIGNhc3QgaXQgYW5kIGFjY2VzcyBpdHMgaW50ZXJuYWxzLiBJbiB0aGUgZnV0dXJlIHRoaXMgc2hvdWxkbid0IGJlIG5lY2Vzc2FyeSxcbiAgICAvLyB0aGlzIGlzIG9ubHkgZm9yIGNvbXB1dGVkIHByb3BlcnRpZXMuXG4gICAgbGV0IHRhZyA9IF90YWcgYXMgYW55O1xuXG4gICAgaWYgKHRhZy5zdWJ0YWcpIHtcbiAgICAgIG1hcmtUYWdBc0NvbnN1bWVkISh0YWcuc3VidGFnKTtcbiAgICB9XG5cbiAgICBpZiAodGFnLnN1YnRhZ3MpIHtcbiAgICAgIHRhZy5zdWJ0YWdzLmZvckVhY2goKHRhZzogVGFnKSA9PiBtYXJrVGFnQXNDb25zdW1lZCEodGFnKSk7XG4gICAgfVxuICB9O1xuXG4gIGFzc2VydFRhZ05vdENvbnN1bWVkID0gPFQ+KHRhZzogVGFnLCBvYmo/OiBULCBrZXlOYW1lPzoga2V5b2YgVCB8IHN0cmluZyB8IHN5bWJvbCkgPT4ge1xuICAgIGlmIChDT05TVU1FRF9UQUdTID09PSBudWxsKSByZXR1cm47XG5cbiAgICBsZXQgdHJhbnNhY3Rpb24gPSBDT05TVU1FRF9UQUdTLmdldCh0YWcpO1xuXG4gICAgaWYgKCF0cmFuc2FjdGlvbikgcmV0dXJuO1xuXG4gICAgLy8gVGhpcyBoYWNrIG1ha2VzIHRoZSBhc3NlcnRpb24gbWVzc2FnZSBuaWNlciwgd2UgY2FuIGN1dCBvZmYgdGhlIGZpcnN0XG4gICAgLy8gZmV3IGxpbmVzIG9mIHRoZSBzdGFjayB0cmFjZSBhbmQgbGV0IHVzZXJzIGtub3cgd2hlcmUgdGhlIGFjdHVhbCBlcnJvclxuICAgIC8vIG9jY3VycmVkLlxuICAgIHRyeSB7XG4gICAgICBhc3NlcnQoZmFsc2UsIG1ha2VUcmFja2luZ0Vycm9yTWVzc2FnZSh0cmFuc2FjdGlvbiwgb2JqLCBrZXlOYW1lKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuc3RhY2spIHtcbiAgICAgICAgbGV0IHVwZGF0ZVN0YWNrQmVnaW4gPSBlLnN0YWNrLmluZGV4T2YoJ1N0YWNrIHRyYWNlIGZvciB0aGUgdXBkYXRlOicpO1xuXG4gICAgICAgIGlmICh1cGRhdGVTdGFja0JlZ2luICE9PSAtMSkge1xuICAgICAgICAgIGxldCBzdGFydCA9IG50aEluZGV4KGUuc3RhY2ssICdcXG4nLCAxLCB1cGRhdGVTdGFja0JlZ2luKTtcbiAgICAgICAgICBsZXQgZW5kID0gbnRoSW5kZXgoZS5zdGFjaywgJ1xcbicsIDQsIHVwZGF0ZVN0YWNrQmVnaW4pO1xuICAgICAgICAgIGUuc3RhY2sgPSBlLnN0YWNrLnN1YnN0cigwLCBzdGFydCkgKyBlLnN0YWNrLnN1YnN0cihlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==