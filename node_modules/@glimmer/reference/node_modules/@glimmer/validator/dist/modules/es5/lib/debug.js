import { DEBUG } from '@glimmer/env';
import { assert } from '@glimmer/global-context';
export var beginTrackingTransaction;
export var endTrackingTransaction;
export var runInTrackingTransaction;
export var resetTrackingTransaction;
export var setTrackingTransactionEnv;
export var assertTagNotConsumed;

var _markTagAsConsumed;

export { _markTagAsConsumed as markTagAsConsumed };
export var logTrackingStack;

if (DEBUG) {
  var CONSUMED_TAGS = null;
  var TRANSACTION_STACK = []; /////////

  var TRANSACTION_ENV = {
    debugMessage: function debugMessage(obj, keyName) {
      var objName;

      if (typeof obj === 'function') {
        objName = obj.name;
      } else if (typeof obj === 'object' && obj !== null) {
        var className = obj.constructor && obj.constructor.name || '(unknown class)';
        objName = "(an instance of " + className + ")";
      } else if (obj === undefined) {
        objName = '(an unknown tag)';
      } else {
        objName = String(obj);
      }

      var dirtyString = keyName ? "`" + keyName + "` on `" + objName + "`" : "`" + objName + "`";
      return "You attempted to update " + dirtyString + ", but it had already been used previously in the same computation.  Attempting to update a value after using it in a computation can cause logical errors, infinite revalidation bugs, and performance issues, and is not supported.";
    }
  };

  setTrackingTransactionEnv = function setTrackingTransactionEnv(env) {
    return Object.assign(TRANSACTION_ENV, env);
  };

  beginTrackingTransaction = function beginTrackingTransaction(_debugLabel) {
    CONSUMED_TAGS = CONSUMED_TAGS || new WeakMap();
    var debugLabel = _debugLabel || undefined;
    var parent = TRANSACTION_STACK[TRANSACTION_STACK.length - 1] || null;
    TRANSACTION_STACK.push({
      parent: parent,
      debugLabel: debugLabel
    });
  };

  endTrackingTransaction = function endTrackingTransaction() {
    if (TRANSACTION_STACK.length === 0) {
      throw new Error('attempted to close a tracking transaction, but one was not open');
    }

    TRANSACTION_STACK.pop();

    if (TRANSACTION_STACK.length === 0) {
      CONSUMED_TAGS = null;
    }
  };

  resetTrackingTransaction = function resetTrackingTransaction() {
    var stack = '';

    if (TRANSACTION_STACK.length > 0) {
      stack = logTrackingStack(TRANSACTION_STACK[TRANSACTION_STACK.length - 1]);
    }

    TRANSACTION_STACK = [];
    CONSUMED_TAGS = null;
    return stack;
  };
  /**
   * Creates a global autotracking transaction. This will prevent any backflow
   * in any `track` calls within the transaction, even if they are not
   * externally consumed.
   *
   * `runInAutotrackingTransaction` can be called within itself, and it will add
   * onto the existing transaction if one exists.
   *
   * TODO: Only throw an error if the `track` is consumed.
   */


  runInTrackingTransaction = function runInTrackingTransaction(fn, debugLabel) {
    beginTrackingTransaction(debugLabel);
    var didError = true;

    try {
      var value = fn();
      didError = false;
      return value;
    } finally {
      if (didError !== true) {
        endTrackingTransaction();
      }
    }
  };

  var nthIndex = function nthIndex(str, pattern, n, startingPos) {
    if (startingPos === void 0) {
      startingPos = -1;
    }

    var i = startingPos;

    while (n-- > 0 && i++ < str.length) {
      i = str.indexOf(pattern, i);
      if (i < 0) break;
    }

    return i;
  };

  var makeTrackingErrorMessage = function makeTrackingErrorMessage(transaction, obj, keyName) {
    var message = [TRANSACTION_ENV.debugMessage(obj, keyName && String(keyName))];
    message.push("`" + String(keyName) + "` was first used:");
    message.push(logTrackingStack(transaction));
    message.push("Stack trace for the update:");
    return message.join('\n\n');
  };

  logTrackingStack = function logTrackingStack(transaction) {
    var trackingStack = [];
    var current = transaction || TRANSACTION_STACK[TRANSACTION_STACK.length - 1];
    if (current === undefined) return '';

    while (current) {
      if (current.debugLabel) {
        trackingStack.unshift(current.debugLabel);
      }

      current = current.parent;
    } // TODO: Use String.prototype.repeat here once we can drop support for IE11


    return trackingStack.map(function (label, index) {
      return Array(2 * index + 1).join(' ') + label;
    }).join('\n');
  };

  _markTagAsConsumed = function markTagAsConsumed(_tag) {
    if (!CONSUMED_TAGS || CONSUMED_TAGS.has(_tag)) return;
    CONSUMED_TAGS.set(_tag, TRANSACTION_STACK[TRANSACTION_STACK.length - 1]); // We need to mark the tag and all of its subtags as consumed, so we need to
    // cast it and access its internals. In the future this shouldn't be necessary,
    // this is only for computed properties.

    var tag = _tag;

    if (tag.subtag) {
      _markTagAsConsumed(tag.subtag);
    }

    if (tag.subtags) {
      tag.subtags.forEach(function (tag) {
        return _markTagAsConsumed(tag);
      });
    }
  };

  assertTagNotConsumed = function assertTagNotConsumed(tag, obj, keyName) {
    if (CONSUMED_TAGS === null) return;
    var transaction = CONSUMED_TAGS.get(tag);
    if (!transaction) return; // This hack makes the assertion message nicer, we can cut off the first
    // few lines of the stack trace and let users know where the actual error
    // occurred.

    try {
      assert(false, makeTrackingErrorMessage(transaction, obj, keyName));
    } catch (e) {
      if (e.stack) {
        var updateStackBegin = e.stack.indexOf('Stack trace for the update:');

        if (updateStackBegin !== -1) {
          var start = nthIndex(e.stack, '\n', 1, updateStackBegin);
          var end = nthIndex(e.stack, '\n', 4, updateStackBegin);
          e.stack = e.stack.substr(0, start) + e.stack.substr(end);
        }
      }

      throw e;
    }
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3ZhbGlkYXRvci9saWIvZGVidWcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsU0FBQSxLQUFBLFFBQUEsY0FBQTtBQUNBLFNBQUEsTUFBQSxRQUFBLHlCQUFBO0FBRUEsT0FBTyxJQUFBLHdCQUFBO0FBR1AsT0FBTyxJQUFBLHNCQUFBO0FBQ1AsT0FBTyxJQUFBLHdCQUFBO0FBSVAsT0FBTyxJQUFBLHdCQUFBO0FBQ1AsT0FBTyxJQUFBLHlCQUFBO0FBSVAsT0FBTyxJQUFBLG9CQUFBOztBQUlBLElBQUEsa0JBQUE7OztBQUVQLE9BQU8sSUFBQSxnQkFBQTs7QUFPUCxJQUFBLEtBQUEsRUFBVztBQUNULE1BQUksYUFBYSxHQUFqQixJQUFBO0FBRUEsTUFBSSxpQkFBaUIsR0FIWixFQUdULENBSFMsQ0FLVDs7QUFFQSxNQUFJLGVBQWUsR0FBRztBQUNwQixJQUFBLFlBRG9CLHdCQUNSLEdBRFEsRUFDUixPQURRLEVBQ3dCO0FBQzFDLFVBQUEsT0FBQTs7QUFFQSxVQUFJLE9BQUEsR0FBQSxLQUFKLFVBQUEsRUFBK0I7QUFDN0IsUUFBQSxPQUFPLEdBQUcsR0FBRyxDQUFiLElBQUE7QUFERixPQUFBLE1BRU8sSUFBSSxPQUFBLEdBQUEsS0FBQSxRQUFBLElBQTJCLEdBQUcsS0FBbEMsSUFBQSxFQUE2QztBQUNsRCxZQUFJLFNBQVMsR0FBSSxHQUFHLENBQUgsV0FBQSxJQUFtQixHQUFHLENBQUgsV0FBQSxDQUFwQixJQUFDLElBQWpCLGlCQUFBO0FBRUEsUUFBQSxPQUFPLHdCQUFQLFNBQU8sTUFBUDtBQUhLLE9BQUEsTUFJQSxJQUFJLEdBQUcsS0FBUCxTQUFBLEVBQXVCO0FBQzVCLFFBQUEsT0FBTyxHQUFQLGtCQUFBO0FBREssT0FBQSxNQUVBO0FBQ0wsUUFBQSxPQUFPLEdBQUcsTUFBTSxDQUFoQixHQUFnQixDQUFoQjtBQUNEOztBQUVELFVBQUksV0FBVyxHQUFHLE9BQU8sU0FBUSxP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Q0FBRCxLQUFBLEdBQVUsQ0FBQyxDQUFELEtBQUEsQ0FBQSxNQUFBLENBQUEsQ0FBQSxFQUFBLEtBQUEsSUFBMkIsQ0FBQyxDQUFELEtBQUEsQ0FBQSxNQUFBLENBQXJDLEdBQXFDLENBQXJDO0FBQ0Q7QUFDRjs7QUFFRCxZQUFBLENBQUE7QUFDRDtBQXhCSCxHQUFBO0FBMEJEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGFnIH0gZnJvbSAnLi92YWxpZGF0b3JzJztcbmltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BnbGltbWVyL2dsb2JhbC1jb250ZXh0JztcblxuZXhwb3J0IGxldCBiZWdpblRyYWNraW5nVHJhbnNhY3Rpb246XG4gIHwgdW5kZWZpbmVkXG4gIHwgKChkZWJ1Z2dpbmdDb250ZXh0Pzogc3RyaW5nIHwgZmFsc2UsIGRlcHJlY2F0ZT86IGJvb2xlYW4pID0+IHZvaWQpO1xuZXhwb3J0IGxldCBlbmRUcmFja2luZ1RyYW5zYWN0aW9uOiB1bmRlZmluZWQgfCAoKCkgPT4gdm9pZCk7XG5leHBvcnQgbGV0IHJ1bkluVHJhY2tpbmdUcmFuc2FjdGlvbjpcbiAgfCB1bmRlZmluZWRcbiAgfCAoPFQ+KGZuOiAoKSA9PiBULCBkZWJ1Z2dpbmdDb250ZXh0Pzogc3RyaW5nIHwgZmFsc2UpID0+IFQpO1xuXG5leHBvcnQgbGV0IHJlc2V0VHJhY2tpbmdUcmFuc2FjdGlvbjogdW5kZWZpbmVkIHwgKCgpID0+IHN0cmluZyk7XG5leHBvcnQgbGV0IHNldFRyYWNraW5nVHJhbnNhY3Rpb25FbnY6XG4gIHwgdW5kZWZpbmVkXG4gIHwgKChlbnY6IHsgZGVidWdNZXNzYWdlPyhvYmo/OiB1bmtub3duLCBrZXlOYW1lPzogc3RyaW5nKTogc3RyaW5nIH0pID0+IHZvaWQpO1xuXG5leHBvcnQgbGV0IGFzc2VydFRhZ05vdENvbnN1bWVkOlxuICB8IHVuZGVmaW5lZFxuICB8ICg8VD4odGFnOiBUYWcsIG9iaj86IFQsIGtleU5hbWU/OiBrZXlvZiBUIHwgc3RyaW5nIHwgc3ltYm9sKSA9PiB2b2lkKTtcblxuZXhwb3J0IGxldCBtYXJrVGFnQXNDb25zdW1lZDogdW5kZWZpbmVkIHwgKChfdGFnOiBUYWcpID0+IHZvaWQpO1xuXG5leHBvcnQgbGV0IGxvZ1RyYWNraW5nU3RhY2s6IHVuZGVmaW5lZCB8ICgodHJhbnNhY3Rpb24/OiBUcmFuc2FjdGlvbikgPT4gc3RyaW5nKTtcblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uIHtcbiAgcGFyZW50OiBUcmFuc2FjdGlvbiB8IG51bGw7XG4gIGRlYnVnTGFiZWw/OiBzdHJpbmc7XG59XG5cbmlmIChERUJVRykge1xuICBsZXQgQ09OU1VNRURfVEFHUzogV2Vha01hcDxUYWcsIFRyYW5zYWN0aW9uPiB8IG51bGwgPSBudWxsO1xuXG4gIGxldCBUUkFOU0FDVElPTl9TVEFDSzogVHJhbnNhY3Rpb25bXSA9IFtdO1xuXG4gIC8vLy8vLy8vL1xuXG4gIGxldCBUUkFOU0FDVElPTl9FTlYgPSB7XG4gICAgZGVidWdNZXNzYWdlKG9iaj86IHVua25vd24sIGtleU5hbWU/OiBzdHJpbmcpIHtcbiAgICAgIGxldCBvYmpOYW1lO1xuXG4gICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYmpOYW1lID0gb2JqLm5hbWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xuICAgICAgICBsZXQgY2xhc3NOYW1lID0gKG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3IubmFtZSkgfHwgJyh1bmtub3duIGNsYXNzKSc7XG5cbiAgICAgICAgb2JqTmFtZSA9IGAoYW4gaW5zdGFuY2Ugb2YgJHtjbGFzc05hbWV9KWA7XG4gICAgICB9IGVsc2UgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9iak5hbWUgPSAnKGFuIHVua25vd24gdGFnKSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpOYW1lID0gU3RyaW5nKG9iaik7XG4gICAgICB9XG5cbiAgICAgIGxldCBkaXJ0eVN0cmluZyA9IGtleU5hbWUgPyBgXFxgJHtrZXlOYW1lfVxcYCBvbiBcXGAke29iak5hbWV9XFxgYCA6IGBcXGAke29iak5hbWV9XFxgYDtcblxuICAgICAgcmV0dXJuIGBZb3UgYXR0ZW1wdGVkIHRvIHVwZGF0ZSAke2RpcnR5U3RyaW5nfSwgYnV0IGl0IGhhZCBhbHJlYWR5IGJlZW4gdXNlZCBwcmV2aW91c2x5IGluIHRoZSBzYW1lIGNvbXB1dGF0aW9uLiAgQXR0ZW1wdGluZyB0byB1cGRhdGUgYSB2YWx1ZSBhZnRlciB1c2luZyBpdCBpbiBhIGNvbXB1dGF0aW9uIGNhbiBjYXVzZSBsb2dpY2FsIGVycm9ycywgaW5maW5pdGUgcmV2YWxpZGF0aW9uIGJ1Z3MsIGFuZCBwZXJmb3JtYW5jZSBpc3N1ZXMsIGFuZCBpcyBub3Qgc3VwcG9ydGVkLmA7XG4gICAgfSxcbiAgfTtcblxuICBzZXRUcmFja2luZ1RyYW5zYWN0aW9uRW52ID0gKGVudikgPT4gT2JqZWN0LmFzc2lnbihUUkFOU0FDVElPTl9FTlYsIGVudik7XG5cbiAgYmVnaW5UcmFja2luZ1RyYW5zYWN0aW9uID0gKF9kZWJ1Z0xhYmVsPzogc3RyaW5nIHwgZmFsc2UpID0+IHtcbiAgICBDT05TVU1FRF9UQUdTID0gQ09OU1VNRURfVEFHUyB8fCBuZXcgV2Vha01hcCgpO1xuXG4gICAgbGV0IGRlYnVnTGFiZWwgPSBfZGVidWdMYWJlbCB8fCB1bmRlZmluZWQ7XG5cbiAgICBsZXQgcGFyZW50ID0gVFJBTlNBQ1RJT05fU1RBQ0tbVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoIC0gMV0gfHwgbnVsbDtcblxuICAgIFRSQU5TQUNUSU9OX1NUQUNLLnB1c2goe1xuICAgICAgcGFyZW50LFxuICAgICAgZGVidWdMYWJlbCxcbiAgICB9KTtcbiAgfTtcblxuICBlbmRUcmFja2luZ1RyYW5zYWN0aW9uID0gKCkgPT4ge1xuICAgIGlmIChUUkFOU0FDVElPTl9TVEFDSy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYXR0ZW1wdGVkIHRvIGNsb3NlIGEgdHJhY2tpbmcgdHJhbnNhY3Rpb24sIGJ1dCBvbmUgd2FzIG5vdCBvcGVuJyk7XG4gICAgfVxuXG4gICAgVFJBTlNBQ1RJT05fU1RBQ0sucG9wKCk7XG5cbiAgICBpZiAoVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoID09PSAwKSB7XG4gICAgICBDT05TVU1FRF9UQUdTID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgcmVzZXRUcmFja2luZ1RyYW5zYWN0aW9uID0gKCkgPT4ge1xuICAgIGxldCBzdGFjayA9ICcnO1xuXG4gICAgaWYgKFRSQU5TQUNUSU9OX1NUQUNLLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YWNrID0gbG9nVHJhY2tpbmdTdGFjayEoVFJBTlNBQ1RJT05fU1RBQ0tbVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoIC0gMV0pO1xuICAgIH1cblxuICAgIFRSQU5TQUNUSU9OX1NUQUNLID0gW107XG4gICAgQ09OU1VNRURfVEFHUyA9IG51bGw7XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBnbG9iYWwgYXV0b3RyYWNraW5nIHRyYW5zYWN0aW9uLiBUaGlzIHdpbGwgcHJldmVudCBhbnkgYmFja2Zsb3dcbiAgICogaW4gYW55IGB0cmFja2AgY2FsbHMgd2l0aGluIHRoZSB0cmFuc2FjdGlvbiwgZXZlbiBpZiB0aGV5IGFyZSBub3RcbiAgICogZXh0ZXJuYWxseSBjb25zdW1lZC5cbiAgICpcbiAgICogYHJ1bkluQXV0b3RyYWNraW5nVHJhbnNhY3Rpb25gIGNhbiBiZSBjYWxsZWQgd2l0aGluIGl0c2VsZiwgYW5kIGl0IHdpbGwgYWRkXG4gICAqIG9udG8gdGhlIGV4aXN0aW5nIHRyYW5zYWN0aW9uIGlmIG9uZSBleGlzdHMuXG4gICAqXG4gICAqIFRPRE86IE9ubHkgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGB0cmFja2AgaXMgY29uc3VtZWQuXG4gICAqL1xuICBydW5JblRyYWNraW5nVHJhbnNhY3Rpb24gPSA8VD4oZm46ICgpID0+IFQsIGRlYnVnTGFiZWw/OiBzdHJpbmcgfCBmYWxzZSkgPT4ge1xuICAgIGJlZ2luVHJhY2tpbmdUcmFuc2FjdGlvbiEoZGVidWdMYWJlbCk7XG4gICAgbGV0IGRpZEVycm9yID0gdHJ1ZTtcblxuICAgIHRyeSB7XG4gICAgICBsZXQgdmFsdWUgPSBmbigpO1xuICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGRpZEVycm9yICE9PSB0cnVlKSB7XG4gICAgICAgIGVuZFRyYWNraW5nVHJhbnNhY3Rpb24hKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGxldCBudGhJbmRleCA9IChzdHI6IHN0cmluZywgcGF0dGVybjogc3RyaW5nLCBuOiBudW1iZXIsIHN0YXJ0aW5nUG9zID0gLTEpID0+IHtcbiAgICBsZXQgaSA9IHN0YXJ0aW5nUG9zO1xuXG4gICAgd2hpbGUgKG4tLSA+IDAgJiYgaSsrIDwgc3RyLmxlbmd0aCkge1xuICAgICAgaSA9IHN0ci5pbmRleE9mKHBhdHRlcm4sIGkpO1xuICAgICAgaWYgKGkgPCAwKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gaTtcbiAgfTtcblxuICBsZXQgbWFrZVRyYWNraW5nRXJyb3JNZXNzYWdlID0gPFQ+KFxuICAgIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbixcbiAgICBvYmo/OiBULFxuICAgIGtleU5hbWU/OiBrZXlvZiBUIHwgc3RyaW5nIHwgc3ltYm9sXG4gICkgPT4ge1xuICAgIGxldCBtZXNzYWdlID0gW1RSQU5TQUNUSU9OX0VOVi5kZWJ1Z01lc3NhZ2Uob2JqLCBrZXlOYW1lICYmIFN0cmluZyhrZXlOYW1lKSldO1xuXG4gICAgbWVzc2FnZS5wdXNoKGBcXGAke1N0cmluZyhrZXlOYW1lKX1cXGAgd2FzIGZpcnN0IHVzZWQ6YCk7XG5cbiAgICBtZXNzYWdlLnB1c2gobG9nVHJhY2tpbmdTdGFjayEodHJhbnNhY3Rpb24pKTtcblxuICAgIG1lc3NhZ2UucHVzaChgU3RhY2sgdHJhY2UgZm9yIHRoZSB1cGRhdGU6YCk7XG5cbiAgICByZXR1cm4gbWVzc2FnZS5qb2luKCdcXG5cXG4nKTtcbiAgfTtcblxuICBsb2dUcmFja2luZ1N0YWNrID0gKHRyYW5zYWN0aW9uPzogVHJhbnNhY3Rpb24pID0+IHtcbiAgICBsZXQgdHJhY2tpbmdTdGFjayA9IFtdO1xuICAgIGxldCBjdXJyZW50OiBUcmFuc2FjdGlvbiB8IG51bGwgfCB1bmRlZmluZWQgPVxuICAgICAgdHJhbnNhY3Rpb24gfHwgVFJBTlNBQ1RJT05fU1RBQ0tbVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG5cbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgaWYgKGN1cnJlbnQuZGVidWdMYWJlbCkge1xuICAgICAgICB0cmFja2luZ1N0YWNrLnVuc2hpZnQoY3VycmVudC5kZWJ1Z0xhYmVsKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBTdHJpbmcucHJvdG90eXBlLnJlcGVhdCBoZXJlIG9uY2Ugd2UgY2FuIGRyb3Agc3VwcG9ydCBmb3IgSUUxMVxuICAgIHJldHVybiB0cmFja2luZ1N0YWNrLm1hcCgobGFiZWwsIGluZGV4KSA9PiBBcnJheSgyICogaW5kZXggKyAxKS5qb2luKCcgJykgKyBsYWJlbCkuam9pbignXFxuJyk7XG4gIH07XG5cbiAgbWFya1RhZ0FzQ29uc3VtZWQgPSAoX3RhZzogVGFnKSA9PiB7XG4gICAgaWYgKCFDT05TVU1FRF9UQUdTIHx8IENPTlNVTUVEX1RBR1MuaGFzKF90YWcpKSByZXR1cm47XG5cbiAgICBDT05TVU1FRF9UQUdTLnNldChfdGFnLCBUUkFOU0FDVElPTl9TVEFDS1tUUkFOU0FDVElPTl9TVEFDSy5sZW5ndGggLSAxXSk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIG1hcmsgdGhlIHRhZyBhbmQgYWxsIG9mIGl0cyBzdWJ0YWdzIGFzIGNvbnN1bWVkLCBzbyB3ZSBuZWVkIHRvXG4gICAgLy8gY2FzdCBpdCBhbmQgYWNjZXNzIGl0cyBpbnRlcm5hbHMuIEluIHRoZSBmdXR1cmUgdGhpcyBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5LFxuICAgIC8vIHRoaXMgaXMgb25seSBmb3IgY29tcHV0ZWQgcHJvcGVydGllcy5cbiAgICBsZXQgdGFnID0gX3RhZyBhcyBhbnk7XG5cbiAgICBpZiAodGFnLnN1YnRhZykge1xuICAgICAgbWFya1RhZ0FzQ29uc3VtZWQhKHRhZy5zdWJ0YWcpO1xuICAgIH1cblxuICAgIGlmICh0YWcuc3VidGFncykge1xuICAgICAgdGFnLnN1YnRhZ3MuZm9yRWFjaCgodGFnOiBUYWcpID0+IG1hcmtUYWdBc0NvbnN1bWVkISh0YWcpKTtcbiAgICB9XG4gIH07XG5cbiAgYXNzZXJ0VGFnTm90Q29uc3VtZWQgPSA8VD4odGFnOiBUYWcsIG9iaj86IFQsIGtleU5hbWU/OiBrZXlvZiBUIHwgc3RyaW5nIHwgc3ltYm9sKSA9PiB7XG4gICAgaWYgKENPTlNVTUVEX1RBR1MgPT09IG51bGwpIHJldHVybjtcblxuICAgIGxldCB0cmFuc2FjdGlvbiA9IENPTlNVTUVEX1RBR1MuZ2V0KHRhZyk7XG5cbiAgICBpZiAoIXRyYW5zYWN0aW9uKSByZXR1cm47XG5cbiAgICAvLyBUaGlzIGhhY2sgbWFrZXMgdGhlIGFzc2VydGlvbiBtZXNzYWdlIG5pY2VyLCB3ZSBjYW4gY3V0IG9mZiB0aGUgZmlyc3RcbiAgICAvLyBmZXcgbGluZXMgb2YgdGhlIHN0YWNrIHRyYWNlIGFuZCBsZXQgdXNlcnMga25vdyB3aGVyZSB0aGUgYWN0dWFsIGVycm9yXG4gICAgLy8gb2NjdXJyZWQuXG4gICAgdHJ5IHtcbiAgICAgIGFzc2VydChmYWxzZSwgbWFrZVRyYWNraW5nRXJyb3JNZXNzYWdlKHRyYW5zYWN0aW9uLCBvYmosIGtleU5hbWUpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5zdGFjaykge1xuICAgICAgICBsZXQgdXBkYXRlU3RhY2tCZWdpbiA9IGUuc3RhY2suaW5kZXhPZignU3RhY2sgdHJhY2UgZm9yIHRoZSB1cGRhdGU6Jyk7XG5cbiAgICAgICAgaWYgKHVwZGF0ZVN0YWNrQmVnaW4gIT09IC0xKSB7XG4gICAgICAgICAgbGV0IHN0YXJ0ID0gbnRoSW5kZXgoZS5zdGFjaywgJ1xcbicsIDEsIHVwZGF0ZVN0YWNrQmVnaW4pO1xuICAgICAgICAgIGxldCBlbmQgPSBudGhJbmRleChlLnN0YWNrLCAnXFxuJywgNCwgdXBkYXRlU3RhY2tCZWdpbik7XG4gICAgICAgICAgZS5zdGFjayA9IGUuc3RhY2suc3Vic3RyKDAsIHN0YXJ0KSArIGUuc3RhY2suc3Vic3RyKGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH07XG59XG4iXSwic291cmNlUm9vdCI6IiJ9