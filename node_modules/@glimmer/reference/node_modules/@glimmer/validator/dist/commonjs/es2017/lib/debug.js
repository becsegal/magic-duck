"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logTrackingStack = exports.markTagAsConsumed = exports.assertTagNotConsumed = exports.setTrackingTransactionEnv = exports.resetTrackingTransaction = exports.runInTrackingTransaction = exports.endTrackingTransaction = exports.beginTrackingTransaction = void 0;

var _env = require("@glimmer/env");

var _globalContext = require("@glimmer/global-context");

let beginTrackingTransaction;
exports.beginTrackingTransaction = beginTrackingTransaction;
let endTrackingTransaction;
exports.endTrackingTransaction = endTrackingTransaction;
let runInTrackingTransaction;
exports.runInTrackingTransaction = runInTrackingTransaction;
let resetTrackingTransaction;
exports.resetTrackingTransaction = resetTrackingTransaction;
let setTrackingTransactionEnv;
exports.setTrackingTransactionEnv = setTrackingTransactionEnv;
let assertTagNotConsumed;
exports.assertTagNotConsumed = assertTagNotConsumed;
let markTagAsConsumed;
exports.markTagAsConsumed = markTagAsConsumed;
let logTrackingStack;
exports.logTrackingStack = logTrackingStack;

if (_env.DEBUG) {
  let CONSUMED_TAGS = null;
  let TRANSACTION_STACK = []; /////////

  let TRANSACTION_ENV = {
    debugMessage(obj, keyName) {
      let objName;

      if (typeof obj === 'function') {
        objName = obj.name;
      } else if (typeof obj === 'object' && obj !== null) {
        let className = obj.constructor && obj.constructor.name || '(unknown class)';
        objName = `(an instance of ${className})`;
      } else if (obj === undefined) {
        objName = '(an unknown tag)';
      } else {
        objName = String(obj);
      }

      let dirtyString = keyName ? `\`${keyName}\` on \`${objName}\`` : `\`${objName}\``;
      return `You attempted to update ${dirtyString}, but it had already been used previously in the same computation.  Attempting to update a value after using it in a computation can cause logical errors, infinite revalidation bugs, and performance issues, and is not supported.`;
    }

  };

  exports.setTrackingTransactionEnv = setTrackingTransactionEnv = env => Object.assign(TRANSACTION_ENV, env);

  exports.beginTrackingTransaction = beginTrackingTransaction = _debugLabel => {
    CONSUMED_TAGS = CONSUMED_TAGS || new WeakMap();
    let debugLabel = _debugLabel || undefined;
    let parent = TRANSACTION_STACK[TRANSACTION_STACK.length - 1] || null;
    TRANSACTION_STACK.push({
      parent,
      debugLabel
    });
  };

  exports.endTrackingTransaction = endTrackingTransaction = () => {
    if (TRANSACTION_STACK.length === 0) {
      throw new Error('attempted to close a tracking transaction, but one was not open');
    }

    TRANSACTION_STACK.pop();

    if (TRANSACTION_STACK.length === 0) {
      CONSUMED_TAGS = null;
    }
  };

  exports.resetTrackingTransaction = resetTrackingTransaction = () => {
    let stack = '';

    if (TRANSACTION_STACK.length > 0) {
      stack = logTrackingStack(TRANSACTION_STACK[TRANSACTION_STACK.length - 1]);
    }

    TRANSACTION_STACK = [];
    CONSUMED_TAGS = null;
    return stack;
  };
  /**
   * Creates a global autotracking transaction. This will prevent any backflow
   * in any `track` calls within the transaction, even if they are not
   * externally consumed.
   *
   * `runInAutotrackingTransaction` can be called within itself, and it will add
   * onto the existing transaction if one exists.
   *
   * TODO: Only throw an error if the `track` is consumed.
   */


  exports.runInTrackingTransaction = runInTrackingTransaction = (fn, debugLabel) => {
    beginTrackingTransaction(debugLabel);
    let didError = true;

    try {
      let value = fn();
      didError = false;
      return value;
    } finally {
      if (didError !== true) {
        endTrackingTransaction();
      }
    }
  };

  let nthIndex = (str, pattern, n, startingPos = -1) => {
    let i = startingPos;

    while (n-- > 0 && i++ < str.length) {
      i = str.indexOf(pattern, i);
      if (i < 0) break;
    }

    return i;
  };

  let makeTrackingErrorMessage = (transaction, obj, keyName) => {
    let message = [TRANSACTION_ENV.debugMessage(obj, keyName && String(keyName))];
    message.push(`\`${String(keyName)}\` was first used:`);
    message.push(logTrackingStack(transaction));
    message.push(`Stack trace for the update:`);
    return message.join('\n\n');
  };

  exports.logTrackingStack = logTrackingStack = transaction => {
    let trackingStack = [];
    let current = transaction || TRANSACTION_STACK[TRANSACTION_STACK.length - 1];
    if (current === undefined) return '';

    while (current) {
      if (current.debugLabel) {
        trackingStack.unshift(current.debugLabel);
      }

      current = current.parent;
    } // TODO: Use String.prototype.repeat here once we can drop support for IE11


    return trackingStack.map((label, index) => Array(2 * index + 1).join(' ') + label).join('\n');
  };

  exports.markTagAsConsumed = markTagAsConsumed = _tag => {
    if (!CONSUMED_TAGS || CONSUMED_TAGS.has(_tag)) return;
    CONSUMED_TAGS.set(_tag, TRANSACTION_STACK[TRANSACTION_STACK.length - 1]); // We need to mark the tag and all of its subtags as consumed, so we need to
    // cast it and access its internals. In the future this shouldn't be necessary,
    // this is only for computed properties.

    let tag = _tag;

    if (tag.subtag) {
      markTagAsConsumed(tag.subtag);
    }

    if (tag.subtags) {
      tag.subtags.forEach(tag => markTagAsConsumed(tag));
    }
  };

  exports.assertTagNotConsumed = assertTagNotConsumed = (tag, obj, keyName) => {
    if (CONSUMED_TAGS === null) return;
    let transaction = CONSUMED_TAGS.get(tag);
    if (!transaction) return; // This hack makes the assertion message nicer, we can cut off the first
    // few lines of the stack trace and let users know where the actual error
    // occurred.

    try {
      (0, _globalContext.assert)(false, makeTrackingErrorMessage(transaction, obj, keyName));
    } catch (e) {
      if (e.stack) {
        let updateStackBegin = e.stack.indexOf('Stack trace for the update:');

        if (updateStackBegin !== -1) {
          let start = nthIndex(e.stack, '\n', 1, updateStackBegin);
          let end = nthIndex(e.stack, '\n', 4, updateStackBegin);
          e.stack = e.stack.substr(0, start) + e.stack.substr(end);
        }
      }

      throw e;
    }
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3ZhbGlkYXRvci9saWIvZGVidWcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNBOztBQUNBOztBQUVPLElBQUEsd0JBQUE7O0FBR0EsSUFBQSxzQkFBQTs7QUFDQSxJQUFBLHdCQUFBOztBQUlBLElBQUEsd0JBQUE7O0FBQ0EsSUFBQSx5QkFBQTs7QUFJQSxJQUFBLG9CQUFBOztBQUlBLElBQUEsaUJBQUE7O0FBRUEsSUFBQSxnQkFBQTs7O0FBT1AsSUFBQSxVQUFBLEVBQVc7QUFDVCxNQUFJLGFBQWEsR0FBakIsSUFBQTtBQUVBLE1BQUksaUJBQWlCLEdBSFosRUFHVCxDQUhTLENBS1Q7O0FBRUEsTUFBSSxlQUFlLEdBQUc7QUFDcEIsSUFBQSxZQUFZLENBQUEsR0FBQSxFQUFBLE9BQUEsRUFBZ0M7QUFDMUMsVUFBQSxPQUFBOztBQUVBLFVBQUksT0FBQSxHQUFBLEtBQUosVUFBQSxFQUErQjtBQUM3QixRQUFBLE9BQU8sR0FBRyxHQUFHLENBQWIsSUFBQTtBQURGLE9BQUEsTUFFTyxJQUFJLE9BQUEsR0FBQSxLQUFBLFFBQUEsSUFBMkIsR0FBRyxLQUFsQyxJQUFBLEVBQTZDO0FBQ2xELFlBQUksU0FBUyxHQUFJLEdBQUcsQ0FBSCxXQUFBLElBQW1CLEdBQUcsQ0FBSCxXQUFBLENBQXBCLElBQUMsSUFBakIsaUJBQUE7QUFFQSxRQUFBLE9BQU8sR0FBRyxtQkFBbUIsU0FBN0IsR0FBQTtBQUhLLE9BQUEsTUFJQSxJQUFJLEdBQUcsS0FBUCxTQUFBLEVBQXVCO0FBQzVCLFFBQUEsT0FBTyxHQUFQLGtCQUFBO0FBREssT0FBQSxNQUVBO0FBQ0wsUUFBQSxPQUFPLEdBQUcsTUFBTSxDQUFoQixHQUFnQixDQUFoQjtBQUNEOztBQUVELFVBQUksV0FBVyxHQUFHLE9BQU8sR0FBRyxLQUFLLE9BQU8sV0FBVyxPQUExQixJQUFBLEdBQXdDLEtBQUssT0FBdEUsSUFBQTtBQUVBLGFBQU8s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IFRhZyB9IGZyb20gJy4vdmFsaWRhdG9ycyc7XG5pbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZ2xpbW1lci9nbG9iYWwtY29udGV4dCc7XG5cbmV4cG9ydCBsZXQgYmVnaW5UcmFja2luZ1RyYW5zYWN0aW9uOlxuICB8IHVuZGVmaW5lZFxuICB8ICgoZGVidWdnaW5nQ29udGV4dD86IHN0cmluZyB8IGZhbHNlLCBkZXByZWNhdGU/OiBib29sZWFuKSA9PiB2b2lkKTtcbmV4cG9ydCBsZXQgZW5kVHJhY2tpbmdUcmFuc2FjdGlvbjogdW5kZWZpbmVkIHwgKCgpID0+IHZvaWQpO1xuZXhwb3J0IGxldCBydW5JblRyYWNraW5nVHJhbnNhY3Rpb246XG4gIHwgdW5kZWZpbmVkXG4gIHwgKDxUPihmbjogKCkgPT4gVCwgZGVidWdnaW5nQ29udGV4dD86IHN0cmluZyB8IGZhbHNlKSA9PiBUKTtcblxuZXhwb3J0IGxldCByZXNldFRyYWNraW5nVHJhbnNhY3Rpb246IHVuZGVmaW5lZCB8ICgoKSA9PiBzdHJpbmcpO1xuZXhwb3J0IGxldCBzZXRUcmFja2luZ1RyYW5zYWN0aW9uRW52OlxuICB8IHVuZGVmaW5lZFxuICB8ICgoZW52OiB7IGRlYnVnTWVzc2FnZT8ob2JqPzogdW5rbm93biwga2V5TmFtZT86IHN0cmluZyk6IHN0cmluZyB9KSA9PiB2b2lkKTtcblxuZXhwb3J0IGxldCBhc3NlcnRUYWdOb3RDb25zdW1lZDpcbiAgfCB1bmRlZmluZWRcbiAgfCAoPFQ+KHRhZzogVGFnLCBvYmo/OiBULCBrZXlOYW1lPzoga2V5b2YgVCB8IHN0cmluZyB8IHN5bWJvbCkgPT4gdm9pZCk7XG5cbmV4cG9ydCBsZXQgbWFya1RhZ0FzQ29uc3VtZWQ6IHVuZGVmaW5lZCB8ICgoX3RhZzogVGFnKSA9PiB2b2lkKTtcblxuZXhwb3J0IGxldCBsb2dUcmFja2luZ1N0YWNrOiB1bmRlZmluZWQgfCAoKHRyYW5zYWN0aW9uPzogVHJhbnNhY3Rpb24pID0+IHN0cmluZyk7XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvbiB7XG4gIHBhcmVudDogVHJhbnNhY3Rpb24gfCBudWxsO1xuICBkZWJ1Z0xhYmVsPzogc3RyaW5nO1xufVxuXG5pZiAoREVCVUcpIHtcbiAgbGV0IENPTlNVTUVEX1RBR1M6IFdlYWtNYXA8VGFnLCBUcmFuc2FjdGlvbj4gfCBudWxsID0gbnVsbDtcblxuICBsZXQgVFJBTlNBQ1RJT05fU1RBQ0s6IFRyYW5zYWN0aW9uW10gPSBbXTtcblxuICAvLy8vLy8vLy9cblxuICBsZXQgVFJBTlNBQ1RJT05fRU5WID0ge1xuICAgIGRlYnVnTWVzc2FnZShvYmo/OiB1bmtub3duLCBrZXlOYW1lPzogc3RyaW5nKSB7XG4gICAgICBsZXQgb2JqTmFtZTtcblxuICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JqTmFtZSA9IG9iai5uYW1lO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9IChvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUpIHx8ICcodW5rbm93biBjbGFzcyknO1xuXG4gICAgICAgIG9iak5hbWUgPSBgKGFuIGluc3RhbmNlIG9mICR7Y2xhc3NOYW1lfSlgO1xuICAgICAgfSBlbHNlIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvYmpOYW1lID0gJyhhbiB1bmtub3duIHRhZyknO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqTmFtZSA9IFN0cmluZyhvYmopO1xuICAgICAgfVxuXG4gICAgICBsZXQgZGlydHlTdHJpbmcgPSBrZXlOYW1lID8gYFxcYCR7a2V5TmFtZX1cXGAgb24gXFxgJHtvYmpOYW1lfVxcYGAgOiBgXFxgJHtvYmpOYW1lfVxcYGA7XG5cbiAgICAgIHJldHVybiBgWW91IGF0dGVtcHRlZCB0byB1cGRhdGUgJHtkaXJ0eVN0cmluZ30sIGJ1dCBpdCBoYWQgYWxyZWFkeSBiZWVuIHVzZWQgcHJldmlvdXNseSBpbiB0aGUgc2FtZSBjb21wdXRhdGlvbi4gIEF0dGVtcHRpbmcgdG8gdXBkYXRlIGEgdmFsdWUgYWZ0ZXIgdXNpbmcgaXQgaW4gYSBjb21wdXRhdGlvbiBjYW4gY2F1c2UgbG9naWNhbCBlcnJvcnMsIGluZmluaXRlIHJldmFsaWRhdGlvbiBidWdzLCBhbmQgcGVyZm9ybWFuY2UgaXNzdWVzLCBhbmQgaXMgbm90IHN1cHBvcnRlZC5gO1xuICAgIH0sXG4gIH07XG5cbiAgc2V0VHJhY2tpbmdUcmFuc2FjdGlvbkVudiA9IChlbnYpID0+IE9iamVjdC5hc3NpZ24oVFJBTlNBQ1RJT05fRU5WLCBlbnYpO1xuXG4gIGJlZ2luVHJhY2tpbmdUcmFuc2FjdGlvbiA9IChfZGVidWdMYWJlbD86IHN0cmluZyB8IGZhbHNlKSA9PiB7XG4gICAgQ09OU1VNRURfVEFHUyA9IENPTlNVTUVEX1RBR1MgfHwgbmV3IFdlYWtNYXAoKTtcblxuICAgIGxldCBkZWJ1Z0xhYmVsID0gX2RlYnVnTGFiZWwgfHwgdW5kZWZpbmVkO1xuXG4gICAgbGV0IHBhcmVudCA9IFRSQU5TQUNUSU9OX1NUQUNLW1RSQU5TQUNUSU9OX1NUQUNLLmxlbmd0aCAtIDFdIHx8IG51bGw7XG5cbiAgICBUUkFOU0FDVElPTl9TVEFDSy5wdXNoKHtcbiAgICAgIHBhcmVudCxcbiAgICAgIGRlYnVnTGFiZWwsXG4gICAgfSk7XG4gIH07XG5cbiAgZW5kVHJhY2tpbmdUcmFuc2FjdGlvbiA9ICgpID0+IHtcbiAgICBpZiAoVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F0dGVtcHRlZCB0byBjbG9zZSBhIHRyYWNraW5nIHRyYW5zYWN0aW9uLCBidXQgb25lIHdhcyBub3Qgb3BlbicpO1xuICAgIH1cblxuICAgIFRSQU5TQUNUSU9OX1NUQUNLLnBvcCgpO1xuXG4gICAgaWYgKFRSQU5TQUNUSU9OX1NUQUNLLmxlbmd0aCA9PT0gMCkge1xuICAgICAgQ09OU1VNRURfVEFHUyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHJlc2V0VHJhY2tpbmdUcmFuc2FjdGlvbiA9ICgpID0+IHtcbiAgICBsZXQgc3RhY2sgPSAnJztcblxuICAgIGlmIChUUkFOU0FDVElPTl9TVEFDSy5sZW5ndGggPiAwKSB7XG4gICAgICBzdGFjayA9IGxvZ1RyYWNraW5nU3RhY2shKFRSQU5TQUNUSU9OX1NUQUNLW1RSQU5TQUNUSU9OX1NUQUNLLmxlbmd0aCAtIDFdKTtcbiAgICB9XG5cbiAgICBUUkFOU0FDVElPTl9TVEFDSyA9IFtdO1xuICAgIENPTlNVTUVEX1RBR1MgPSBudWxsO1xuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZ2xvYmFsIGF1dG90cmFja2luZyB0cmFuc2FjdGlvbi4gVGhpcyB3aWxsIHByZXZlbnQgYW55IGJhY2tmbG93XG4gICAqIGluIGFueSBgdHJhY2tgIGNhbGxzIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24sIGV2ZW4gaWYgdGhleSBhcmUgbm90XG4gICAqIGV4dGVybmFsbHkgY29uc3VtZWQuXG4gICAqXG4gICAqIGBydW5JbkF1dG90cmFja2luZ1RyYW5zYWN0aW9uYCBjYW4gYmUgY2FsbGVkIHdpdGhpbiBpdHNlbGYsIGFuZCBpdCB3aWxsIGFkZFxuICAgKiBvbnRvIHRoZSBleGlzdGluZyB0cmFuc2FjdGlvbiBpZiBvbmUgZXhpc3RzLlxuICAgKlxuICAgKiBUT0RPOiBPbmx5IHRocm93IGFuIGVycm9yIGlmIHRoZSBgdHJhY2tgIGlzIGNvbnN1bWVkLlxuICAgKi9cbiAgcnVuSW5UcmFja2luZ1RyYW5zYWN0aW9uID0gPFQ+KGZuOiAoKSA9PiBULCBkZWJ1Z0xhYmVsPzogc3RyaW5nIHwgZmFsc2UpID0+IHtcbiAgICBiZWdpblRyYWNraW5nVHJhbnNhY3Rpb24hKGRlYnVnTGFiZWwpO1xuICAgIGxldCBkaWRFcnJvciA9IHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgbGV0IHZhbHVlID0gZm4oKTtcbiAgICAgIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChkaWRFcnJvciAhPT0gdHJ1ZSkge1xuICAgICAgICBlbmRUcmFja2luZ1RyYW5zYWN0aW9uISgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBsZXQgbnRoSW5kZXggPSAoc3RyOiBzdHJpbmcsIHBhdHRlcm46IHN0cmluZywgbjogbnVtYmVyLCBzdGFydGluZ1BvcyA9IC0xKSA9PiB7XG4gICAgbGV0IGkgPSBzdGFydGluZ1BvcztcblxuICAgIHdoaWxlIChuLS0gPiAwICYmIGkrKyA8IHN0ci5sZW5ndGgpIHtcbiAgICAgIGkgPSBzdHIuaW5kZXhPZihwYXR0ZXJuLCBpKTtcbiAgICAgIGlmIChpIDwgMCkgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGk7XG4gIH07XG5cbiAgbGV0IG1ha2VUcmFja2luZ0Vycm9yTWVzc2FnZSA9IDxUPihcbiAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24sXG4gICAgb2JqPzogVCxcbiAgICBrZXlOYW1lPzoga2V5b2YgVCB8IHN0cmluZyB8IHN5bWJvbFxuICApID0+IHtcbiAgICBsZXQgbWVzc2FnZSA9IFtUUkFOU0FDVElPTl9FTlYuZGVidWdNZXNzYWdlKG9iaiwga2V5TmFtZSAmJiBTdHJpbmcoa2V5TmFtZSkpXTtcblxuICAgIG1lc3NhZ2UucHVzaChgXFxgJHtTdHJpbmcoa2V5TmFtZSl9XFxgIHdhcyBmaXJzdCB1c2VkOmApO1xuXG4gICAgbWVzc2FnZS5wdXNoKGxvZ1RyYWNraW5nU3RhY2shKHRyYW5zYWN0aW9uKSk7XG5cbiAgICBtZXNzYWdlLnB1c2goYFN0YWNrIHRyYWNlIGZvciB0aGUgdXBkYXRlOmApO1xuXG4gICAgcmV0dXJuIG1lc3NhZ2Uuam9pbignXFxuXFxuJyk7XG4gIH07XG5cbiAgbG9nVHJhY2tpbmdTdGFjayA9ICh0cmFuc2FjdGlvbj86IFRyYW5zYWN0aW9uKSA9PiB7XG4gICAgbGV0IHRyYWNraW5nU3RhY2sgPSBbXTtcbiAgICBsZXQgY3VycmVudDogVHJhbnNhY3Rpb24gfCBudWxsIHwgdW5kZWZpbmVkID1cbiAgICAgIHRyYW5zYWN0aW9uIHx8IFRSQU5TQUNUSU9OX1NUQUNLW1RSQU5TQUNUSU9OX1NUQUNLLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGN1cnJlbnQgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuXG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgIGlmIChjdXJyZW50LmRlYnVnTGFiZWwpIHtcbiAgICAgICAgdHJhY2tpbmdTdGFjay51bnNoaWZ0KGN1cnJlbnQuZGVidWdMYWJlbCk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQgaGVyZSBvbmNlIHdlIGNhbiBkcm9wIHN1cHBvcnQgZm9yIElFMTFcbiAgICByZXR1cm4gdHJhY2tpbmdTdGFjay5tYXAoKGxhYmVsLCBpbmRleCkgPT4gQXJyYXkoMiAqIGluZGV4ICsgMSkuam9pbignICcpICsgbGFiZWwpLmpvaW4oJ1xcbicpO1xuICB9O1xuXG4gIG1hcmtUYWdBc0NvbnN1bWVkID0gKF90YWc6IFRhZykgPT4ge1xuICAgIGlmICghQ09OU1VNRURfVEFHUyB8fCBDT05TVU1FRF9UQUdTLmhhcyhfdGFnKSkgcmV0dXJuO1xuXG4gICAgQ09OU1VNRURfVEFHUy5zZXQoX3RhZywgVFJBTlNBQ1RJT05fU1RBQ0tbVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoIC0gMV0pO1xuXG4gICAgLy8gV2UgbmVlZCB0byBtYXJrIHRoZSB0YWcgYW5kIGFsbCBvZiBpdHMgc3VidGFncyBhcyBjb25zdW1lZCwgc28gd2UgbmVlZCB0b1xuICAgIC8vIGNhc3QgaXQgYW5kIGFjY2VzcyBpdHMgaW50ZXJuYWxzLiBJbiB0aGUgZnV0dXJlIHRoaXMgc2hvdWxkbid0IGJlIG5lY2Vzc2FyeSxcbiAgICAvLyB0aGlzIGlzIG9ubHkgZm9yIGNvbXB1dGVkIHByb3BlcnRpZXMuXG4gICAgbGV0IHRhZyA9IF90YWcgYXMgYW55O1xuXG4gICAgaWYgKHRhZy5zdWJ0YWcpIHtcbiAgICAgIG1hcmtUYWdBc0NvbnN1bWVkISh0YWcuc3VidGFnKTtcbiAgICB9XG5cbiAgICBpZiAodGFnLnN1YnRhZ3MpIHtcbiAgICAgIHRhZy5zdWJ0YWdzLmZvckVhY2goKHRhZzogVGFnKSA9PiBtYXJrVGFnQXNDb25zdW1lZCEodGFnKSk7XG4gICAgfVxuICB9O1xuXG4gIGFzc2VydFRhZ05vdENvbnN1bWVkID0gPFQ+KHRhZzogVGFnLCBvYmo/OiBULCBrZXlOYW1lPzoga2V5b2YgVCB8IHN0cmluZyB8IHN5bWJvbCkgPT4ge1xuICAgIGlmIChDT05TVU1FRF9UQUdTID09PSBudWxsKSByZXR1cm47XG5cbiAgICBsZXQgdHJhbnNhY3Rpb24gPSBDT05TVU1FRF9UQUdTLmdldCh0YWcpO1xuXG4gICAgaWYgKCF0cmFuc2FjdGlvbikgcmV0dXJuO1xuXG4gICAgLy8gVGhpcyBoYWNrIG1ha2VzIHRoZSBhc3NlcnRpb24gbWVzc2FnZSBuaWNlciwgd2UgY2FuIGN1dCBvZmYgdGhlIGZpcnN0XG4gICAgLy8gZmV3IGxpbmVzIG9mIHRoZSBzdGFjayB0cmFjZSBhbmQgbGV0IHVzZXJzIGtub3cgd2hlcmUgdGhlIGFjdHVhbCBlcnJvclxuICAgIC8vIG9jY3VycmVkLlxuICAgIHRyeSB7XG4gICAgICBhc3NlcnQoZmFsc2UsIG1ha2VUcmFja2luZ0Vycm9yTWVzc2FnZSh0cmFuc2FjdGlvbiwgb2JqLCBrZXlOYW1lKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuc3RhY2spIHtcbiAgICAgICAgbGV0IHVwZGF0ZVN0YWNrQmVnaW4gPSBlLnN0YWNrLmluZGV4T2YoJ1N0YWNrIHRyYWNlIGZvciB0aGUgdXBkYXRlOicpO1xuXG4gICAgICAgIGlmICh1cGRhdGVTdGFja0JlZ2luICE9PSAtMSkge1xuICAgICAgICAgIGxldCBzdGFydCA9IG50aEluZGV4KGUuc3RhY2ssICdcXG4nLCAxLCB1cGRhdGVTdGFja0JlZ2luKTtcbiAgICAgICAgICBsZXQgZW5kID0gbnRoSW5kZXgoZS5zdGFjaywgJ1xcbicsIDQsIHVwZGF0ZVN0YWNrQmVnaW4pO1xuICAgICAgICAgIGUuc3RhY2sgPSBlLnN0YWNrLnN1YnN0cigwLCBzdGFydCkgKyBlLnN0YWNrLnN1YnN0cihlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==