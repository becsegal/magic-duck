"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tracked = undefined;
exports.setPropertyDidChange = setPropertyDidChange;

var _env = require("@glimmer/env");

var _validator = require("@glimmer/validator");

/**
 * @decorator
 *
 * Marks a property as tracked.
 *
 * By default, a component's properties are expected to be static,
 * meaning you are not able to update them and have the template update accordingly.
 * Marking a property as tracked means that when that property changes,
 * a rerender of the component is scheduled so the template is kept up to date.
 *
 * @example
 *
 * ```typescript
 * import Component from '@glimmer/component';
 * import { tracked } from '@glimmer/tracking';
 *
 * export default class MyComponent extends Component {
 *    @tracked
 *    remainingApples = 10
 * }
 * ```
 *
 * When something changes the component's `remainingApples` property, the rerender
 * will be scheduled.
 *
 * @example Computed Properties
 *
 * In the case that you have a getter that depends on other properties, tracked
 * properties accessed within the getter will automatically be tracked for you.
 * That means when any of those dependent tracked properties is changed, a
 * rerender of the component will be scheduled.
 *
 * In the following example we have two properties,
 * `eatenApples`, and `remainingApples`.
 *
 *
 * ```typescript
 * import Component from '@glimmer/component';
 * import { tracked } from '@glimmer/tracking';
 *
 * const totalApples = 100;
 *
 * export default class MyComponent extends Component {
 *    @tracked
 *    eatenApples = 0
 *
 *    get remainingApples() {
 *      return totalApples - this.eatenApples;
 *    }
 *
 *    increment() {
 *      this.eatenApples = this.eatenApples + 1;
 *    }
 *  }
 * ```
 */
var tracked = exports.tracked = function tracked() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var target = args[0],
      key = args[1],
      descriptor = args[2]; // Error on `@tracked()`, `@tracked(...args)`, and `@tracked get propName()`

  if (_env.DEBUG && typeof target === 'string') throwTrackedWithArgumentsError(args);
  if (_env.DEBUG && target === undefined) throwTrackedWithEmptyArgumentsError();
  if (_env.DEBUG && descriptor && descriptor.get) throwTrackedComputedPropertyError();

  if (descriptor) {
    return descriptorForField(target, key, descriptor);
  } else {
    // In TypeScript's implementation, decorators on simple class fields do not
    // receive a descriptor, so we define the property on the target directly.
    Object.defineProperty(target, key, descriptorForField(target, key));
  }
};

function throwTrackedComputedPropertyError() {
  throw new Error("The @tracked decorator does not need to be applied to getters. Properties implemented using a getter will recompute automatically when any tracked properties they access change.");
}

function throwTrackedWithArgumentsError(args) {
  throw new Error("You attempted to use @tracked with " + (args.length > 1 ? 'arguments' : 'an argument') + " ( @tracked(" + args.map(function (d) {
    return "'" + d + "'";
  }).join(', ') + ") ), which is no longer necessary nor supported. Dependencies are now automatically tracked, so you can just use " + '`@tracked`' + ".");
}

function throwTrackedWithEmptyArgumentsError() {
  throw new Error('You attempted to use @tracked(), which is no longer necessary nor supported. Remove the parentheses and you will be good to go!');
}

function descriptorForField(_target, key, desc) {
  if (_env.DEBUG && desc && (desc.value || desc.get || desc.set)) {
    throw new Error("You attempted to use @tracked on " + String(key) + ", but that element is not a class field. @tracked is only usable on class fields. Native getters and setters will autotrack add any tracked fields they encounter, so there is no need mark getters and setters with @tracked.");
  }

  var _trackedData = (0, _validator.trackedData)(key, desc && desc.initializer),
      getter = _trackedData.getter,
      setter = _trackedData.setter;

  return {
    enumerable: true,
    configurable: true,
    get: function get() {
      return getter(this);
    },
    set: function set(newValue) {
      setter(this, newValue);
      propertyDidChange();
    }
  };
}

var propertyDidChange = function propertyDidChange() {};

function setPropertyDidChange(cb) {
  propertyDidChange = cb;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3RyYWNraW5nL3NyYy90cmFja2VkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztRQW1KTSxvQixHQUFBLG9COztBQW5KTjs7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3RE8sSUFBSSxPQUFPLFdBQVAsT0FBTyxHQUFzQixTQUE3QixPQUE2QixHQUFtQjtBQUFBLE9BQUEsSUFBQSxJQUFBLEdBQUEsU0FBQSxDQUFBLE1BQUEsRUFBZixJQUFlLEdBQUEsSUFBQSxLQUFBLENBQUEsSUFBQSxDQUFBLEVBQUEsSUFBQSxHQUFBLENBQUEsRUFBQSxJQUFBLEdBQUEsSUFBQSxFQUFBLElBQUEsRUFBQSxFQUFBO0FBQWYsSUFBQSxJQUFlLENBQUEsSUFBQSxDQUFmLEdBQWUsU0FBQSxDQUFBLElBQUEsQ0FBZjtBQUFlOztBQUFBLE1BQ3BELE1BRG9ELEdBQ3pCLElBRHlCLENBQUEsQ0FBQSxDQUFBO0FBQUEsTUFDNUMsR0FENEMsR0FDekIsSUFEeUIsQ0FBQSxDQUFBLENBQUE7QUFBQSxNQUN2QyxVQUR1QyxHQUN6QixJQUR5QixDQUFBLENBQUEsQ0FBQSxDQUFBLENBR3pEOztBQUNBLE1BQUksY0FBUyxPQUFBLE1BQUEsS0FBYixRQUFBLEVBQXlDLDhCQUE4QixDQUE5QixJQUE4QixDQUE5QjtBQUN6QyxNQUFJLGNBQVMsTUFBTSxLQUFuQixTQUFBLEVBQW1DLG1DQUFtQztBQUN0RSxNQUFJLGNBQUEsVUFBQSxJQUF1QixVQUFVLENBQXJDLEdBQUEsRUFBMkMsaUNBQWlDOztBQUU1RSxNQUFBLFVBQUEsRUFBZ0I7QUFDZCxXQUFPLGtCQUFrQixDQUFBLE1BQUEsRUFBQSxHQUFBLEVBQXpCLFVBQXlCLENBQXpCO0FBREYsR0FBQSxNQUVPO0FBQ0w7QUFDQTtBQUNBLElBQUEsTUFBTSxDQUFOLGNBQUEsQ0FBQSxNQUFBLEVBQUEsR0FBQSxFQUFtQyxrQkFBa0IsQ0FBQSxNQUFBLEVBQXJELEdBQXFELENBQXJEO0FBQ0Q7QUFkSSxDQUFBOztBQWlCUCxTQUFBLGlDQUFBLEdBQTBDO0FBQ3hDLFFBQU0sSUFBQSxLQUFBLENBQU4sbUxBQU0sQ0FBTjtBQUdEOztBQUVELFNBQUEsOEJBQUEsQ0FBQSxJQUFBLEVBQW1EO0FBQ2pELFFBQU0sSUFBQSxLQUFBLENBQUEseUNBRUYsSUFBSSxDQUFKLE1BQUEsR0FBQSxDQUFBLEdBQUEsV0FBQSxHQUZFLGFBQUEsSUFBQSxjQUFBLEdBR1csSUFBSSxDQUFKLEdBQUEsQ0FDUixVQUFBLENBQUEsRUFBQTtBQUFBLFdBQUEsTUFBQSxDQUFBLEdBQUEsR0FBQTtBQURRLEdBQUEsRUFBQSxJQUFBLENBSFgsSUFHVyxDQUhYLEdBQUEsbUhBQUEsR0FBQSxZQUFBLEdBQU4sR0FBTSxDQUFOO0FBU0Q7O0FBRUQsU0FBQSxtQ0FBQSxHQUE0QztBQUMxQyxRQUFNLElBQUEsS0FBQSxDQUFOLGlJQUFNLENBQU47QUFHRDs7QUFpQkQsU0FBQSxrQkFBQSxDQUFBLE9BQUEsRUFBQSxHQUFBLEVBQUEsSUFBQSxFQUdvQztBQUVsQyxNQUFJLGNBQUEsSUFBQSxLQUFrQixJQUFJLENBQUosS0FBQSxJQUFjLElBQUksQ0FBbEIsR0FBQSxJQUEwQixJQUFJLENBQXBELEdBQUksQ0FBSixFQUEyRDtBQUN6RCxVQUFNLElBQUEsS0FBQSxDQUFBLHNDQUNnQyxNQUFNLENBRHRDLEdBQ3NDLENBRHRDLEdBQU4sZ09BQU0sQ0FBTjtBQUtEOztBQVJpQyxNQUFBLFlBQUEsR0FVVCw0QkFBVyxHQUFYLEVBQXVCLElBQUksSUFBSSxJQUFJLENBVjFCLFdBVVQsQ0FWUztBQUFBLE1BVTVCLE1BVjRCLEdBQUEsWUFBQSxDQUFBLE1BQUE7QUFBQSxNQVVwQixNQVZvQixHQUFBLFlBQUEsQ0FBQSxNQUFBOztBQVlsQyxTQUFPO0FBQ0wsSUFBQSxVQUFVLEVBREwsSUFBQTtBQUVMLElBQUEsWUFBWSxFQUZQLElBQUE7QUFJTCxJQUFBLEdBSkssRUFBQSxTQUFBLEdBQUEsR0FJRjtBQUNELGFBQU8sTUFBTSxDQUFiLElBQWEsQ0FBYjtBQUxHLEtBQUE7QUFRTCxJQUFBLEdBUkssRUFBQSxTQUFBLEdBQUEsQ0FBQSxRQUFBLEVBUXFCO0FBQ3hCLE1BQUEsTUFBTSxDQUFBLElBQUEsRUFBTixRQUFNLENBQU47QUFDQSxNQUFBLGlCQUFpQjtBQUNsQjtBQVhJLEdBQVA7QUFhRDs7QUFFRCxJQUFJLGlCQUFpQixHQUFHLFNBQUEsaUJBQUEsR0FBQSxDQUF4QixDQUFBOztBQUVNLFNBQUEsb0JBQUEsQ0FBQSxFQUFBLEVBQTZDO0FBQ2pELEVBQUEsaUJBQWlCLEdBQWpCLEVBQUE7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IHRyYWNrZWREYXRhIH0gZnJvbSAnQGdsaW1tZXIvdmFsaWRhdG9yJztcblxuLyoqXG4gKiBAZGVjb3JhdG9yXG4gKlxuICogTWFya3MgYSBwcm9wZXJ0eSBhcyB0cmFja2VkLlxuICpcbiAqIEJ5IGRlZmF1bHQsIGEgY29tcG9uZW50J3MgcHJvcGVydGllcyBhcmUgZXhwZWN0ZWQgdG8gYmUgc3RhdGljLFxuICogbWVhbmluZyB5b3UgYXJlIG5vdCBhYmxlIHRvIHVwZGF0ZSB0aGVtIGFuZCBoYXZlIHRoZSB0ZW1wbGF0ZSB1cGRhdGUgYWNjb3JkaW5nbHkuXG4gKiBNYXJraW5nIGEgcHJvcGVydHkgYXMgdHJhY2tlZCBtZWFucyB0aGF0IHdoZW4gdGhhdCBwcm9wZXJ0eSBjaGFuZ2VzLFxuICogYSByZXJlbmRlciBvZiB0aGUgY29tcG9uZW50IGlzIHNjaGVkdWxlZCBzbyB0aGUgdGVtcGxhdGUgaXMga2VwdCB1cCB0byBkYXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IENvbXBvbmVudCBmcm9tICdAZ2xpbW1lci9jb21wb25lbnQnO1xuICogaW1wb3J0IHsgdHJhY2tlZCB9IGZyb20gJ0BnbGltbWVyL3RyYWNraW5nJztcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gKiAgICBAdHJhY2tlZFxuICogICAgcmVtYWluaW5nQXBwbGVzID0gMTBcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFdoZW4gc29tZXRoaW5nIGNoYW5nZXMgdGhlIGNvbXBvbmVudCdzIGByZW1haW5pbmdBcHBsZXNgIHByb3BlcnR5LCB0aGUgcmVyZW5kZXJcbiAqIHdpbGwgYmUgc2NoZWR1bGVkLlxuICpcbiAqIEBleGFtcGxlIENvbXB1dGVkIFByb3BlcnRpZXNcbiAqXG4gKiBJbiB0aGUgY2FzZSB0aGF0IHlvdSBoYXZlIGEgZ2V0dGVyIHRoYXQgZGVwZW5kcyBvbiBvdGhlciBwcm9wZXJ0aWVzLCB0cmFja2VkXG4gKiBwcm9wZXJ0aWVzIGFjY2Vzc2VkIHdpdGhpbiB0aGUgZ2V0dGVyIHdpbGwgYXV0b21hdGljYWxseSBiZSB0cmFja2VkIGZvciB5b3UuXG4gKiBUaGF0IG1lYW5zIHdoZW4gYW55IG9mIHRob3NlIGRlcGVuZGVudCB0cmFja2VkIHByb3BlcnRpZXMgaXMgY2hhbmdlZCwgYVxuICogcmVyZW5kZXIgb2YgdGhlIGNvbXBvbmVudCB3aWxsIGJlIHNjaGVkdWxlZC5cbiAqXG4gKiBJbiB0aGUgZm9sbG93aW5nIGV4YW1wbGUgd2UgaGF2ZSB0d28gcHJvcGVydGllcyxcbiAqIGBlYXRlbkFwcGxlc2AsIGFuZCBgcmVtYWluaW5nQXBwbGVzYC5cbiAqXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IENvbXBvbmVudCBmcm9tICdAZ2xpbW1lci9jb21wb25lbnQnO1xuICogaW1wb3J0IHsgdHJhY2tlZCB9IGZyb20gJ0BnbGltbWVyL3RyYWNraW5nJztcbiAqXG4gKiBjb25zdCB0b3RhbEFwcGxlcyA9IDEwMDtcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gKiAgICBAdHJhY2tlZFxuICogICAgZWF0ZW5BcHBsZXMgPSAwXG4gKlxuICogICAgZ2V0IHJlbWFpbmluZ0FwcGxlcygpIHtcbiAqICAgICAgcmV0dXJuIHRvdGFsQXBwbGVzIC0gdGhpcy5lYXRlbkFwcGxlcztcbiAqICAgIH1cbiAqXG4gKiAgICBpbmNyZW1lbnQoKSB7XG4gKiAgICAgIHRoaXMuZWF0ZW5BcHBsZXMgPSB0aGlzLmVhdGVuQXBwbGVzICsgMTtcbiAqICAgIH1cbiAqICB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGxldCB0cmFja2VkOiBQcm9wZXJ0eURlY29yYXRvciA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICBsZXQgW3RhcmdldCwga2V5LCBkZXNjcmlwdG9yXSA9IGFyZ3M7XG5cbiAgLy8gRXJyb3Igb24gYEB0cmFja2VkKClgLCBgQHRyYWNrZWQoLi4uYXJncylgLCBhbmQgYEB0cmFja2VkIGdldCBwcm9wTmFtZSgpYFxuICBpZiAoREVCVUcgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHRocm93VHJhY2tlZFdpdGhBcmd1bWVudHNFcnJvcihhcmdzKTtcbiAgaWYgKERFQlVHICYmIHRhcmdldCA9PT0gdW5kZWZpbmVkKSB0aHJvd1RyYWNrZWRXaXRoRW1wdHlBcmd1bWVudHNFcnJvcigpO1xuICBpZiAoREVCVUcgJiYgZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmdldCkgdGhyb3dUcmFja2VkQ29tcHV0ZWRQcm9wZXJ0eUVycm9yKCk7XG5cbiAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICByZXR1cm4gZGVzY3JpcHRvckZvckZpZWxkKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBUeXBlU2NyaXB0J3MgaW1wbGVtZW50YXRpb24sIGRlY29yYXRvcnMgb24gc2ltcGxlIGNsYXNzIGZpZWxkcyBkbyBub3RcbiAgICAvLyByZWNlaXZlIGEgZGVzY3JpcHRvciwgc28gd2UgZGVmaW5lIHRoZSBwcm9wZXJ0eSBvbiB0aGUgdGFyZ2V0IGRpcmVjdGx5LlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvckZvckZpZWxkKHRhcmdldCwga2V5KSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHRocm93VHJhY2tlZENvbXB1dGVkUHJvcGVydHlFcnJvcigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBUaGUgQHRyYWNrZWQgZGVjb3JhdG9yIGRvZXMgbm90IG5lZWQgdG8gYmUgYXBwbGllZCB0byBnZXR0ZXJzLiBQcm9wZXJ0aWVzIGltcGxlbWVudGVkIHVzaW5nIGEgZ2V0dGVyIHdpbGwgcmVjb21wdXRlIGF1dG9tYXRpY2FsbHkgd2hlbiBhbnkgdHJhY2tlZCBwcm9wZXJ0aWVzIHRoZXkgYWNjZXNzIGNoYW5nZS5gXG4gICk7XG59XG5cbmZ1bmN0aW9uIHRocm93VHJhY2tlZFdpdGhBcmd1bWVudHNFcnJvcihhcmdzOiBhbnlbXSkge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYFlvdSBhdHRlbXB0ZWQgdG8gdXNlIEB0cmFja2VkIHdpdGggJHtcbiAgICAgIGFyZ3MubGVuZ3RoID4gMSA/ICdhcmd1bWVudHMnIDogJ2FuIGFyZ3VtZW50J1xuICAgIH0gKCBAdHJhY2tlZCgke2FyZ3NcbiAgICAgIC5tYXAoKGQpID0+IGAnJHtkfSdgKVxuICAgICAgLmpvaW4oXG4gICAgICAgICcsICdcbiAgICAgICl9KSApLCB3aGljaCBpcyBubyBsb25nZXIgbmVjZXNzYXJ5IG5vciBzdXBwb3J0ZWQuIERlcGVuZGVuY2llcyBhcmUgbm93IGF1dG9tYXRpY2FsbHkgdHJhY2tlZCwgc28geW91IGNhbiBqdXN0IHVzZSAkeydgQHRyYWNrZWRgJ30uYFxuICApO1xufVxuXG5mdW5jdGlvbiB0aHJvd1RyYWNrZWRXaXRoRW1wdHlBcmd1bWVudHNFcnJvcigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICdZb3UgYXR0ZW1wdGVkIHRvIHVzZSBAdHJhY2tlZCgpLCB3aGljaCBpcyBubyBsb25nZXIgbmVjZXNzYXJ5IG5vciBzdXBwb3J0ZWQuIFJlbW92ZSB0aGUgcGFyZW50aGVzZXMgYW5kIHlvdSB3aWxsIGJlIGdvb2QgdG8gZ28hJ1xuICApO1xufVxuXG4vKipcbiAqIFdoZW5ldmVyIGEgdHJhY2tlZCBjb21wdXRlZCBwcm9wZXJ0eSBpcyBlbnRlcmVkLCB0aGUgY3VycmVudCB0cmFja2VyIGlzXG4gKiBzYXZlZCBvZmYgYW5kIGEgbmV3IHRyYWNrZXIgaXMgcmVwbGFjZWQuXG4gKlxuICogQW55IHRyYWNrZWQgcHJvcGVydGllcyBjb25zdW1lZCBhcmUgYWRkZWQgdG8gdGhlIGN1cnJlbnQgdHJhY2tlci5cbiAqXG4gKiBXaGVuIGEgdHJhY2tlZCBjb21wdXRlZCBwcm9wZXJ0eSBpcyBleGl0ZWQsIHRoZSB0cmFja2VyJ3MgdGFncyBhcmVcbiAqIGNvbWJpbmVkIGFuZCBhZGRlZCB0byB0aGUgcGFyZW50IHRyYWNrZXIuXG4gKlxuICogVGhlIGNvbnNlcXVlbmNlIGlzIHRoYXQgZWFjaCB0cmFja2VkIGNvbXB1dGVkIHByb3BlcnR5IGhhcyBhIHRhZ1xuICogdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgdHJhY2tlZCBwcm9wZXJ0aWVzIGNvbnN1bWVkIGluc2lkZSBvZlxuICogaXRzZWxmLCBpbmNsdWRpbmcgY2hpbGQgdHJhY2tlZCBjb21wdXRlZCBwcm9wZXJ0aWVzLlxuICovXG50eXBlIERlY29yYXRvclByb3BlcnR5RGVzY3JpcHRvciA9IChQcm9wZXJ0eURlc2NyaXB0b3IgJiB7IGluaXRpYWxpemVyPzogYW55IH0pIHwgdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBkZXNjcmlwdG9yRm9yRmllbGQ8VCBleHRlbmRzIG9iamVjdCwgSyBleHRlbmRzIGtleW9mIFQ+KFxuICBfdGFyZ2V0OiBULFxuICBrZXk6IEssXG4gIGRlc2M/OiBEZWNvcmF0b3JQcm9wZXJ0eURlc2NyaXB0b3Jcbik6IERlY29yYXRvclByb3BlcnR5RGVzY3JpcHRvciB7XG4gIGlmIChERUJVRyAmJiBkZXNjICYmIChkZXNjLnZhbHVlIHx8IGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBZb3UgYXR0ZW1wdGVkIHRvIHVzZSBAdHJhY2tlZCBvbiAke1N0cmluZyhcbiAgICAgICAga2V5XG4gICAgICApfSwgYnV0IHRoYXQgZWxlbWVudCBpcyBub3QgYSBjbGFzcyBmaWVsZC4gQHRyYWNrZWQgaXMgb25seSB1c2FibGUgb24gY2xhc3MgZmllbGRzLiBOYXRpdmUgZ2V0dGVycyBhbmQgc2V0dGVycyB3aWxsIGF1dG90cmFjayBhZGQgYW55IHRyYWNrZWQgZmllbGRzIHRoZXkgZW5jb3VudGVyLCBzbyB0aGVyZSBpcyBubyBuZWVkIG1hcmsgZ2V0dGVycyBhbmQgc2V0dGVycyB3aXRoIEB0cmFja2VkLmBcbiAgICApO1xuICB9XG5cbiAgbGV0IHsgZ2V0dGVyLCBzZXR0ZXIgfSA9IHRyYWNrZWREYXRhPFQsIEs+KGtleSwgZGVzYyAmJiBkZXNjLmluaXRpYWxpemVyKTtcblxuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG4gICAgZ2V0KHRoaXM6IFQpOiBhbnkge1xuICAgICAgcmV0dXJuIGdldHRlcih0aGlzKTtcbiAgICB9LFxuXG4gICAgc2V0KHRoaXM6IFQsIG5ld1ZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICAgIHNldHRlcih0aGlzLCBuZXdWYWx1ZSk7XG4gICAgICBwcm9wZXJ0eURpZENoYW5nZSgpO1xuICAgIH0sXG4gIH07XG59XG5cbmxldCBwcm9wZXJ0eURpZENoYW5nZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvcGVydHlEaWRDaGFuZ2UoY2I6ICgpID0+IHZvaWQpIHtcbiAgcHJvcGVydHlEaWRDaGFuZ2UgPSBjYjtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=