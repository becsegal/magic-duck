import { Dict, Option } from '@glimmer/interfaces';
import { SourceLocation, SourcePosition } from '../source/location';
import { SourceSpan } from '../source/span';
import * as ASTv1 from './api';
export declare type BuilderHead = string | ASTv1.Expression;
export declare type TagDescriptor = string | {
    name: string;
    selfClosing: boolean;
};
declare function buildMustache(path: BuilderHead | ASTv1.Literal, params?: ASTv1.Expression[], hash?: ASTv1.Hash, raw?: boolean, loc?: SourceLocation, strip?: ASTv1.StripFlags): ASTv1.MustacheStatement;
declare function buildBlock(path: BuilderHead, params: Option<ASTv1.Expression[]>, hash: Option<ASTv1.Hash>, _defaultBlock: ASTv1.PossiblyDeprecatedBlock, _elseBlock?: Option<ASTv1.PossiblyDeprecatedBlock>, loc?: SourceLocation, openStrip?: ASTv1.StripFlags, inverseStrip?: ASTv1.StripFlags, closeStrip?: ASTv1.StripFlags): ASTv1.BlockStatement;
declare function buildElementModifier(path: BuilderHead | ASTv1.Expression, params?: ASTv1.Expression[], hash?: ASTv1.Hash, loc?: Option<SourceLocation>): ASTv1.ElementModifierStatement;
declare function buildPartial(name: ASTv1.PathExpression, params?: ASTv1.Expression[], hash?: ASTv1.Hash, indent?: string, loc?: SourceLocation): ASTv1.PartialStatement;
declare function buildComment(value: string, loc?: SourceLocation): ASTv1.CommentStatement;
declare function buildMustacheComment(value: string, loc?: SourceLocation): ASTv1.MustacheCommentStatement;
declare function buildConcat(parts: (ASTv1.TextNode | ASTv1.MustacheStatement)[], loc?: SourceLocation): ASTv1.ConcatStatement;
export declare type ElementParts = ['attrs', ...AttrSexp[]] | ['modifiers', ...ModifierSexp[]] | ['body', ...ASTv1.Statement[]] | ['comments', ...ElementComment[]] | ['as', ...string[]] | ['loc', SourceLocation];
export declare type PathSexp = string | ['path', string, LocSexp?];
export declare type ModifierSexp = string | [PathSexp, LocSexp?] | [PathSexp, ASTv1.Expression[], LocSexp?] | [PathSexp, ASTv1.Expression[], Dict<ASTv1.Expression>, LocSexp?];
export declare type AttrSexp = [string, ASTv1.AttrNode['value'] | string, LocSexp?];
export declare type LocSexp = ['loc', SourceLocation];
export declare type ElementComment = ASTv1.MustacheCommentStatement | SourceLocation | string;
export declare type SexpValue = string | ASTv1.Expression[] | Dict<ASTv1.Expression> | LocSexp | PathSexp | undefined;
export interface BuildElementOptions {
    attrs?: ASTv1.AttrNode[];
    modifiers?: ASTv1.ElementModifierStatement[];
    children?: ASTv1.Statement[];
    comments?: ElementComment[];
    blockParams?: string[];
    loc?: SourceSpan;
}
declare function buildElement(tag: TagDescriptor, options: BuildElementOptions): ASTv1.ElementNode;
declare function buildAttr(name: string, value: ASTv1.AttrNode['value'], loc?: SourceLocation): ASTv1.AttrNode;
declare function buildText(chars?: string, loc?: SourceLocation): ASTv1.TextNode;
declare function buildSexpr(path: BuilderHead, params?: ASTv1.Expression[], hash?: ASTv1.Hash, loc?: SourceLocation): ASTv1.SubExpression;
declare function buildThis(loc: SourceLocation): ASTv1.PathHead;
declare function buildAtName(name: string, loc: SourceLocation): ASTv1.PathHead;
declare function buildVar(name: string, loc: SourceLocation): ASTv1.PathHead;
declare function buildHeadFromString(head: string, loc: SourceLocation): ASTv1.PathHead;
declare function buildNamedBlockName(name: string, loc?: SourceLocation): ASTv1.NamedBlockName;
declare function buildCleanPath(head: ASTv1.PathHead, tail: string[], loc: SourceLocation): ASTv1.PathExpression;
declare function buildPath(path: ASTv1.PathExpression | string | {
    head: string;
    tail: string[];
}, loc?: SourceLocation): ASTv1.PathExpression;
declare function buildPath(path: ASTv1.Expression, loc?: SourceLocation): ASTv1.Expression;
declare function buildPath(path: BuilderHead | ASTv1.Expression, loc?: SourceLocation): ASTv1.Expression;
declare function buildLiteral<T extends ASTv1.Literal>(type: T['type'], value: T['value'], loc?: SourceLocation): T;
declare function buildHash(pairs?: ASTv1.HashPair[], loc?: SourceLocation): ASTv1.Hash;
declare function buildPair(key: string, value: ASTv1.Expression, loc?: SourceLocation): ASTv1.HashPair;
declare function buildProgram(body?: ASTv1.Statement[], blockParams?: string[], loc?: SourceLocation): ASTv1.Template;
declare function buildBlockItself(body?: ASTv1.Statement[], blockParams?: string[], chained?: boolean, loc?: SourceLocation): ASTv1.Block;
declare function buildTemplate(body?: ASTv1.Statement[], blockParams?: string[], loc?: SourceLocation): ASTv1.Template;
declare function buildPosition(line: number, column: number): SourcePosition;
declare function buildLoc(loc: Option<SourceLocation>): SourceSpan;
declare function buildLoc(startLine: number, startColumn: number, endLine?: number, endColumn?: number, source?: string): SourceSpan;
declare const _default: {
    mustache: typeof buildMustache;
    block: typeof buildBlock;
    partial: typeof buildPartial;
    comment: typeof buildComment;
    mustacheComment: typeof buildMustacheComment;
    element: typeof buildElement;
    elementModifier: typeof buildElementModifier;
    attr: typeof buildAttr;
    text: typeof buildText;
    sexpr: typeof buildSexpr;
    concat: typeof buildConcat;
    hash: typeof buildHash;
    pair: typeof buildPair;
    literal: typeof buildLiteral;
    program: typeof buildProgram;
    blockItself: typeof buildBlockItself;
    template: typeof buildTemplate;
    loc: typeof buildLoc;
    pos: typeof buildPosition;
    path: typeof buildPath;
    fullPath: typeof buildCleanPath;
    head: typeof buildHeadFromString;
    at: typeof buildAtName;
    var: typeof buildVar;
    this: typeof buildThis;
    blockName: typeof buildNamedBlockName;
    string: (value: string) => ASTv1.StringLiteral;
    boolean: (value: boolean) => ASTv1.BooleanLiteral;
    number: (value: number) => ASTv1.NumberLiteral;
    undefined(): ASTv1.UndefinedLiteral;
    null(): ASTv1.NullLiteral;
};
export default _default;
//# sourceMappingURL=public-builders.d.ts.map