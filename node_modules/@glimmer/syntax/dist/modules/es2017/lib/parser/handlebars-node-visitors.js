import { Parser } from '../parser';
import { NON_EXISTENT_LOCATION } from '../source/location';
import { generateSyntaxError } from '../syntax-error';
import { appendChild, isHBSLiteral, printLiteral } from '../utils';
import { PathExpressionImplV1 } from '../v1/legacy-interop';
import b from '../v1/parser-builders';
export class HandlebarsNodeVisitors extends Parser {
  get isTopLevel() {
    return this.elementStack.length === 0;
  }

  Program(program) {
    let body = [];
    let node;

    if (this.isTopLevel) {
      node = b.template({
        body,
        blockParams: program.blockParams,
        loc: this.source.spanFor(program.loc)
      });
    } else {
      node = b.blockItself({
        body,
        blockParams: program.blockParams,
        chained: program.chained,
        loc: this.source.spanFor(program.loc)
      });
    }

    let i,
        l = program.body.length;
    this.elementStack.push(node);

    if (l === 0) {
      return this.elementStack.pop();
    }

    for (i = 0; i < l; i++) {
      this.acceptNode(program.body[i]);
    } // Ensure that that the element stack is balanced properly.


    let poppedNode = this.elementStack.pop();

    if (poppedNode !== node) {
      let elementNode = poppedNode;
      throw generateSyntaxError(`Unclosed element \`${elementNode.tag}\``, elementNode.loc);
    }

    return node;
  }

  BlockStatement(block) {
    if (this.tokenizer.state === "comment"
    /* comment */
    ) {
        this.appendToCommentData(this.sourceForNode(block));
        return;
      }

    if (this.tokenizer.state !== "data"
    /* data */
    && this.tokenizer.state !== "beforeData"
    /* beforeData */
    ) {
        throw generateSyntaxError('A block may only be used inside an HTML element or another block.', this.source.spanFor(block.loc));
      }

    let {
      path,
      params,
      hash
    } = acceptCallNodes(this, block); // These are bugs in Handlebars upstream

    if (!block.program.loc) {
      block.program.loc = NON_EXISTENT_LOCATION;
    }

    if (block.inverse && !block.inverse.loc) {
      block.inverse.loc = NON_EXISTENT_LOCATION;
    }

    let program = this.Program(block.program);
    let inverse = block.inverse ? this.Program(block.inverse) : null;
    let node = b.block({
      path,
      params,
      hash,
      defaultBlock: program,
      elseBlock: inverse,
      loc: this.source.spanFor(block.loc),
      openStrip: block.openStrip,
      inverseStrip: block.inverseStrip,
      closeStrip: block.closeStrip
    });
    let parentProgram = this.currentElement();
    appendChild(parentProgram, node);
  }

  MustacheStatement(rawMustache) {
    let {
      tokenizer
    } = this;

    if (tokenizer.state === 'comment') {
      this.appendToCommentData(this.sourceForNode(rawMustache));
      return;
    }

    let mustache;
    let {
      escaped,
      loc,
      strip
    } = rawMustache;

    if (isHBSLiteral(rawMustache.path)) {
      mustache = b.mustache({
        path: this.acceptNode(rawMustache.path),
        params: [],
        hash: b.hash([], this.source.spanFor(rawMustache.path.loc).collapse('end')),
        trusting: !escaped,
        loc: this.source.spanFor(loc),
        strip
      });
    } else {
      let {
        path,
        params,
        hash
      } = acceptCallNodes(this, rawMustache);
      mustache = b.mustache({
        path,
        params,
        hash,
        trusting: !escaped,
        loc: this.source.spanFor(loc),
        strip
      });
    }

    switch (tokenizer.state) {
      // Tag helpers
      case "tagOpen"
      /* tagOpen */
      :
      case "tagName"
      /* tagName */
      :
        throw generateSyntaxError(`Cannot use mustaches in an elements tagname`, mustache.loc);

      case "beforeAttributeName"
      /* beforeAttributeName */
      :
        addElementModifier(this.currentStartTag, mustache);
        break;

      case "attributeName"
      /* attributeName */
      :
      case "afterAttributeName"
      /* afterAttributeName */
      :
        this.beginAttributeValue(false);
        this.finishAttributeValue();
        addElementModifier(this.currentStartTag, mustache);
        tokenizer.transitionTo("beforeAttributeName"
        /* beforeAttributeName */
        );
        break;

      case "afterAttributeValueQuoted"
      /* afterAttributeValueQuoted */
      :
        addElementModifier(this.currentStartTag, mustache);
        tokenizer.transitionTo("beforeAttributeName"
        /* beforeAttributeName */
        );
        break;
      // Attribute values

      case "beforeAttributeValue"
      /* beforeAttributeValue */
      :
        this.beginAttributeValue(false);
        this.appendDynamicAttributeValuePart(mustache);
        tokenizer.transitionTo("attributeValueUnquoted"
        /* attributeValueUnquoted */
        );
        break;

      case "attributeValueDoubleQuoted"
      /* attributeValueDoubleQuoted */
      :
      case "attributeValueSingleQuoted"
      /* attributeValueSingleQuoted */
      :
      case "attributeValueUnquoted"
      /* attributeValueUnquoted */
      :
        this.appendDynamicAttributeValuePart(mustache);
        break;
      // TODO: Only append child when the tokenizer state makes
      // sense to do so, otherwise throw an error.

      default:
        appendChild(this.currentElement(), mustache);
    }

    return mustache;
  }

  appendDynamicAttributeValuePart(part) {
    this.finalizeTextPart();
    let attr = this.currentAttr;
    attr.isDynamic = true;
    attr.parts.push(part);
  }

  finalizeTextPart() {
    let attr = this.currentAttr;
    let text = attr.currentPart;

    if (text !== null) {
      this.currentAttr.parts.push(text);
      this.startTextPart();
    }
  }

  startTextPart() {
    this.currentAttr.currentPart = null;
  }

  ContentStatement(content) {
    updateTokenizerLocation(this.tokenizer, content);
    this.tokenizer.tokenizePart(content.value);
    this.tokenizer.flushData();
  }

  CommentStatement(rawComment) {
    let {
      tokenizer
    } = this;

    if (tokenizer.state === "comment"
    /* comment */
    ) {
        this.appendToCommentData(this.sourceForNode(rawComment));
        return null;
      }

    let {
      value,
      loc
    } = rawComment;
    let comment = b.mustacheComment(value, this.source.spanFor(loc));

    switch (tokenizer.state) {
      case "beforeAttributeName"
      /* beforeAttributeName */
      :
      case "afterAttributeName"
      /* afterAttributeName */
      :
        this.currentStartTag.comments.push(comment);
        break;

      case "beforeData"
      /* beforeData */
      :
      case "data"
      /* data */
      :
        appendChild(this.currentElement(), comment);
        break;

      default:
        throw generateSyntaxError(`Using a Handlebars comment when in the \`${tokenizer['state']}\` state is not supported`, this.source.spanFor(rawComment.loc));
    }

    return comment;
  }

  PartialStatement(partial) {
    throw generateSyntaxError(`Handlebars partials are not supported`, this.source.spanFor(partial.loc));
  }

  PartialBlockStatement(partialBlock) {
    throw generateSyntaxError(`Handlebars partial blocks are not supported`, this.source.spanFor(partialBlock.loc));
  }

  Decorator(decorator) {
    throw generateSyntaxError(`Handlebars decorators are not supported`, this.source.spanFor(decorator.loc));
  }

  DecoratorBlock(decoratorBlock) {
    throw generateSyntaxError(`Handlebars decorator blocks are not supported`, this.source.spanFor(decoratorBlock.loc));
  }

  SubExpression(sexpr) {
    let {
      path,
      params,
      hash
    } = acceptCallNodes(this, sexpr);
    return b.sexpr({
      path,
      params,
      hash,
      loc: this.source.spanFor(sexpr.loc)
    });
  }

  PathExpression(path) {
    let {
      original
    } = path;
    let parts;

    if (original.indexOf('/') !== -1) {
      if (original.slice(0, 2) === './') {
        throw generateSyntaxError(`Using "./" is not supported in Glimmer and unnecessary`, this.source.spanFor(path.loc));
      }

      if (original.slice(0, 3) === '../') {
        throw generateSyntaxError(`Changing context using "../" is not supported in Glimmer`, this.source.spanFor(path.loc));
      }

      if (original.indexOf('.') !== -1) {
        throw generateSyntaxError(`Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths`, this.source.spanFor(path.loc));
      }

      parts = [path.parts.join('/')];
    } else if (original === '.') {
      throw generateSyntaxError(`'.' is not a supported path in Glimmer; check for a path with a trailing '.'`, this.source.spanFor(path.loc));
    } else {
      parts = path.parts;
    }

    let thisHead = false; // This is to fix a bug in the Handlebars AST where the path expressions in
    // `{{this.foo}}` (and similarly `{{foo-bar this.foo named=this.foo}}` etc)
    // are simply turned into `{{foo}}`. The fix is to push it back onto the
    // parts array and let the runtime see the difference. However, we cannot
    // simply use the string `this` as it means literally the property called
    // "this" in the current context (it can be expressed in the syntax as
    // `{{[this]}}`, where the square bracket are generally for this kind of
    // escaping â€“ such as `{{foo.["bar.baz"]}}` would mean lookup a property
    // named literally "bar.baz" on `this.foo`). By convention, we use `null`
    // for this purpose.

    if (original.match(/^this(\..+)?$/)) {
      thisHead = true;
    }

    let pathHead;

    if (thisHead) {
      pathHead = {
        type: 'ThisHead',
        loc: {
          start: path.loc.start,
          end: {
            line: path.loc.start.line,
            column: path.loc.start.column + 4
          }
        }
      };
    } else if (path.data) {
      let head = parts.shift();

      if (head === undefined) {
        throw generateSyntaxError(`Attempted to parse a path expression, but it was not valid. Paths beginning with @ must start with a-z.`, this.source.spanFor(path.loc));
      }

      pathHead = {
        type: 'AtHead',
        name: `@${head}`,
        loc: {
          start: path.loc.start,
          end: {
            line: path.loc.start.line,
            column: path.loc.start.column + head.length + 1
          }
        }
      };
    } else {
      let head = parts.shift();

      if (head === undefined) {
        throw generateSyntaxError(`Attempted to parse a path expression, but it was not valid. Paths must start with a-z or A-Z.`, this.source.spanFor(path.loc));
      }

      pathHead = {
        type: 'VarHead',
        name: head,
        loc: {
          start: path.loc.start,
          end: {
            line: path.loc.start.line,
            column: path.loc.start.column + head.length
          }
        }
      };
    }

    return new PathExpressionImplV1(path.original, pathHead, parts, this.source.spanFor(path.loc));
  }

  Hash(hash) {
    let pairs = [];

    for (let i = 0; i < hash.pairs.length; i++) {
      let pair = hash.pairs[i];
      pairs.push(b.pair({
        key: pair.key,
        value: this.acceptNode(pair.value),
        loc: this.source.spanFor(pair.loc)
      }));
    }

    return b.hash(pairs, this.source.spanFor(hash.loc));
  }

  StringLiteral(string) {
    return b.literal({
      type: 'StringLiteral',
      value: string.value,
      loc: string.loc
    });
  }

  BooleanLiteral(boolean) {
    return b.literal({
      type: 'BooleanLiteral',
      value: boolean.value,
      loc: boolean.loc
    });
  }

  NumberLiteral(number) {
    return b.literal({
      type: 'NumberLiteral',
      value: number.value,
      loc: number.loc
    });
  }

  UndefinedLiteral(undef) {
    return b.literal({
      type: 'UndefinedLiteral',
      value: undefined,
      loc: undef.loc
    });
  }

  NullLiteral(nul) {
    return b.literal({
      type: 'NullLiteral',
      value: null,
      loc: nul.loc
    });
  }

}

function calculateRightStrippedOffsets(original, value) {
  if (value === '') {
    // if it is empty, just return the count of newlines
    // in original
    return {
      lines: original.split('\n').length - 1,
      columns: 0
    };
  } // otherwise, return the number of newlines prior to
  // `value`


  let difference = original.split(value)[0];
  let lines = difference.split(/\n/);
  let lineCount = lines.length - 1;
  return {
    lines: lineCount,
    columns: lines[lineCount].length
  };
}

function updateTokenizerLocation(tokenizer, content) {
  let line = content.loc.start.line;
  let column = content.loc.start.column;
  let offsets = calculateRightStrippedOffsets(content.original, content.value);
  line = line + offsets.lines;

  if (offsets.lines) {
    column = offsets.columns;
  } else {
    column = column + offsets.columns;
  }

  tokenizer.line = line;
  tokenizer.column = column;
}

function acceptCallNodes(compiler, node) {
  let path = node.path.type === 'PathExpression' ? compiler.PathExpression(node.path) : compiler.SubExpression(node.path);
  let params = node.params ? node.params.map(e => compiler.acceptNode(e)) : []; // if there is no hash, position it as a collapsed node immediately after the last param (or the
  // path, if there are also no params)

  let end = params.length > 0 ? params[params.length - 1].loc : path.loc;
  let hash = node.hash ? compiler.Hash(node.hash) : {
    type: 'Hash',
    pairs: [],
    loc: compiler.source.spanFor(end).collapse('end')
  };
  return {
    path,
    params,
    hash
  };
}

function addElementModifier(element, mustache) {
  let {
    path,
    params,
    hash,
    loc
  } = mustache;

  if (isHBSLiteral(path)) {
    let modifier = `{{${printLiteral(path)}}}`;
    let tag = `<${element.name} ... ${modifier} ...`;
    throw generateSyntaxError(`In ${tag}, ${modifier} is not a valid modifier`, mustache.loc);
  }

  let modifier = b.elementModifier({
    path,
    params,
    hash,
    loc
  });
  element.modifiers.push(modifier);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvcGFyc2VyL2hhbmRsZWJhcnMtbm9kZS12aXNpdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFHQSxTQUFTLE1BQVQsUUFBK0MsV0FBL0M7QUFDQSxTQUFTLHFCQUFULFFBQXNDLG9CQUF0QztBQUNBLFNBQVMsbUJBQVQsUUFBb0MsaUJBQXBDO0FBQ0EsU0FBUyxXQUFULEVBQXNCLFlBQXRCLEVBQW9DLFlBQXBDLFFBQXdELFVBQXhEO0FBR0EsU0FBUyxvQkFBVCxRQUFxQyxzQkFBckM7QUFDQSxPQUFPLENBQVAsTUFBYyx1QkFBZDtBQUVBLE9BQU0sTUFBZ0Isc0JBQWhCLFNBQStDLE1BQS9DLENBQXFEO0FBS3pELE1BQVksVUFBWixHQUFzQjtBQUNwQixXQUFPLEtBQUssWUFBTCxDQUFrQixNQUFsQixLQUE2QixDQUFwQztBQUNEOztBQUtELEVBQUEsT0FBTyxDQUFDLE9BQUQsRUFBcUI7QUFDMUIsUUFBSSxJQUFJLEdBQXNCLEVBQTlCO0FBQ0EsUUFBSSxJQUFKOztBQUVBLFFBQUksS0FBSyxVQUFULEVBQXFCO0FBQ25CLE1BQUEsSUFBSSxHQUFHLENBQUMsQ0FBQyxRQUFGLENBQVc7QUFDaEIsUUFBQSxJQURnQjtBQUVoQixRQUFBLFdBQVcsRUFBRSxPQUFPLENBQUMsV0FGTDtBQUdoQixRQUFBLEdBQUcsRUFBRSxLQUFLLE1BQUwsQ0FBWSxPQUFaLENBQW9CLE9BQU8sQ0FBQyxHQUE1QjtBQUhXLE9BQVgsQ0FBUDtBQUtELEtBTkQsTUFNTztBQUNMLE1BQUEsSUFBSSxHQUFHLENBQUMsQ0FBQyxXQUFGLENBQWM7QUFDbkIsUUFBQSxJQURtQjtBQUVuQixRQUFBLFdBQVcsRUFBRSxPQUFPLENBQUMsV0FGRjtBQUduQixRQUFBLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FIRTtBQUluQixRQUFBLEdBQUcsRUFBRSxLQUFLLE1BQUwsQ0FBWSxPQUFaLENBQW9CLE9B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QU0sbUJBQW1CLENBQUMsTUFBTSxHQUFHLEtBQUssUUFBUSwwQkFBdkIsRUFBbUQsUUFBUSxDQUFDLEdBQTVELENBQXpCO0FBQ0Q7O0FBRUQsTUFBSSxRQUFRLEdBQUcsQ0FBQyxDQUFDLGVBQUYsQ0FBa0I7QUFBRSxJQUFBLElBQUY7QUFBUSxJQUFBLE1BQVI7QUFBZ0IsSUFBQSxJQUFoQjtBQUFzQixJQUFBO0FBQXRCLEdBQWxCLENBQWY7QUFDQSxFQUFBLE9BQU8sQ0FBQyxTQUFSLENBQWtCLElBQWxCLENBQXVCLFFBQXZCO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPcHRpb24sIFJlY2FzdCB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgVG9rZW5pemVyU3RhdGUgfSBmcm9tICdzaW1wbGUtaHRtbC10b2tlbml6ZXInO1xuXG5pbXBvcnQgeyBQYXJzZXIsIFBhcnNlck5vZGVCdWlsZGVyLCBUYWcgfSBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHsgTk9OX0VYSVNURU5UX0xPQ0FUSU9OIH0gZnJvbSAnLi4vc291cmNlL2xvY2F0aW9uJztcbmltcG9ydCB7IGdlbmVyYXRlU3ludGF4RXJyb3IgfSBmcm9tICcuLi9zeW50YXgtZXJyb3InO1xuaW1wb3J0IHsgYXBwZW5kQ2hpbGQsIGlzSEJTTGl0ZXJhbCwgcHJpbnRMaXRlcmFsIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0ICogYXMgQVNUdjEgZnJvbSAnLi4vdjEvYXBpJztcbmltcG9ydCAqIGFzIEhCUyBmcm9tICcuLi92MS9oYW5kbGViYXJzLWFzdCc7XG5pbXBvcnQgeyBQYXRoRXhwcmVzc2lvbkltcGxWMSB9IGZyb20gJy4uL3YxL2xlZ2FjeS1pbnRlcm9wJztcbmltcG9ydCBiIGZyb20gJy4uL3YxL3BhcnNlci1idWlsZGVycyc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBIYW5kbGViYXJzTm9kZVZpc2l0b3JzIGV4dGVuZHMgUGFyc2VyIHtcbiAgYWJzdHJhY3QgYXBwZW5kVG9Db21tZW50RGF0YShzOiBzdHJpbmcpOiB2b2lkO1xuICBhYnN0cmFjdCBiZWdpbkF0dHJpYnV0ZVZhbHVlKHF1b3RlZDogYm9vbGVhbik6IHZvaWQ7XG4gIGFic3RyYWN0IGZpbmlzaEF0dHJpYnV0ZVZhbHVlKCk6IHZvaWQ7XG5cbiAgcHJpdmF0ZSBnZXQgaXNUb3BMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50U3RhY2subGVuZ3RoID09PSAwO1xuICB9XG5cbiAgUHJvZ3JhbShwcm9ncmFtOiBIQlMuUHJvZ3JhbSk6IEFTVHYxLkJsb2NrO1xuICBQcm9ncmFtKHByb2dyYW06IEhCUy5Qcm9ncmFtKTogQVNUdjEuVGVtcGxhdGU7XG4gIFByb2dyYW0ocHJvZ3JhbTogSEJTLlByb2dyYW0pOiBBU1R2MS5UZW1wbGF0ZSB8IEFTVHYxLkJsb2NrO1xuICBQcm9ncmFtKHByb2dyYW06IEhCUy5Qcm9ncmFtKTogQVNUdjEuQmxvY2sgfCBBU1R2MS5UZW1wbGF0ZSB7XG4gICAgbGV0IGJvZHk6IEFTVHYxLlN0YXRlbWVudFtdID0gW107XG4gICAgbGV0IG5vZGU7XG5cbiAgICBpZiAodGhpcy5pc1RvcExldmVsKSB7XG4gICAgICBub2RlID0gYi50ZW1wbGF0ZSh7XG4gICAgICAgIGJvZHksXG4gICAgICAgIGJsb2NrUGFyYW1zOiBwcm9ncmFtLmJsb2NrUGFyYW1zLFxuICAgICAgICBsb2M6IHRoaXMuc291cmNlLnNwYW5Gb3IocHJvZ3JhbS5sb2MpLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBiLmJsb2NrSXRzZWxmKHtcbiAgICAgICAgYm9keSxcbiAgICAgICAgYmxvY2tQYXJhbXM6IHByb2dyYW0uYmxvY2tQYXJhbXMsXG4gICAgICAgIGNoYWluZWQ6IHByb2dyYW0uY2hhaW5lZCxcbiAgICAgICAgbG9jOiB0aGlzLnNvdXJjZS5zcGFuRm9yKHByb2dyYW0ubG9jKSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxldCBpLFxuICAgICAgbCA9IHByb2dyYW0uYm9keS5sZW5ndGg7XG5cbiAgICB0aGlzLmVsZW1lbnRTdGFjay5wdXNoKG5vZGUpO1xuXG4gICAgaWYgKGwgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRTdGFjay5wb3AoKSBhcyBBU1R2MS5CbG9jayB8IEFTVHYxLlRlbXBsYXRlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMuYWNjZXB0Tm9kZShwcm9ncmFtLmJvZHlbaV0pO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoYXQgdGhlIGVsZW1lbnQgc3RhY2sgaXMgYmFsYW5jZWQgcHJvcGVybHkuXG4gICAgbGV0IHBvcHBlZE5vZGUgPSB0aGlzLmVsZW1lbnRTdGFjay5wb3AoKTtcbiAgICBpZiAocG9wcGVkTm9kZSAhPT0gbm9kZSkge1xuICAgICAgbGV0IGVsZW1lbnROb2RlID0gcG9wcGVkTm9kZSBhcyBBU1R2MS5FbGVtZW50Tm9kZTtcblxuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihgVW5jbG9zZWQgZWxlbWVudCBcXGAke2VsZW1lbnROb2RlLnRhZ31cXGBgLCBlbGVtZW50Tm9kZS5sb2MpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgQmxvY2tTdGF0ZW1lbnQoYmxvY2s6IEhCUy5CbG9ja1N0YXRlbWVudCk6IEFTVHYxLkJsb2NrU3RhdGVtZW50IHwgdm9pZCB7XG4gICAgaWYgKHRoaXMudG9rZW5pemVyLnN0YXRlID09PSBUb2tlbml6ZXJTdGF0ZS5jb21tZW50KSB7XG4gICAgICB0aGlzLmFwcGVuZFRvQ29tbWVudERhdGEodGhpcy5zb3VyY2VGb3JOb2RlKGJsb2NrKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdGhpcy50b2tlbml6ZXIuc3RhdGUgIT09IFRva2VuaXplclN0YXRlLmRhdGEgJiZcbiAgICAgIHRoaXMudG9rZW5pemVyLnN0YXRlICE9PSBUb2tlbml6ZXJTdGF0ZS5iZWZvcmVEYXRhXG4gICAgKSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAnQSBibG9jayBtYXkgb25seSBiZSB1c2VkIGluc2lkZSBhbiBIVE1MIGVsZW1lbnQgb3IgYW5vdGhlciBibG9jay4nLFxuICAgICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKGJsb2NrLmxvYylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHsgcGF0aCwgcGFyYW1zLCBoYXNoIH0gPSBhY2NlcHRDYWxsTm9kZXModGhpcywgYmxvY2spO1xuXG4gICAgLy8gVGhlc2UgYXJlIGJ1Z3MgaW4gSGFuZGxlYmFycyB1cHN0cmVhbVxuICAgIGlmICghYmxvY2sucHJvZ3JhbS5sb2MpIHtcbiAgICAgIGJsb2NrLnByb2dyYW0ubG9jID0gTk9OX0VYSVNURU5UX0xPQ0FUSU9OO1xuICAgIH1cblxuICAgIGlmIChibG9jay5pbnZlcnNlICYmICFibG9jay5pbnZlcnNlLmxvYykge1xuICAgICAgYmxvY2suaW52ZXJzZS5sb2MgPSBOT05fRVhJU1RFTlRfTE9DQVRJT047XG4gICAgfVxuXG4gICAgbGV0IHByb2dyYW0gPSB0aGlzLlByb2dyYW0oYmxvY2sucHJvZ3JhbSk7XG4gICAgbGV0IGludmVyc2UgPSBibG9jay5pbnZlcnNlID8gdGhpcy5Qcm9ncmFtKGJsb2NrLmludmVyc2UpIDogbnVsbDtcblxuICAgIGxldCBub2RlID0gYi5ibG9jayh7XG4gICAgICBwYXRoLFxuICAgICAgcGFyYW1zLFxuICAgICAgaGFzaCxcbiAgICAgIGRlZmF1bHRCbG9jazogcHJvZ3JhbSxcbiAgICAgIGVsc2VCbG9jazogaW52ZXJzZSxcbiAgICAgIGxvYzogdGhpcy5zb3VyY2Uuc3BhbkZvcihibG9jay5sb2MpLFxuICAgICAgb3BlblN0cmlwOiBibG9jay5vcGVuU3RyaXAsXG4gICAgICBpbnZlcnNlU3RyaXA6IGJsb2NrLmludmVyc2VTdHJpcCxcbiAgICAgIGNsb3NlU3RyaXA6IGJsb2NrLmNsb3NlU3RyaXAsXG4gICAgfSk7XG5cbiAgICBsZXQgcGFyZW50UHJvZ3JhbSA9IHRoaXMuY3VycmVudEVsZW1lbnQoKTtcblxuICAgIGFwcGVuZENoaWxkKHBhcmVudFByb2dyYW0sIG5vZGUpO1xuICB9XG5cbiAgTXVzdGFjaGVTdGF0ZW1lbnQocmF3TXVzdGFjaGU6IEhCUy5NdXN0YWNoZVN0YXRlbWVudCk6IEFTVHYxLk11c3RhY2hlU3RhdGVtZW50IHwgdm9pZCB7XG4gICAgbGV0IHsgdG9rZW5pemVyIH0gPSB0aGlzO1xuXG4gICAgaWYgKHRva2VuaXplci5zdGF0ZSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgICB0aGlzLmFwcGVuZFRvQ29tbWVudERhdGEodGhpcy5zb3VyY2VGb3JOb2RlKHJhd011c3RhY2hlKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IG11c3RhY2hlOiBBU1R2MS5NdXN0YWNoZVN0YXRlbWVudDtcbiAgICBsZXQgeyBlc2NhcGVkLCBsb2MsIHN0cmlwIH0gPSByYXdNdXN0YWNoZTtcblxuICAgIGlmIChpc0hCU0xpdGVyYWwocmF3TXVzdGFjaGUucGF0aCkpIHtcbiAgICAgIG11c3RhY2hlID0gYi5tdXN0YWNoZSh7XG4gICAgICAgIHBhdGg6IHRoaXMuYWNjZXB0Tm9kZTxBU1R2MS5MaXRlcmFsPihyYXdNdXN0YWNoZS5wYXRoKSxcbiAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgaGFzaDogYi5oYXNoKFtdLCB0aGlzLnNvdXJjZS5zcGFuRm9yKHJhd011c3RhY2hlLnBhdGgubG9jKS5jb2xsYXBzZSgnZW5kJykpLFxuICAgICAgICB0cnVzdGluZzogIWVzY2FwZWQsXG4gICAgICAgIGxvYzogdGhpcy5zb3VyY2Uuc3BhbkZvcihsb2MpLFxuICAgICAgICBzdHJpcCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2ggfSA9IGFjY2VwdENhbGxOb2RlcyhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgcmF3TXVzdGFjaGUgYXMgSEJTLk11c3RhY2hlU3RhdGVtZW50ICYge1xuICAgICAgICAgIHBhdGg6IEhCUy5QYXRoRXhwcmVzc2lvbiB8IEhCUy5TdWJFeHByZXNzaW9uO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgbXVzdGFjaGUgPSBiLm11c3RhY2hlKHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBoYXNoLFxuICAgICAgICB0cnVzdGluZzogIWVzY2FwZWQsXG4gICAgICAgIGxvYzogdGhpcy5zb3VyY2Uuc3BhbkZvcihsb2MpLFxuICAgICAgICBzdHJpcCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHN3aXRjaCAodG9rZW5pemVyLnN0YXRlKSB7XG4gICAgICAvLyBUYWcgaGVscGVyc1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS50YWdPcGVuOlxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS50YWdOYW1lOlxuICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKGBDYW5ub3QgdXNlIG11c3RhY2hlcyBpbiBhbiBlbGVtZW50cyB0YWduYW1lYCwgbXVzdGFjaGUubG9jKTtcblxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5iZWZvcmVBdHRyaWJ1dGVOYW1lOlxuICAgICAgICBhZGRFbGVtZW50TW9kaWZpZXIodGhpcy5jdXJyZW50U3RhcnRUYWcsIG11c3RhY2hlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmF0dHJpYnV0ZU5hbWU6XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmFmdGVyQXR0cmlidXRlTmFtZTpcbiAgICAgICAgdGhpcy5iZWdpbkF0dHJpYnV0ZVZhbHVlKGZhbHNlKTtcbiAgICAgICAgdGhpcy5maW5pc2hBdHRyaWJ1dGVWYWx1ZSgpO1xuICAgICAgICBhZGRFbGVtZW50TW9kaWZpZXIodGhpcy5jdXJyZW50U3RhcnRUYWcsIG11c3RhY2hlKTtcbiAgICAgICAgdG9rZW5pemVyLnRyYW5zaXRpb25UbyhUb2tlbml6ZXJTdGF0ZS5iZWZvcmVBdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmFmdGVyQXR0cmlidXRlVmFsdWVRdW90ZWQ6XG4gICAgICAgIGFkZEVsZW1lbnRNb2RpZmllcih0aGlzLmN1cnJlbnRTdGFydFRhZywgbXVzdGFjaGUpO1xuICAgICAgICB0b2tlbml6ZXIudHJhbnNpdGlvblRvKFRva2VuaXplclN0YXRlLmJlZm9yZUF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gQXR0cmlidXRlIHZhbHVlc1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5iZWZvcmVBdHRyaWJ1dGVWYWx1ZTpcbiAgICAgICAgdGhpcy5iZWdpbkF0dHJpYnV0ZVZhbHVlKGZhbHNlKTtcbiAgICAgICAgdGhpcy5hcHBlbmREeW5hbWljQXR0cmlidXRlVmFsdWVQYXJ0KG11c3RhY2hlKTtcbiAgICAgICAgdG9rZW5pemVyLnRyYW5zaXRpb25UbyhUb2tlbml6ZXJTdGF0ZS5hdHRyaWJ1dGVWYWx1ZVVucXVvdGVkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmF0dHJpYnV0ZVZhbHVlRG91YmxlUXVvdGVkOlxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hdHRyaWJ1dGVWYWx1ZVNpbmdsZVF1b3RlZDpcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYXR0cmlidXRlVmFsdWVVbnF1b3RlZDpcbiAgICAgICAgdGhpcy5hcHBlbmREeW5hbWljQXR0cmlidXRlVmFsdWVQYXJ0KG11c3RhY2hlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIFRPRE86IE9ubHkgYXBwZW5kIGNoaWxkIHdoZW4gdGhlIHRva2VuaXplciBzdGF0ZSBtYWtlc1xuICAgICAgLy8gc2Vuc2UgdG8gZG8gc28sIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvci5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFwcGVuZENoaWxkKHRoaXMuY3VycmVudEVsZW1lbnQoKSwgbXVzdGFjaGUpO1xuICAgIH1cblxuICAgIHJldHVybiBtdXN0YWNoZTtcbiAgfVxuXG4gIGFwcGVuZER5bmFtaWNBdHRyaWJ1dGVWYWx1ZVBhcnQocGFydDogQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQpOiB2b2lkIHtcbiAgICB0aGlzLmZpbmFsaXplVGV4dFBhcnQoKTtcbiAgICBsZXQgYXR0ciA9IHRoaXMuY3VycmVudEF0dHI7XG4gICAgYXR0ci5pc0R5bmFtaWMgPSB0cnVlO1xuICAgIGF0dHIucGFydHMucHVzaChwYXJ0KTtcbiAgfVxuXG4gIGZpbmFsaXplVGV4dFBhcnQoKTogdm9pZCB7XG4gICAgbGV0IGF0dHIgPSB0aGlzLmN1cnJlbnRBdHRyO1xuICAgIGxldCB0ZXh0ID0gYXR0ci5jdXJyZW50UGFydDtcbiAgICBpZiAodGV4dCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5jdXJyZW50QXR0ci5wYXJ0cy5wdXNoKHRleHQpO1xuICAgICAgdGhpcy5zdGFydFRleHRQYXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgc3RhcnRUZXh0UGFydCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRBdHRyLmN1cnJlbnRQYXJ0ID0gbnVsbDtcbiAgfVxuXG4gIENvbnRlbnRTdGF0ZW1lbnQoY29udGVudDogSEJTLkNvbnRlbnRTdGF0ZW1lbnQpOiB2b2lkIHtcbiAgICB1cGRhdGVUb2tlbml6ZXJMb2NhdGlvbih0aGlzLnRva2VuaXplciwgY29udGVudCk7XG5cbiAgICB0aGlzLnRva2VuaXplci50b2tlbml6ZVBhcnQoY29udGVudC52YWx1ZSk7XG4gICAgdGhpcy50b2tlbml6ZXIuZmx1c2hEYXRhKCk7XG4gIH1cblxuICBDb21tZW50U3RhdGVtZW50KHJhd0NvbW1lbnQ6IEhCUy5Db21tZW50U3RhdGVtZW50KTogT3B0aW9uPEFTVHYxLk11c3RhY2hlQ29tbWVudFN0YXRlbWVudD4ge1xuICAgIGxldCB7IHRva2VuaXplciB9ID0gdGhpcztcblxuICAgIGlmICh0b2tlbml6ZXIuc3RhdGUgPT09IFRva2VuaXplclN0YXRlLmNvbW1lbnQpIHtcbiAgICAgIHRoaXMuYXBwZW5kVG9Db21tZW50RGF0YSh0aGlzLnNvdXJjZUZvck5vZGUocmF3Q29tbWVudCkpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IHsgdmFsdWUsIGxvYyB9ID0gcmF3Q29tbWVudDtcbiAgICBsZXQgY29tbWVudCA9IGIubXVzdGFjaGVDb21tZW50KHZhbHVlLCB0aGlzLnNvdXJjZS5zcGFuRm9yKGxvYykpO1xuXG4gICAgc3dpdGNoICh0b2tlbml6ZXIuc3RhdGUpIHtcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlTmFtZTpcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYWZ0ZXJBdHRyaWJ1dGVOYW1lOlxuICAgICAgICB0aGlzLmN1cnJlbnRTdGFydFRhZy5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5iZWZvcmVEYXRhOlxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5kYXRhOlxuICAgICAgICBhcHBlbmRDaGlsZCh0aGlzLmN1cnJlbnRFbGVtZW50KCksIGNvbW1lbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICBgVXNpbmcgYSBIYW5kbGViYXJzIGNvbW1lbnQgd2hlbiBpbiB0aGUgXFxgJHt0b2tlbml6ZXJbJ3N0YXRlJ119XFxgIHN0YXRlIGlzIG5vdCBzdXBwb3J0ZWRgLFxuICAgICAgICAgIHRoaXMuc291cmNlLnNwYW5Gb3IocmF3Q29tbWVudC5sb2MpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbW1lbnQ7XG4gIH1cblxuICBQYXJ0aWFsU3RhdGVtZW50KHBhcnRpYWw6IEhCUy5QYXJ0aWFsU3RhdGVtZW50KTogbmV2ZXIge1xuICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICBgSGFuZGxlYmFycyBwYXJ0aWFscyBhcmUgbm90IHN1cHBvcnRlZGAsXG4gICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKHBhcnRpYWwubG9jKVxuICAgICk7XG4gIH1cblxuICBQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQocGFydGlhbEJsb2NrOiBIQlMuUGFydGlhbEJsb2NrU3RhdGVtZW50KTogbmV2ZXIge1xuICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICBgSGFuZGxlYmFycyBwYXJ0aWFsIGJsb2NrcyBhcmUgbm90IHN1cHBvcnRlZGAsXG4gICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKHBhcnRpYWxCbG9jay5sb2MpXG4gICAgKTtcbiAgfVxuXG4gIERlY29yYXRvcihkZWNvcmF0b3I6IEhCUy5EZWNvcmF0b3IpOiBuZXZlciB7XG4gICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgIGBIYW5kbGViYXJzIGRlY29yYXRvcnMgYXJlIG5vdCBzdXBwb3J0ZWRgLFxuICAgICAgdGhpcy5zb3VyY2Uuc3BhbkZvcihkZWNvcmF0b3IubG9jKVxuICAgICk7XG4gIH1cblxuICBEZWNvcmF0b3JCbG9jayhkZWNvcmF0b3JCbG9jazogSEJTLkRlY29yYXRvckJsb2NrKTogbmV2ZXIge1xuICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICBgSGFuZGxlYmFycyBkZWNvcmF0b3IgYmxvY2tzIGFyZSBub3Qgc3VwcG9ydGVkYCxcbiAgICAgIHRoaXMuc291cmNlLnNwYW5Gb3IoZGVjb3JhdG9yQmxvY2subG9jKVxuICAgICk7XG4gIH1cblxuICBTdWJFeHByZXNzaW9uKHNleHByOiBIQlMuU3ViRXhwcmVzc2lvbik6IEFTVHYxLlN1YkV4cHJlc3Npb24ge1xuICAgIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCB9ID0gYWNjZXB0Q2FsbE5vZGVzKHRoaXMsIHNleHByKTtcbiAgICByZXR1cm4gYi5zZXhwcih7IHBhdGgsIHBhcmFtcywgaGFzaCwgbG9jOiB0aGlzLnNvdXJjZS5zcGFuRm9yKHNleHByLmxvYykgfSk7XG4gIH1cblxuICBQYXRoRXhwcmVzc2lvbihwYXRoOiBIQlMuUGF0aEV4cHJlc3Npb24pOiBBU1R2MS5QYXRoRXhwcmVzc2lvbiB7XG4gICAgbGV0IHsgb3JpZ2luYWwgfSA9IHBhdGg7XG4gICAgbGV0IHBhcnRzOiBzdHJpbmdbXTtcblxuICAgIGlmIChvcmlnaW5hbC5pbmRleE9mKCcvJykgIT09IC0xKSB7XG4gICAgICBpZiAob3JpZ2luYWwuc2xpY2UoMCwgMikgPT09ICcuLycpIHtcbiAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICBgVXNpbmcgXCIuL1wiIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2xpbW1lciBhbmQgdW5uZWNlc3NhcnlgLFxuICAgICAgICAgIHRoaXMuc291cmNlLnNwYW5Gb3IocGF0aC5sb2MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWwuc2xpY2UoMCwgMykgPT09ICcuLi8nKSB7XG4gICAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgYENoYW5naW5nIGNvbnRleHQgdXNpbmcgXCIuLi9cIiBpcyBub3Qgc3VwcG9ydGVkIGluIEdsaW1tZXJgLFxuICAgICAgICAgIHRoaXMuc291cmNlLnNwYW5Gb3IocGF0aC5sb2MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWwuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgIGBNaXhpbmcgJy4nIGFuZCAnLycgaW4gcGF0aHMgaXMgbm90IHN1cHBvcnRlZCBpbiBHbGltbWVyOyB1c2Ugb25seSAnLicgdG8gc2VwYXJhdGUgcHJvcGVydHkgcGF0aHNgLFxuICAgICAgICAgIHRoaXMuc291cmNlLnNwYW5Gb3IocGF0aC5sb2MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwYXJ0cyA9IFtwYXRoLnBhcnRzLmpvaW4oJy8nKV07XG4gICAgfSBlbHNlIGlmIChvcmlnaW5hbCA9PT0gJy4nKSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICBgJy4nIGlzIG5vdCBhIHN1cHBvcnRlZCBwYXRoIGluIEdsaW1tZXI7IGNoZWNrIGZvciBhIHBhdGggd2l0aCBhIHRyYWlsaW5nICcuJ2AsXG4gICAgICAgIHRoaXMuc291cmNlLnNwYW5Gb3IocGF0aC5sb2MpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0cyA9IHBhdGgucGFydHM7XG4gICAgfVxuXG4gICAgbGV0IHRoaXNIZWFkID0gZmFsc2U7XG5cbiAgICAvLyBUaGlzIGlzIHRvIGZpeCBhIGJ1ZyBpbiB0aGUgSGFuZGxlYmFycyBBU1Qgd2hlcmUgdGhlIHBhdGggZXhwcmVzc2lvbnMgaW5cbiAgICAvLyBge3t0aGlzLmZvb319YCAoYW5kIHNpbWlsYXJseSBge3tmb28tYmFyIHRoaXMuZm9vIG5hbWVkPXRoaXMuZm9vfX1gIGV0YylcbiAgICAvLyBhcmUgc2ltcGx5IHR1cm5lZCBpbnRvIGB7e2Zvb319YC4gVGhlIGZpeCBpcyB0byBwdXNoIGl0IGJhY2sgb250byB0aGVcbiAgICAvLyBwYXJ0cyBhcnJheSBhbmQgbGV0IHRoZSBydW50aW1lIHNlZSB0aGUgZGlmZmVyZW5jZS4gSG93ZXZlciwgd2UgY2Fubm90XG4gICAgLy8gc2ltcGx5IHVzZSB0aGUgc3RyaW5nIGB0aGlzYCBhcyBpdCBtZWFucyBsaXRlcmFsbHkgdGhlIHByb3BlcnR5IGNhbGxlZFxuICAgIC8vIFwidGhpc1wiIGluIHRoZSBjdXJyZW50IGNvbnRleHQgKGl0IGNhbiBiZSBleHByZXNzZWQgaW4gdGhlIHN5bnRheCBhc1xuICAgIC8vIGB7e1t0aGlzXX19YCwgd2hlcmUgdGhlIHNxdWFyZSBicmFja2V0IGFyZSBnZW5lcmFsbHkgZm9yIHRoaXMga2luZCBvZlxuICAgIC8vIGVzY2FwaW5nIOKAkyBzdWNoIGFzIGB7e2Zvby5bXCJiYXIuYmF6XCJdfX1gIHdvdWxkIG1lYW4gbG9va3VwIGEgcHJvcGVydHlcbiAgICAvLyBuYW1lZCBsaXRlcmFsbHkgXCJiYXIuYmF6XCIgb24gYHRoaXMuZm9vYCkuIEJ5IGNvbnZlbnRpb24sIHdlIHVzZSBgbnVsbGBcbiAgICAvLyBmb3IgdGhpcyBwdXJwb3NlLlxuICAgIGlmIChvcmlnaW5hbC5tYXRjaCgvXnRoaXMoXFwuLispPyQvKSkge1xuICAgICAgdGhpc0hlYWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCBwYXRoSGVhZDogQVNUdjEuUGF0aEhlYWQ7XG4gICAgaWYgKHRoaXNIZWFkKSB7XG4gICAgICBwYXRoSGVhZCA9IHtcbiAgICAgICAgdHlwZTogJ1RoaXNIZWFkJyxcbiAgICAgICAgbG9jOiB7XG4gICAgICAgICAgc3RhcnQ6IHBhdGgubG9jLnN0YXJ0LFxuICAgICAgICAgIGVuZDogeyBsaW5lOiBwYXRoLmxvYy5zdGFydC5saW5lLCBjb2x1bW46IHBhdGgubG9jLnN0YXJ0LmNvbHVtbiArIDQgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChwYXRoLmRhdGEpIHtcbiAgICAgIGxldCBoZWFkID0gcGFydHMuc2hpZnQoKTtcblxuICAgICAgaWYgKGhlYWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gcGFyc2UgYSBwYXRoIGV4cHJlc3Npb24sIGJ1dCBpdCB3YXMgbm90IHZhbGlkLiBQYXRocyBiZWdpbm5pbmcgd2l0aCBAIG11c3Qgc3RhcnQgd2l0aCBhLXouYCxcbiAgICAgICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKHBhdGgubG9jKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBwYXRoSGVhZCA9IHtcbiAgICAgICAgdHlwZTogJ0F0SGVhZCcsXG4gICAgICAgIG5hbWU6IGBAJHtoZWFkfWAsXG4gICAgICAgIGxvYzoge1xuICAgICAgICAgIHN0YXJ0OiBwYXRoLmxvYy5zdGFydCxcbiAgICAgICAgICBlbmQ6IHsgbGluZTogcGF0aC5sb2Muc3RhcnQubGluZSwgY29sdW1uOiBwYXRoLmxvYy5zdGFydC5jb2x1bW4gKyBoZWFkLmxlbmd0aCArIDEgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBoZWFkID0gcGFydHMuc2hpZnQoKTtcblxuICAgICAgaWYgKGhlYWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gcGFyc2UgYSBwYXRoIGV4cHJlc3Npb24sIGJ1dCBpdCB3YXMgbm90IHZhbGlkLiBQYXRocyBtdXN0IHN0YXJ0IHdpdGggYS16IG9yIEEtWi5gLFxuICAgICAgICAgIHRoaXMuc291cmNlLnNwYW5Gb3IocGF0aC5sb2MpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHBhdGhIZWFkID0ge1xuICAgICAgICB0eXBlOiAnVmFySGVhZCcsXG4gICAgICAgIG5hbWU6IGhlYWQsXG4gICAgICAgIGxvYzoge1xuICAgICAgICAgIHN0YXJ0OiBwYXRoLmxvYy5zdGFydCxcbiAgICAgICAgICBlbmQ6IHsgbGluZTogcGF0aC5sb2Muc3RhcnQubGluZSwgY29sdW1uOiBwYXRoLmxvYy5zdGFydC5jb2x1bW4gKyBoZWFkLmxlbmd0aCB9LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBhdGhFeHByZXNzaW9uSW1wbFYxKHBhdGgub3JpZ2luYWwsIHBhdGhIZWFkLCBwYXJ0cywgdGhpcy5zb3VyY2Uuc3BhbkZvcihwYXRoLmxvYykpO1xuICB9XG5cbiAgSGFzaChoYXNoOiBIQlMuSGFzaCk6IEFTVHYxLkhhc2gge1xuICAgIGxldCBwYWlyczogQVNUdjEuSGFzaFBhaXJbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYXNoLnBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgcGFpciA9IGhhc2gucGFpcnNbaV07XG4gICAgICBwYWlycy5wdXNoKFxuICAgICAgICBiLnBhaXIoe1xuICAgICAgICAgIGtleTogcGFpci5rZXksXG4gICAgICAgICAgdmFsdWU6IHRoaXMuYWNjZXB0Tm9kZShwYWlyLnZhbHVlKSxcbiAgICAgICAgICBsb2M6IHRoaXMuc291cmNlLnNwYW5Gb3IocGFpci5sb2MpLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYi5oYXNoKHBhaXJzLCB0aGlzLnNvdXJjZS5zcGFuRm9yKGhhc2gubG9jKSk7XG4gIH1cblxuICBTdHJpbmdMaXRlcmFsKHN0cmluZzogSEJTLlN0cmluZ0xpdGVyYWwpOiBBU1R2MS5TdHJpbmdMaXRlcmFsIHtcbiAgICByZXR1cm4gYi5saXRlcmFsKHsgdHlwZTogJ1N0cmluZ0xpdGVyYWwnLCB2YWx1ZTogc3RyaW5nLnZhbHVlLCBsb2M6IHN0cmluZy5sb2MgfSk7XG4gIH1cblxuICBCb29sZWFuTGl0ZXJhbChib29sZWFuOiBIQlMuQm9vbGVhbkxpdGVyYWwpOiBBU1R2MS5Cb29sZWFuTGl0ZXJhbCB7XG4gICAgcmV0dXJuIGIubGl0ZXJhbCh7IHR5cGU6ICdCb29sZWFuTGl0ZXJhbCcsIHZhbHVlOiBib29sZWFuLnZhbHVlLCBsb2M6IGJvb2xlYW4ubG9jIH0pO1xuICB9XG5cbiAgTnVtYmVyTGl0ZXJhbChudW1iZXI6IEhCUy5OdW1iZXJMaXRlcmFsKTogQVNUdjEuTnVtYmVyTGl0ZXJhbCB7XG4gICAgcmV0dXJuIGIubGl0ZXJhbCh7IHR5cGU6ICdOdW1iZXJMaXRlcmFsJywgdmFsdWU6IG51bWJlci52YWx1ZSwgbG9jOiBudW1iZXIubG9jIH0pO1xuICB9XG5cbiAgVW5kZWZpbmVkTGl0ZXJhbCh1bmRlZjogSEJTLlVuZGVmaW5lZExpdGVyYWwpOiBBU1R2MS5VbmRlZmluZWRMaXRlcmFsIHtcbiAgICByZXR1cm4gYi5saXRlcmFsKHsgdHlwZTogJ1VuZGVmaW5lZExpdGVyYWwnLCB2YWx1ZTogdW5kZWZpbmVkLCBsb2M6IHVuZGVmLmxvYyB9KTtcbiAgfVxuXG4gIE51bGxMaXRlcmFsKG51bDogSEJTLk51bGxMaXRlcmFsKTogQVNUdjEuTnVsbExpdGVyYWwge1xuICAgIHJldHVybiBiLmxpdGVyYWwoeyB0eXBlOiAnTnVsbExpdGVyYWwnLCB2YWx1ZTogbnVsbCwgbG9jOiBudWwubG9jIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJpZ2h0U3RyaXBwZWRPZmZzZXRzKG9yaWdpbmFsOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgaWYgKHZhbHVlID09PSAnJykge1xuICAgIC8vIGlmIGl0IGlzIGVtcHR5LCBqdXN0IHJldHVybiB0aGUgY291bnQgb2YgbmV3bGluZXNcbiAgICAvLyBpbiBvcmlnaW5hbFxuICAgIHJldHVybiB7XG4gICAgICBsaW5lczogb3JpZ2luYWwuc3BsaXQoJ1xcbicpLmxlbmd0aCAtIDEsXG4gICAgICBjb2x1bW5zOiAwLFxuICAgIH07XG4gIH1cblxuICAvLyBvdGhlcndpc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIG5ld2xpbmVzIHByaW9yIHRvXG4gIC8vIGB2YWx1ZWBcbiAgbGV0IGRpZmZlcmVuY2UgPSBvcmlnaW5hbC5zcGxpdCh2YWx1ZSlbMF07XG4gIGxldCBsaW5lcyA9IGRpZmZlcmVuY2Uuc3BsaXQoL1xcbi8pO1xuICBsZXQgbGluZUNvdW50ID0gbGluZXMubGVuZ3RoIC0gMTtcblxuICByZXR1cm4ge1xuICAgIGxpbmVzOiBsaW5lQ291bnQsXG4gICAgY29sdW1uczogbGluZXNbbGluZUNvdW50XS5sZW5ndGgsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRva2VuaXplckxvY2F0aW9uKHRva2VuaXplcjogUGFyc2VyWyd0b2tlbml6ZXInXSwgY29udGVudDogSEJTLkNvbnRlbnRTdGF0ZW1lbnQpIHtcbiAgbGV0IGxpbmUgPSBjb250ZW50LmxvYy5zdGFydC5saW5lO1xuICBsZXQgY29sdW1uID0gY29udGVudC5sb2Muc3RhcnQuY29sdW1uO1xuXG4gIGxldCBvZmZzZXRzID0gY2FsY3VsYXRlUmlnaHRTdHJpcHBlZE9mZnNldHMoXG4gICAgY29udGVudC5vcmlnaW5hbCBhcyBSZWNhc3Q8SEJTLlN0cmlwRmxhZ3MsIHN0cmluZz4sXG4gICAgY29udGVudC52YWx1ZVxuICApO1xuXG4gIGxpbmUgPSBsaW5lICsgb2Zmc2V0cy5saW5lcztcbiAgaWYgKG9mZnNldHMubGluZXMpIHtcbiAgICBjb2x1bW4gPSBvZmZzZXRzLmNvbHVtbnM7XG4gIH0gZWxzZSB7XG4gICAgY29sdW1uID0gY29sdW1uICsgb2Zmc2V0cy5jb2x1bW5zO1xuICB9XG5cbiAgdG9rZW5pemVyLmxpbmUgPSBsaW5lO1xuICB0b2tlbml6ZXIuY29sdW1uID0gY29sdW1uO1xufVxuXG5mdW5jdGlvbiBhY2NlcHRDYWxsTm9kZXMoXG4gIGNvbXBpbGVyOiBIYW5kbGViYXJzTm9kZVZpc2l0b3JzLFxuICBub2RlOiB7XG4gICAgcGF0aDogSEJTLlBhdGhFeHByZXNzaW9uIHwgSEJTLlN1YkV4cHJlc3Npb247XG4gICAgcGFyYW1zOiBIQlMuRXhwcmVzc2lvbltdO1xuICAgIGhhc2g6IEhCUy5IYXNoO1xuICB9XG4pOiB7XG4gIHBhdGg6IEFTVHYxLlBhdGhFeHByZXNzaW9uIHwgQVNUdjEuU3ViRXhwcmVzc2lvbjtcbiAgcGFyYW1zOiBBU1R2MS5FeHByZXNzaW9uW107XG4gIGhhc2g6IEFTVHYxLkhhc2g7XG59IHtcbiAgbGV0IHBhdGggPVxuICAgIG5vZGUucGF0aC50eXBlID09PSAnUGF0aEV4cHJlc3Npb24nXG4gICAgICA/IGNvbXBpbGVyLlBhdGhFeHByZXNzaW9uKG5vZGUucGF0aClcbiAgICAgIDogY29tcGlsZXIuU3ViRXhwcmVzc2lvbihub2RlLnBhdGgpO1xuICBsZXQgcGFyYW1zID0gbm9kZS5wYXJhbXMgPyBub2RlLnBhcmFtcy5tYXAoKGUpID0+IGNvbXBpbGVyLmFjY2VwdE5vZGU8QVNUdjEuRXhwcmVzc2lvbj4oZSkpIDogW107XG5cbiAgLy8gaWYgdGhlcmUgaXMgbm8gaGFzaCwgcG9zaXRpb24gaXQgYXMgYSBjb2xsYXBzZWQgbm9kZSBpbW1lZGlhdGVseSBhZnRlciB0aGUgbGFzdCBwYXJhbSAob3IgdGhlXG4gIC8vIHBhdGgsIGlmIHRoZXJlIGFyZSBhbHNvIG5vIHBhcmFtcylcbiAgbGV0IGVuZCA9IHBhcmFtcy5sZW5ndGggPiAwID8gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXS5sb2MgOiBwYXRoLmxvYztcblxuICBsZXQgaGFzaCA9IG5vZGUuaGFzaFxuICAgID8gY29tcGlsZXIuSGFzaChub2RlLmhhc2gpXG4gICAgOiAoe1xuICAgICAgICB0eXBlOiAnSGFzaCcsXG4gICAgICAgIHBhaXJzOiBbXSBhcyBBU1R2MS5IYXNoUGFpcltdLFxuICAgICAgICBsb2M6IGNvbXBpbGVyLnNvdXJjZS5zcGFuRm9yKGVuZCkuY29sbGFwc2UoJ2VuZCcpLFxuICAgICAgfSBhcyBjb25zdCk7XG5cbiAgcmV0dXJuIHsgcGF0aCwgcGFyYW1zLCBoYXNoIH07XG59XG5cbmZ1bmN0aW9uIGFkZEVsZW1lbnRNb2RpZmllcihcbiAgZWxlbWVudDogUGFyc2VyTm9kZUJ1aWxkZXI8VGFnPCdTdGFydFRhZyc+PixcbiAgbXVzdGFjaGU6IEFTVHYxLk11c3RhY2hlU3RhdGVtZW50XG4pIHtcbiAgbGV0IHsgcGF0aCwgcGFyYW1zLCBoYXNoLCBsb2MgfSA9IG11c3RhY2hlO1xuXG4gIGlmIChpc0hCU0xpdGVyYWwocGF0aCkpIHtcbiAgICBsZXQgbW9kaWZpZXIgPSBge3ske3ByaW50TGl0ZXJhbChwYXRoKX19fWA7XG4gICAgbGV0IHRhZyA9IGA8JHtlbGVtZW50Lm5hbWV9IC4uLiAke21vZGlmaWVyfSAuLi5gO1xuXG4gICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihgSW4gJHt0YWd9LCAke21vZGlmaWVyfSBpcyBub3QgYSB2YWxpZCBtb2RpZmllcmAsIG11c3RhY2hlLmxvYyk7XG4gIH1cblxuICBsZXQgbW9kaWZpZXIgPSBiLmVsZW1lbnRNb2RpZmllcih7IHBhdGgsIHBhcmFtcywgaGFzaCwgbG9jIH0pO1xuICBlbGVtZW50Lm1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=