// eslint-disable-next-line import/no-extraneous-dependencies
import { DEBUG } from '@glimmer/env';
import { assert } from '@glimmer/util';
import { SourceOffset, SourceSpan } from './span';
export class Source {
  constructor(source, module = 'an unknown module') {
    this.source = source;
    this.module = module;
  }
  /**
   * Validate that the character offset represents a position in the source string.
   */


  check(offset) {
    return offset >= 0 && offset <= this.source.length;
  }

  slice(start, end) {
    return this.source.slice(start, end);
  }

  offsetFor(line, column) {
    return SourceOffset.forHbsPos(this, {
      line,
      column
    });
  }

  spanFor({
    start,
    end
  }) {
    return SourceSpan.forHbsLoc(this, {
      start: {
        line: start.line,
        column: start.column
      },
      end: {
        line: end.line,
        column: end.column
      }
    });
  }

  hbsPosFor(offset) {
    let seenLines = 0;
    let seenChars = 0;

    if (offset > this.source.length) {
      return null;
    }

    while (true) {
      let nextLine = this.source.indexOf('\n', seenChars);

      if (offset <= nextLine || nextLine === -1) {
        return {
          line: seenLines + 1,
          column: offset - seenChars
        };
      } else {
        seenLines += 1;
        seenChars = nextLine + 1;
      }
    }
  }

  charPosFor(position) {
    let {
      line,
      column
    } = position;
    let sourceString = this.source;
    let sourceLength = sourceString.length;
    let seenLines = 0;
    let seenChars = 0;

    while (true) {
      if (seenChars >= sourceLength) return sourceLength;
      let nextLine = this.source.indexOf('\n', seenChars);
      if (nextLine === -1) nextLine = this.source.length;

      if (seenLines === line - 1) {
        if (seenChars + column > nextLine) return nextLine;

        if (DEBUG) {
          let roundTrip = this.hbsPosFor(seenChars + column);
          (false && assert(roundTrip !== null, `the returned offset failed to round-trip`));
          (false && assert(roundTrip.line === line, `the round-tripped line didn't match the original line`));
          (false && assert(roundTrip.column === column, `the round-tripped column didn't match the original column`));
        }

        return seenChars + column;
      } else if (nextLine === -1) {
        return 0;
      } else {
        seenLines += 1;
        seenChars = nextLine + 1;
      }
    }
  }

}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvc291cmNlL3NvdXJjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFNBQVMsS0FBVCxRQUFzQixjQUF0QjtBQUVBLFNBQVMsTUFBVCxRQUF1QixlQUF2QjtBQUdBLFNBQVMsWUFBVCxFQUF1QixVQUF2QixRQUF5QyxRQUF6QztBQUVBLE9BQU0sTUFBTyxNQUFQLENBQWE7QUFDakIsRUFBQSxXQUFBLENBQXFCLE1BQXJCLEVBQThDLE1BQUEsR0FBaUIsbUJBQS9ELEVBQWtGO0FBQTdELFNBQUEsTUFBQSxHQUFBLE1BQUE7QUFBeUIsU0FBQSxNQUFBLEdBQUEsTUFBQTtBQUF3QztBQUV0Rjs7Ozs7QUFHQSxFQUFBLEtBQUssQ0FBQyxNQUFELEVBQWU7QUFDbEIsV0FBTyxNQUFNLElBQUksQ0FBVixJQUFlLE1BQU0sSUFBSSxLQUFLLE1BQUwsQ0FBWSxNQUE1QztBQUNEOztBQUVELEVBQUEsS0FBSyxDQUFDLEtBQUQsRUFBZ0IsR0FBaEIsRUFBMkI7QUFDOUIsV0FBTyxLQUFLLE1BQUwsQ0FBWSxLQUFaLENBQWtCLEtBQWxCLEVBQXlCLEdBQXpCLENBQVA7QUFDRDs7QUFFRCxFQUFBLFNBQVMsQ0FBQyxJQUFELEVBQWUsTUFBZixFQUE2QjtBQUNwQyxXQUFPLFlBQVksQ0FBQyxTQUFiLENBQXVCLElBQXZCLEVBQTZCO0FBQUUsTUFBQSxJQUFGO0FBQVEsTUFBQTtBQUFSLEtBQTdCLENBQVA7QUFDRDs7QUFFRCxFQUFBLE9BQU8sQ0FBQztBQUFFLElBQUEsS0FBRjtBQUFTLElBQUE7QUFBVCxHQUFELEVBQXlDO0FBQzlDLFdBQU8sVUFBVSxDQUFDLFNBQVgsQ0FBcUIsSUFBckIsRUFBMkI7QUFDaEMsTUFBQSxLQUFLLEVBQUU7QUFBRSxRQUFBLElBQUksRUFBRSxLQUFLLENBQUMsSUFBZDtBQUFvQixRQUFBLE1BQU0sRUFBRSxLQUFLLENBQUM7QUFBbEMsT0FEeUI7QUFFaEMsTUFBQSxHQUFHLEVBQUU7QUFBRSxRQUFBLElBQUksRUFBRSxHQUFHLENBQUMsSUFBWjtBQUFrQixRQUFBLE1BQU0sRUFBRSxHQUFHLENBQUM7QUFBOUI7QUFGMkIsS0FBM0IsQ0FBUDtBQUlEOztBQUVELEVBQUEsU0FBUyxDQUFDLE1BQUQsRUFBZTtBQUN0QixRQUFJLFNBQVMsR0FBRyxDQUFoQjtBQUNBLFFBQUksU0FBUyxHQUFHLENBQWhCOztBQUVBLFFBQUksTUFBTSxHQUFHLEtBQUssTUFBTCxDQUFZLE1BQXpCLEVBQWlDO0FBQy9CLGFBQU8sSUFBUDtBQUNEOztBQUVELFdBQU8sSUFBUCxFQUFhO0FBQ1gsVUFBSSxRQUFRLEdBQUcsS0FBSyxNQUFMLENBQVksT0FBWixDQUFvQixJQUFwQixFQUEwQixTQUExQixDQUFmOztBQUVBLFVBQUksTUFBTSxJQUFJLFFBQVYsSUFBc0IsUUFBUSxLQUFLLENBQUMsQ0FBeEMsRUFBMkM7QUFDekMsZUFBTztBQUNMLFVBQUEsSUFBSSxFQUFFLFNBQVMsR0FBRyxDQURiO0FBRUwsVUFBQSxNQUFNLEVBQUUsTUFBTSxHQUFHO0FBRlosU0FBUDtBQUlELE9BTEQsTUFLTztBQUNMLFFBQUEsU0FBUyxJQUFJLENBQWI7QUFDQSxRQUFBLFNBQVMsR0FBRyxRQUFRLEdBQUcsQ0FBdkI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsRUFBQSxVQUFVLENBQUMsUUFBRCxFQUF5QjtBQUNqQyxRQUFJO0FBQUUsTUFBQSxJQUFGO0FBQVEsTUFBQTtBQUFSLFFBQW1CLFFBQXZCO0FBQ0EsUUFBSSxZQUFZLEdBQUcsS0FBSyxNQUF4QjtBQUNBLFFBQUksWUFBWSxHQUFHLFlBQVksQ0FBQyxNQUFoQztBQUNBLFFBQUksU0FBUyxHQUFHLENBQWhCO0FBQ0EsUUFBSSxTQUFTLEdBQUcsQ0FBaEI7O0FBRUEsV0FBTyxJQUFQLEVBQWE7QUFDWCxVQUFJLFNBQVMsSUFBSSxZQUFqQixFQUErQixPQUFPLFlBQVA7QUFFL0IsVUFBSSxRQUFRLEdBQUcsS0FBSyxNQUFMLENBQVksT0FBWixDQUFvQixJQUFwQixFQUEwQixTQUExQixDQUFmO0FBQ0EsVUFBSSxRQUFRLEtBQUssQ0FBQyxDQUFsQixFQUFxQixRQUFRLEdBQUcsS0FBSyxNQUFMLENBQVksTUFBdkI7O0FBRXJCLFVBQUksU0FBUyxLQUFLLElBQUksR0FBRyxDQUF6QixFQUE0QjtBQUMxQixZQUFJLFNBQVMsR0FBRyxNQUFaLEdBQXFCLFFBQXpCLEVBQW1DLE9BQU8sUUFBUDs7QUFFbkMsWUFBSSxLQUFKLEVBQVc7QUFDVCxjQUFJLFNBQVMsR0FBRyxLQUFLLFNBQUwsQ0FBZSxTQUFTLEdBQUcsTUFBM0IsQ0FBaEI7QUFEUyxvQkFFVCxNQUFNLENBQUMsU0FBUyxLQUFLLElBQWYsRUFBcUIsMENBQXJCLENBRkc7QUFBQSxvQkFHVCxNQUFNLENBQUMsU0FBUyxDQUFDLElBQVYsS0FBbUIsSUFBcEIsRUFBMEIsdURBQTFCLENBSEc7QUFBQSxvQkFJVCxNQUFNLENBQ0osU0FBUyxDQUFDLE1BQVYsS0FBcUIsTUFEakIsRUFFSiwyREFGSSxDQUpHO0FBUVY7O0FBRUQsZUFBTyxTQUFTLEdBQUcsTUFBbkI7QUFDRCxPQWRELE1BY08sSUFBSSxRQUFRLEtBQUssQ0FBQyxDQUFsQixFQUFxQjtBQUMxQixlQUFPLENBQVA7QUFDRCxPQUZNLE1BRUE7QUFDTCxRQUFBLFNBQVMsSUFBSSxDQUFiO0FBQ0EsUUFBQSxTQUFTLEdBQUcsUUFBUSxHQUFHLENBQXZCO0FBQ0Q7QUFDRjtBQUNGOztBQWxGZ0IiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5pbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQgdHlwZSB7IE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmltcG9ydCB7IFNvdXJjZUxvY2F0aW9uLCBTb3VyY2VQb3NpdGlvbiB9IGZyb20gJy4vbG9jYXRpb24nO1xuaW1wb3J0IHsgU291cmNlT2Zmc2V0LCBTb3VyY2VTcGFuIH0gZnJvbSAnLi9zcGFuJztcblxuZXhwb3J0IGNsYXNzIFNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHNvdXJjZTogc3RyaW5nLCByZWFkb25seSBtb2R1bGU6IHN0cmluZyA9ICdhbiB1bmtub3duIG1vZHVsZScpIHt9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHRoYXQgdGhlIGNoYXJhY3RlciBvZmZzZXQgcmVwcmVzZW50cyBhIHBvc2l0aW9uIGluIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgKi9cbiAgY2hlY2sob2Zmc2V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gb2Zmc2V0ID49IDAgJiYgb2Zmc2V0IDw9IHRoaXMuc291cmNlLmxlbmd0aDtcbiAgfVxuXG4gIHNsaWNlKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIH1cblxuICBvZmZzZXRGb3IobGluZTogbnVtYmVyLCBjb2x1bW46IG51bWJlcik6IFNvdXJjZU9mZnNldCB7XG4gICAgcmV0dXJuIFNvdXJjZU9mZnNldC5mb3JIYnNQb3ModGhpcywgeyBsaW5lLCBjb2x1bW4gfSk7XG4gIH1cblxuICBzcGFuRm9yKHsgc3RhcnQsIGVuZCB9OiBSZWFkb25seTxTb3VyY2VMb2NhdGlvbj4pOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gU291cmNlU3Bhbi5mb3JIYnNMb2ModGhpcywge1xuICAgICAgc3RhcnQ6IHsgbGluZTogc3RhcnQubGluZSwgY29sdW1uOiBzdGFydC5jb2x1bW4gfSxcbiAgICAgIGVuZDogeyBsaW5lOiBlbmQubGluZSwgY29sdW1uOiBlbmQuY29sdW1uIH0sXG4gICAgfSk7XG4gIH1cblxuICBoYnNQb3NGb3Iob2Zmc2V0OiBudW1iZXIpOiBPcHRpb248U291cmNlUG9zaXRpb24+IHtcbiAgICBsZXQgc2VlbkxpbmVzID0gMDtcbiAgICBsZXQgc2VlbkNoYXJzID0gMDtcblxuICAgIGlmIChvZmZzZXQgPiB0aGlzLnNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgbmV4dExpbmUgPSB0aGlzLnNvdXJjZS5pbmRleE9mKCdcXG4nLCBzZWVuQ2hhcnMpO1xuXG4gICAgICBpZiAob2Zmc2V0IDw9IG5leHRMaW5lIHx8IG5leHRMaW5lID09PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHNlZW5MaW5lcyArIDEsXG4gICAgICAgICAgY29sdW1uOiBvZmZzZXQgLSBzZWVuQ2hhcnMsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuTGluZXMgKz0gMTtcbiAgICAgICAgc2VlbkNoYXJzID0gbmV4dExpbmUgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNoYXJQb3NGb3IocG9zaXRpb246IFNvdXJjZVBvc2l0aW9uKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgbGV0IHsgbGluZSwgY29sdW1uIH0gPSBwb3NpdGlvbjtcbiAgICBsZXQgc291cmNlU3RyaW5nID0gdGhpcy5zb3VyY2U7XG4gICAgbGV0IHNvdXJjZUxlbmd0aCA9IHNvdXJjZVN0cmluZy5sZW5ndGg7XG4gICAgbGV0IHNlZW5MaW5lcyA9IDA7XG4gICAgbGV0IHNlZW5DaGFycyA9IDA7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHNlZW5DaGFycyA+PSBzb3VyY2VMZW5ndGgpIHJldHVybiBzb3VyY2VMZW5ndGg7XG5cbiAgICAgIGxldCBuZXh0TGluZSA9IHRoaXMuc291cmNlLmluZGV4T2YoJ1xcbicsIHNlZW5DaGFycyk7XG4gICAgICBpZiAobmV4dExpbmUgPT09IC0xKSBuZXh0TGluZSA9IHRoaXMuc291cmNlLmxlbmd0aDtcblxuICAgICAgaWYgKHNlZW5MaW5lcyA9PT0gbGluZSAtIDEpIHtcbiAgICAgICAgaWYgKHNlZW5DaGFycyArIGNvbHVtbiA+IG5leHRMaW5lKSByZXR1cm4gbmV4dExpbmU7XG5cbiAgICAgICAgaWYgKERFQlVHKSB7XG4gICAgICAgICAgbGV0IHJvdW5kVHJpcCA9IHRoaXMuaGJzUG9zRm9yKHNlZW5DaGFycyArIGNvbHVtbik7XG4gICAgICAgICAgYXNzZXJ0KHJvdW5kVHJpcCAhPT0gbnVsbCwgYHRoZSByZXR1cm5lZCBvZmZzZXQgZmFpbGVkIHRvIHJvdW5kLXRyaXBgKTtcbiAgICAgICAgICBhc3NlcnQocm91bmRUcmlwLmxpbmUgPT09IGxpbmUsIGB0aGUgcm91bmQtdHJpcHBlZCBsaW5lIGRpZG4ndCBtYXRjaCB0aGUgb3JpZ2luYWwgbGluZWApO1xuICAgICAgICAgIGFzc2VydChcbiAgICAgICAgICAgIHJvdW5kVHJpcC5jb2x1bW4gPT09IGNvbHVtbixcbiAgICAgICAgICAgIGB0aGUgcm91bmQtdHJpcHBlZCBjb2x1bW4gZGlkbid0IG1hdGNoIHRoZSBvcmlnaW5hbCBjb2x1bW5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWVuQ2hhcnMgKyBjb2x1bW47XG4gICAgICB9IGVsc2UgaWYgKG5leHRMaW5lID09PSAtMSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZW5MaW5lcyArPSAxO1xuICAgICAgICBzZWVuQ2hhcnMgPSBuZXh0TGluZSArIDE7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9