import { assert } from '@glimmer/util';
import { PathExpressionImplV1 } from './legacy-interop';
var DEFAULT_STRIP = {
  close: false,
  open: false
};
/**
 * The Parser Builder differentiates from the public builder API by:
 *
 * 1. Offering fewer different ways to instantiate nodes
 * 2. Mandating source locations
 */

var Builders = /*#__PURE__*/function () {
  function Builders() {}

  var _proto = Builders.prototype;

  _proto.pos = function pos(line, column) {
    return {
      line: line,
      column: column
    };
  };

  _proto.blockItself = function blockItself(_ref) {
    var body = _ref.body,
        blockParams = _ref.blockParams,
        _ref$chained = _ref.chained,
        chained = _ref$chained === void 0 ? false : _ref$chained,
        loc = _ref.loc;
    return {
      type: 'Block',
      body: body || [],
      blockParams: blockParams || [],
      chained: chained,
      loc: loc
    };
  };

  _proto.template = function template(_ref2) {
    var body = _ref2.body,
        blockParams = _ref2.blockParams,
        loc = _ref2.loc;
    return {
      type: 'Template',
      body: body || [],
      blockParams: blockParams || [],
      loc: loc
    };
  };

  _proto.mustache = function mustache(_ref3) {
    var path = _ref3.path,
        params = _ref3.params,
        hash = _ref3.hash,
        trusting = _ref3.trusting,
        loc = _ref3.loc,
        _ref3$strip = _ref3.strip,
        strip = _ref3$strip === void 0 ? DEFAULT_STRIP : _ref3$strip;
    return {
      type: 'MustacheStatement',
      path: path,
      params: params,
      hash: hash,
      escaped: !trusting,
      trusting: trusting,
      loc: loc,
      strip: strip || {
        open: false,
        close: false
      }
    };
  };

  _proto.block = function block(_ref4) {
    var path = _ref4.path,
        params = _ref4.params,
        hash = _ref4.hash,
        defaultBlock = _ref4.defaultBlock,
        _ref4$elseBlock = _ref4.elseBlock,
        elseBlock = _ref4$elseBlock === void 0 ? null : _ref4$elseBlock,
        loc = _ref4.loc,
        _ref4$openStrip = _ref4.openStrip,
        openStrip = _ref4$openStrip === void 0 ? DEFAULT_STRIP : _ref4$openStrip,
        _ref4$inverseStrip = _ref4.inverseStrip,
        inverseStrip = _ref4$inverseStrip === void 0 ? DEFAULT_STRIP : _ref4$inverseStrip,
        _ref4$closeStrip = _ref4.closeStrip,
        closeStrip = _ref4$closeStrip === void 0 ? DEFAULT_STRIP : _ref4$closeStrip;
    return {
      type: 'BlockStatement',
      path: path,
      params: params,
      hash: hash,
      program: defaultBlock,
      inverse: elseBlock,
      loc: loc,
      openStrip: openStrip,
      inverseStrip: inverseStrip,
      closeStrip: closeStrip
    };
  };

  _proto.comment = function comment(value, loc) {
    return {
      type: 'CommentStatement',
      value: value,
      loc: loc
    };
  };

  _proto.mustacheComment = function mustacheComment(value, loc) {
    return {
      type: 'MustacheCommentStatement',
      value: value,
      loc: loc
    };
  };

  _proto.concat = function concat(parts, loc) {
    return {
      type: 'ConcatStatement',
      parts: parts,
      loc: loc
    };
  };

  _proto.element = function element(_ref5) {
    var tag = _ref5.tag,
        selfClosing = _ref5.selfClosing,
        attrs = _ref5.attrs,
        blockParams = _ref5.blockParams,
        modifiers = _ref5.modifiers,
        comments = _ref5.comments,
        children = _ref5.children,
        loc = _ref5.loc;
    return {
      type: 'ElementNode',
      tag: tag,
      selfClosing: selfClosing,
      attributes: attrs || [],
      blockParams: blockParams || [],
      modifiers: modifiers || [],
      comments: comments || [],
      children: children || [],
      loc: loc
    };
  };

  _proto.elementModifier = function elementModifier(_ref6) {
    var path = _ref6.path,
        params = _ref6.params,
        hash = _ref6.hash,
        loc = _ref6.loc;
    return {
      type: 'ElementModifierStatement',
      path: path,
      params: params,
      hash: hash,
      loc: loc
    };
  };

  _proto.attr = function attr(_ref7) {
    var name = _ref7.name,
        value = _ref7.value,
        loc = _ref7.loc;
    return {
      type: 'AttrNode',
      name: name,
      value: value,
      loc: loc
    };
  };

  _proto.text = function text(_ref8) {
    var chars = _ref8.chars,
        loc = _ref8.loc;
    return {
      type: 'TextNode',
      chars: chars,
      loc: loc
    };
  };

  _proto.sexpr = function sexpr(_ref9) {
    var path = _ref9.path,
        params = _ref9.params,
        hash = _ref9.hash,
        loc = _ref9.loc;
    return {
      type: 'SubExpression',
      path: path,
      params: params,
      hash: hash,
      loc: loc
    };
  };

  _proto.path = function path(_ref10) {
    var head = _ref10.head,
        tail = _ref10.tail,
        loc = _ref10.loc;

    var _headToString = headToString(head),
        originalHead = _headToString.original;

    var original = [].concat(originalHead, tail).join('.');
    return new PathExpressionImplV1(original, head, tail, loc);
  };

  _proto.head = function head(_head, loc) {
    if (_head[0] === '@') {
      return this.atName(_head, loc);
    } else if (_head === 'this') {
      return this["this"](loc);
    } else {
      return this["var"](_head, loc);
    }
  };

  _proto["this"] = function _this(loc) {
    return {
      type: 'ThisHead',
      loc: loc
    };
  };

  _proto.atName = function atName(name, loc) {
    // the `@` should be included so we have a complete source range
    false && assert(name[0] === '@', "call builders.at() with a string that starts with '@'");
    return {
      type: 'AtHead',
      name: name,
      loc: loc
    };
  };

  _proto["var"] = function _var(name, loc) {
    false && assert(name !== 'this', "You called builders.var() with 'this'. Call builders.this instead");
    false && assert(name[0] !== '@', "You called builders.var() with '" + name + "'. Call builders.at('" + name + "') instead");
    return {
      type: 'VarHead',
      name: name,
      loc: loc
    };
  };

  _proto.hash = function hash(pairs, loc) {
    return {
      type: 'Hash',
      pairs: pairs || [],
      loc: loc
    };
  };

  _proto.pair = function pair(_ref11) {
    var key = _ref11.key,
        value = _ref11.value,
        loc = _ref11.loc;
    return {
      type: 'HashPair',
      key: key,
      value: value,
      loc: loc
    };
  };

  _proto.literal = function literal(_ref12) {
    var type = _ref12.type,
        value = _ref12.value,
        loc = _ref12.loc;
    return {
      type: type,
      value: value,
      original: value,
      loc: loc
    };
  };

  _proto.undefined = function (_undefined) {
    function undefined() {
      return _undefined.apply(this, arguments);
    }

    undefined.toString = function () {
      return _undefined.toString();
    };

    return undefined;
  }(function () {
    return this.literal({
      type: 'UndefinedLiteral',
      value: undefined
    });
  });

  _proto["null"] = function _null() {
    return this.literal({
      type: 'NullLiteral',
      value: null
    });
  };

  _proto.string = function string(value, loc) {
    return this.literal({
      type: 'StringLiteral',
      value: value,
      loc: loc
    });
  };

  _proto["boolean"] = function boolean(value, loc) {
    return this.literal({
      type: 'BooleanLiteral',
      value: value,
      loc: loc
    });
  };

  _proto.number = function number(value, loc) {
    return this.literal({
      type: 'NumberLiteral',
      value: value,
      loc: loc
    });
  };

  return Builders;
}(); // Expressions


function headToString(head) {
  switch (head.type) {
    case 'AtHead':
      return {
        original: head.name,
        parts: [head.name]
      };

    case 'ThisHead':
      return {
        original: "this",
        parts: []
      };

    case 'VarHead':
      return {
        original: head.name,
        parts: [head.name]
      };
  }
}

export default new Builders();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvdjEvcGFyc2VyLWJ1aWxkZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLFNBQUEsTUFBQSxRQUFBLGVBQUE7QUFNQSxTQUFBLG9CQUFBLFFBQUEsa0JBQUE7QUFFQSxJQUFNLGFBQWEsR0FBRztBQUNwQixFQUFBLEtBQUssRUFEZSxLQUFBO0FBRXBCLEVBQUEsSUFBSSxFQUFFO0FBRmMsQ0FBdEI7QUFLQTs7Ozs7OztJQU1BLFE7Ozs7O1NBQ0UsRyxHQUFBLGFBQUcsSUFBSCxFQUFHLE1BQUgsRUFBZ0M7QUFDOUIsV0FBTztBQUNMLE1BQUEsSUFESyxFQUNMLElBREs7QUFFTCxNQUFBLE1BQUEsRUFBQTtBQUZLLEtBQVA7QUFJRCxHOztTQUVELFcsR0FBQSwyQkFVQztBQUFBLFFBVlcsSUFVWCxRQVZXLElBVVg7QUFBQSxRQVZXLFdBVVgsUUFWVyxXQVVYO0FBQUEsNEJBUEMsT0FPRDtBQUFBLFFBUEMsT0FPRCw2QkFWVyxLQVVYO0FBQUEsUUFOQyxHQU1ELFFBTkMsR0FNRDtBQUNDLFdBQU87QUFDTCxNQUFBLElBQUksRUFEQyxPQUFBO0FBRUwsTUFBQSxJQUFJLEVBQUUsSUFBSSxJQUZMLEVBQUE7QUFHTCxNQUFBLFdBQVcsRUFBRSxXQUFXLElBSG5CLEVBQUE7QUFJTCxNQUFBLE9BSkssRUFJTCxPQUpLO0FBS0wsTUFBQSxHQUFBLEVBQUE7QUFMSyxLQUFQO0FBT0QsRzs7U0FFRCxRLEdBQUEseUJBUUM7QUFBQSxRQVJRLElBUVIsU0FSUSxJQVFSO0FBQUEsUUFSUSxXQVFSLFNBUlEsV0FRUjtBQUFBLFFBTEMsR0FLRCxTQUxDLEdBS0Q7QUFDQyxXQUFPO0FBQ0wsTUFBQSxJQUFJLEVBREMsVUFBQTtBQUVMLE1BQUEsSUFBSSxFQUFFLElBQUksSUFGTCxFQUFBO0FBR0wsTUFBQSxXQUFXLEVBQUUsV0FBVyxJQUhuQixFQUFBO0FBSUwsTUFBQSxHQUFBLEVB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Q0g7OztBQUVBLFNBQUEsWUFBQSxDQUFBLElBQUEsRUFBMEM7QUFDeEMsVUFBUSxJQUFJLENBQVosSUFBQTtBQUNFLFNBQUEsUUFBQTtBQUNFLGFBQU87QUFBRSxRQUFBLFFBQVEsRUFBRSxJQUFJLENBQWhCLElBQUE7QUFBdUIsUUFBQSxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUwsSUFBQTtBQUE5QixPQUFQOztBQUNGLFNBQUEsVUFBQTtBQUNFLGFBQU87QUFBRSxRQUFBLFFBQUYsUUFBQTtBQUFvQixRQUFBLEtBQUssRUFBRTtBQUEzQixPQUFQOztBQUNGLFNBQUEsU0FBQTtBQUNFLGFBQU87QUFBRSxRQUFBLFFBQVEsRUFBRSxJQUFJLENBQWhCLElBQUE7QUFBdUIsUUFBQSxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUwsSUFBQTtBQUE5QixPQUFQO0FBTko7QUFRRDs7QUFFRCxlQUFlLElBQWYsUUFBZSxFQUFmIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGljdCwgT3B0aW9uLCBQcmVzZW50QXJyYXkgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5pbXBvcnQgeyBQYXJzZXJOb2RlQnVpbGRlciB9IGZyb20gJy4uL3BhcnNlcic7XG5pbXBvcnQgeyBTb3VyY2VMb2NhdGlvbiB9IGZyb20gJy4uL3NvdXJjZS9sb2NhdGlvbic7XG5pbXBvcnQgeyBTb3VyY2VPZmZzZXQsIFNvdXJjZVNwYW4gfSBmcm9tICcuLi9zb3VyY2Uvc3Bhbic7XG5pbXBvcnQgKiBhcyBBU1R2MSBmcm9tICcuL2FwaSc7XG5pbXBvcnQgeyBQYXRoRXhwcmVzc2lvbkltcGxWMSB9IGZyb20gJy4vbGVnYWN5LWludGVyb3AnO1xuXG5jb25zdCBERUZBVUxUX1NUUklQID0ge1xuICBjbG9zZTogZmFsc2UsXG4gIG9wZW46IGZhbHNlLFxufTtcblxuLyoqXG4gKiBUaGUgUGFyc2VyIEJ1aWxkZXIgZGlmZmVyZW50aWF0ZXMgZnJvbSB0aGUgcHVibGljIGJ1aWxkZXIgQVBJIGJ5OlxuICpcbiAqIDEuIE9mZmVyaW5nIGZld2VyIGRpZmZlcmVudCB3YXlzIHRvIGluc3RhbnRpYXRlIG5vZGVzXG4gKiAyLiBNYW5kYXRpbmcgc291cmNlIGxvY2F0aW9uc1xuICovXG5jbGFzcyBCdWlsZGVycyB7XG4gIHBvcyhsaW5lOiBudW1iZXIsIGNvbHVtbjogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmUsXG4gICAgICBjb2x1bW4sXG4gICAgfTtcbiAgfVxuXG4gIGJsb2NrSXRzZWxmKHtcbiAgICBib2R5LFxuICAgIGJsb2NrUGFyYW1zLFxuICAgIGNoYWluZWQgPSBmYWxzZSxcbiAgICBsb2MsXG4gIH06IHtcbiAgICBib2R5PzogQVNUdjEuU3RhdGVtZW50W107XG4gICAgYmxvY2tQYXJhbXM/OiBzdHJpbmdbXTtcbiAgICBjaGFpbmVkPzogYm9vbGVhbjtcbiAgICBsb2M6IFNvdXJjZVNwYW47XG4gIH0pOiBBU1R2MS5CbG9jayB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdCbG9jaycsXG4gICAgICBib2R5OiBib2R5IHx8IFtdLFxuICAgICAgYmxvY2tQYXJhbXM6IGJsb2NrUGFyYW1zIHx8IFtdLFxuICAgICAgY2hhaW5lZCxcbiAgICAgIGxvYyxcbiAgICB9O1xuICB9XG5cbiAgdGVtcGxhdGUoe1xuICAgIGJvZHksXG4gICAgYmxvY2tQYXJhbXMsXG4gICAgbG9jLFxuICB9OiB7XG4gICAgYm9keT86IEFTVHYxLlN0YXRlbWVudFtdO1xuICAgIGJsb2NrUGFyYW1zPzogc3RyaW5nW107XG4gICAgbG9jOiBTb3VyY2VTcGFuO1xuICB9KTogQVNUdjEuVGVtcGxhdGUge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnVGVtcGxhdGUnLFxuICAgICAgYm9keTogYm9keSB8fCBbXSxcbiAgICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyB8fCBbXSxcbiAgICAgIGxvYyxcbiAgICB9O1xuICB9XG5cbiAgbXVzdGFjaGUoe1xuICAgIHBhdGgsXG4gICAgcGFyYW1zLFxuICAgIGhhc2gsXG4gICAgdHJ1c3RpbmcsXG4gICAgbG9jLFxuICAgIHN0cmlwID0gREVGQVVMVF9TVFJJUCxcbiAgfToge1xuICAgIHBhdGg6IEFTVHYxLkV4cHJlc3Npb247XG4gICAgcGFyYW1zOiBBU1R2MS5FeHByZXNzaW9uW107XG4gICAgaGFzaDogQVNUdjEuSGFzaDtcbiAgICB0cnVzdGluZzogYm9vbGVhbjtcbiAgICBsb2M6IFNvdXJjZVNwYW47XG4gICAgc3RyaXA6IEFTVHYxLlN0cmlwRmxhZ3M7XG4gIH0pOiBBU1R2MS5NdXN0YWNoZVN0YXRlbWVudCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdNdXN0YWNoZVN0YXRlbWVudCcsXG4gICAgICBwYXRoLFxuICAgICAgcGFyYW1zLFxuICAgICAgaGFzaCxcbiAgICAgIGVzY2FwZWQ6ICF0cnVzdGluZyxcbiAgICAgIHRydXN0aW5nLFxuICAgICAgbG9jLFxuICAgICAgc3RyaXA6IHN0cmlwIHx8IHsgb3BlbjogZmFsc2UsIGNsb3NlOiBmYWxzZSB9LFxuICAgIH07XG4gIH1cblxuICBibG9jayh7XG4gICAgcGF0aCxcbiAgICBwYXJhbXMsXG4gICAgaGFzaCxcbiAgICBkZWZhdWx0QmxvY2ssXG4gICAgZWxzZUJsb2NrID0gbnVsbCxcbiAgICBsb2MsXG4gICAgb3BlblN0cmlwID0gREVGQVVMVF9TVFJJUCxcbiAgICBpbnZlcnNlU3RyaXAgPSBERUZBVUxUX1NUUklQLFxuICAgIGNsb3NlU3RyaXAgPSBERUZBVUxUX1NUUklQLFxuICB9OiB7XG4gICAgcGF0aDogQVNUdjEuUGF0aEV4cHJlc3Npb24gfCBBU1R2MS5TdWJFeHByZXNzaW9uO1xuICAgIHBhcmFtczogQVNUdjEuRXhwcmVzc2lvbltdO1xuICAgIGhhc2g6IEFTVHYxLkhhc2g7XG4gICAgZGVmYXVsdEJsb2NrOiBBU1R2MS5CbG9jaztcbiAgICBlbHNlQmxvY2s/OiBPcHRpb248QVNUdjEuQmxvY2s+O1xuICAgIGxvYzogU291cmNlU3BhbjtcbiAgICBvcGVuU3RyaXA6IEFTVHYxLlN0cmlwRmxhZ3M7XG4gICAgaW52ZXJzZVN0cmlwOiBBU1R2MS5TdHJpcEZsYWdzO1xuICAgIGNsb3NlU3RyaXA6IEFTVHYxLlN0cmlwRmxhZ3M7XG4gIH0pOiBBU1R2MS5CbG9ja1N0YXRlbWVudCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdCbG9ja1N0YXRlbWVudCcsXG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgcGFyYW1zLFxuICAgICAgaGFzaCxcbiAgICAgIHByb2dyYW06IGRlZmF1bHRCbG9jayxcbiAgICAgIGludmVyc2U6IGVsc2VCbG9jayxcbiAgICAgIGxvYzogbG9jLFxuICAgICAgb3BlblN0cmlwOiBvcGVuU3RyaXAsXG4gICAgICBpbnZlcnNlU3RyaXA6IGludmVyc2VTdHJpcCxcbiAgICAgIGNsb3NlU3RyaXA6IGNsb3NlU3RyaXAsXG4gICAgfTtcbiAgfVxuXG4gIGNvbW1lbnQodmFsdWU6IHN0cmluZywgbG9jOiBTb3VyY2VPZmZzZXQpOiBQYXJzZXJOb2RlQnVpbGRlcjxBU1R2MS5Db21tZW50U3RhdGVtZW50PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdDb21tZW50U3RhdGVtZW50JyxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGxvYyxcbiAgICB9O1xuICB9XG5cbiAgbXVzdGFjaGVDb21tZW50KHZhbHVlOiBzdHJpbmcsIGxvYzogU291cmNlU3Bhbik6IEFTVHYxLk11c3RhY2hlQ29tbWVudFN0YXRlbWVudCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQnLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgbG9jLFxuICAgIH07XG4gIH1cblxuICBjb25jYXQoXG4gICAgcGFydHM6IFByZXNlbnRBcnJheTxBU1R2MS5UZXh0Tm9kZSB8IEFTVHYxLk11c3RhY2hlU3RhdGVtZW50PixcbiAgICBsb2M6IFNvdXJjZVNwYW5cbiAgKTogQVNUdjEuQ29uY2F0U3RhdGVtZW50IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0NvbmNhdFN0YXRlbWVudCcsXG4gICAgICBwYXJ0cyxcbiAgICAgIGxvYyxcbiAgICB9O1xuICB9XG5cbiAgZWxlbWVudCh7XG4gICAgdGFnLFxuICAgIHNlbGZDbG9zaW5nLFxuICAgIGF0dHJzLFxuICAgIGJsb2NrUGFyYW1zLFxuICAgIG1vZGlmaWVycyxcbiAgICBjb21tZW50cyxcbiAgICBjaGlsZHJlbixcbiAgICBsb2MsXG4gIH06IEJ1aWxkRWxlbWVudE9wdGlvbnMpOiBBU1R2MS5FbGVtZW50Tm9kZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdFbGVtZW50Tm9kZScsXG4gICAgICB0YWcsXG4gICAgICBzZWxmQ2xvc2luZzogc2VsZkNsb3NpbmcsXG4gICAgICBhdHRyaWJ1dGVzOiBhdHRycyB8fCBbXSxcbiAgICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyB8fCBbXSxcbiAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzIHx8IFtdLFxuICAgICAgY29tbWVudHM6IChjb21tZW50cyBhcyBBU1R2MS5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnRbXSkgfHwgW10sXG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4gfHwgW10sXG4gICAgICBsb2MsXG4gICAgfTtcbiAgfVxuXG4gIGVsZW1lbnRNb2RpZmllcih7XG4gICAgcGF0aCxcbiAgICBwYXJhbXMsXG4gICAgaGFzaCxcbiAgICBsb2MsXG4gIH06IHtcbiAgICBwYXRoOiBBU1R2MS5QYXRoRXhwcmVzc2lvbiB8IEFTVHYxLlN1YkV4cHJlc3Npb247XG4gICAgcGFyYW1zOiBBU1R2MS5FeHByZXNzaW9uW107XG4gICAgaGFzaDogQVNUdjEuSGFzaDtcbiAgICBsb2M6IFNvdXJjZVNwYW47XG4gIH0pOiBBU1R2MS5FbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnQge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50JyxcbiAgICAgIHBhdGgsXG4gICAgICBwYXJhbXMsXG4gICAgICBoYXNoLFxuICAgICAgbG9jLFxuICAgIH07XG4gIH1cblxuICBhdHRyKHtcbiAgICBuYW1lLFxuICAgIHZhbHVlLFxuICAgIGxvYyxcbiAgfToge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB2YWx1ZTogQVNUdjEuQXR0ck5vZGVbJ3ZhbHVlJ107XG4gICAgbG9jOiBTb3VyY2VTcGFuO1xuICB9KTogQVNUdjEuQXR0ck5vZGUge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnQXR0ck5vZGUnLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGxvYyxcbiAgICB9O1xuICB9XG5cbiAgdGV4dCh7IGNoYXJzLCBsb2MgfTogeyBjaGFyczogc3RyaW5nOyBsb2M6IFNvdXJjZVNwYW4gfSk6IEFTVHYxLlRleHROb2RlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ1RleHROb2RlJyxcbiAgICAgIGNoYXJzLFxuICAgICAgbG9jLFxuICAgIH07XG4gIH1cblxuICBzZXhwcih7XG4gICAgcGF0aCxcbiAgICBwYXJhbXMsXG4gICAgaGFzaCxcbiAgICBsb2MsXG4gIH06IHtcbiAgICBwYXRoOiBBU1R2MS5QYXRoRXhwcmVzc2lvbiB8IEFTVHYxLlN1YkV4cHJlc3Npb247XG4gICAgcGFyYW1zOiBBU1R2MS5FeHByZXNzaW9uW107XG4gICAgaGFzaDogQVNUdjEuSGFzaDtcbiAgICBsb2M6IFNvdXJjZVNwYW47XG4gIH0pOiBBU1R2MS5TdWJFeHByZXNzaW9uIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ1N1YkV4cHJlc3Npb24nLFxuICAgICAgcGF0aCxcbiAgICAgIHBhcmFtcyxcbiAgICAgIGhhc2gsXG4gICAgICBsb2MsXG4gICAgfTtcbiAgfVxuXG4gIHBhdGgoe1xuICAgIGhlYWQsXG4gICAgdGFpbCxcbiAgICBsb2MsXG4gIH06IHtcbiAgICBoZWFkOiBBU1R2MS5QYXRoSGVhZDtcbiAgICB0YWlsOiBzdHJpbmdbXTtcbiAgICBsb2M6IFNvdXJjZVNwYW47XG4gIH0pOiBBU1R2MS5QYXRoRXhwcmVzc2lvbiB7XG4gICAgbGV0IHsgb3JpZ2luYWw6IG9yaWdpbmFsSGVhZCB9ID0gaGVhZFRvU3RyaW5nKGhlYWQpO1xuICAgIGxldCBvcmlnaW5hbCA9IFsuLi5vcmlnaW5hbEhlYWQsIC4uLnRhaWxdLmpvaW4oJy4nKTtcblxuICAgIHJldHVybiBuZXcgUGF0aEV4cHJlc3Npb25JbXBsVjEob3JpZ2luYWwsIGhlYWQsIHRhaWwsIGxvYyk7XG4gIH1cblxuICBoZWFkKGhlYWQ6IHN0cmluZywgbG9jOiBTb3VyY2VTcGFuKTogQVNUdjEuUGF0aEhlYWQge1xuICAgIGlmIChoZWFkWzBdID09PSAnQCcpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0TmFtZShoZWFkLCBsb2MpO1xuICAgIH0gZWxzZSBpZiAoaGVhZCA9PT0gJ3RoaXMnKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGlzKGxvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnZhcihoZWFkLCBsb2MpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMobG9jOiBTb3VyY2VTcGFuKTogQVNUdjEuUGF0aEhlYWQge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnVGhpc0hlYWQnLFxuICAgICAgbG9jLFxuICAgIH07XG4gIH1cblxuICBhdE5hbWUobmFtZTogc3RyaW5nLCBsb2M6IFNvdXJjZVNwYW4pOiBBU1R2MS5QYXRoSGVhZCB7XG4gICAgLy8gdGhlIGBAYCBzaG91bGQgYmUgaW5jbHVkZWQgc28gd2UgaGF2ZSBhIGNvbXBsZXRlIHNvdXJjZSByYW5nZVxuICAgIGFzc2VydChuYW1lWzBdID09PSAnQCcsIGBjYWxsIGJ1aWxkZXJzLmF0KCkgd2l0aCBhIHN0cmluZyB0aGF0IHN0YXJ0cyB3aXRoICdAJ2ApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdBdEhlYWQnLFxuICAgICAgbmFtZSxcbiAgICAgIGxvYyxcbiAgICB9O1xuICB9XG5cbiAgdmFyKG5hbWU6IHN0cmluZywgbG9jOiBTb3VyY2VTcGFuKTogQVNUdjEuUGF0aEhlYWQge1xuICAgIGFzc2VydChuYW1lICE9PSAndGhpcycsIGBZb3UgY2FsbGVkIGJ1aWxkZXJzLnZhcigpIHdpdGggJ3RoaXMnLiBDYWxsIGJ1aWxkZXJzLnRoaXMgaW5zdGVhZGApO1xuICAgIGFzc2VydChcbiAgICAgIG5hbWVbMF0gIT09ICdAJyxcbiAgICAgIGBZb3UgY2FsbGVkIGJ1aWxkZXJzLnZhcigpIHdpdGggJyR7bmFtZX0nLiBDYWxsIGJ1aWxkZXJzLmF0KCcke25hbWV9JykgaW5zdGVhZGBcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdWYXJIZWFkJyxcbiAgICAgIG5hbWUsXG4gICAgICBsb2MsXG4gICAgfTtcbiAgfVxuXG4gIGhhc2gocGFpcnM6IEFTVHYxLkhhc2hQYWlyW10sIGxvYzogU291cmNlU3Bhbik6IEFTVHYxLkhhc2gge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnSGFzaCcsXG4gICAgICBwYWlyczogcGFpcnMgfHwgW10sXG4gICAgICBsb2MsXG4gICAgfTtcbiAgfVxuXG4gIHBhaXIoe1xuICAgIGtleSxcbiAgICB2YWx1ZSxcbiAgICBsb2MsXG4gIH06IHtcbiAgICBrZXk6IHN0cmluZztcbiAgICB2YWx1ZTogQVNUdjEuRXhwcmVzc2lvbjtcbiAgICBsb2M6IFNvdXJjZVNwYW47XG4gIH0pOiBBU1R2MS5IYXNoUGFpciB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdIYXNoUGFpcicsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHZhbHVlLFxuICAgICAgbG9jLFxuICAgIH07XG4gIH1cblxuICBsaXRlcmFsPFQgZXh0ZW5kcyBBU1R2MS5MaXRlcmFsPih7XG4gICAgdHlwZSxcbiAgICB2YWx1ZSxcbiAgICBsb2MsXG4gIH06IHtcbiAgICB0eXBlOiBUWyd0eXBlJ107XG4gICAgdmFsdWU6IFRbJ3ZhbHVlJ107XG4gICAgbG9jPzogU291cmNlTG9jYXRpb247XG4gIH0pOiBUIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZSxcbiAgICAgIHZhbHVlLFxuICAgICAgb3JpZ2luYWw6IHZhbHVlLFxuICAgICAgbG9jLFxuICAgIH0gYXMgVDtcbiAgfVxuXG4gIHVuZGVmaW5lZCgpOiBBU1R2MS5VbmRlZmluZWRMaXRlcmFsIHtcbiAgICByZXR1cm4gdGhpcy5saXRlcmFsKHsgdHlwZTogJ1VuZGVmaW5lZExpdGVyYWwnLCB2YWx1ZTogdW5kZWZpbmVkIH0pO1xuICB9XG5cbiAgbnVsbCgpOiBBU1R2MS5OdWxsTGl0ZXJhbCB7XG4gICAgcmV0dXJuIHRoaXMubGl0ZXJhbCh7IHR5cGU6ICdOdWxsTGl0ZXJhbCcsIHZhbHVlOiBudWxsIH0pO1xuICB9XG5cbiAgc3RyaW5nKHZhbHVlOiBzdHJpbmcsIGxvYzogU291cmNlU3Bhbik6IEFTVHYxLlN0cmluZ0xpdGVyYWwge1xuICAgIHJldHVybiB0aGlzLmxpdGVyYWwoeyB0eXBlOiAnU3RyaW5nTGl0ZXJhbCcsIHZhbHVlLCBsb2MgfSk7XG4gIH1cblxuICBib29sZWFuKHZhbHVlOiBib29sZWFuLCBsb2M6IFNvdXJjZVNwYW4pOiBBU1R2MS5Cb29sZWFuTGl0ZXJhbCB7XG4gICAgcmV0dXJuIHRoaXMubGl0ZXJhbCh7IHR5cGU6ICdCb29sZWFuTGl0ZXJhbCcsIHZhbHVlLCBsb2MgfSk7XG4gIH1cblxuICBudW1iZXIodmFsdWU6IG51bWJlciwgbG9jOiBTb3VyY2VTcGFuKTogQVNUdjEuTnVtYmVyTGl0ZXJhbCB7XG4gICAgcmV0dXJuIHRoaXMubGl0ZXJhbCh7IHR5cGU6ICdOdW1iZXJMaXRlcmFsJywgdmFsdWUsIGxvYyB9KTtcbiAgfVxufVxuXG4vLyBOb2Rlc1xuXG5leHBvcnQgdHlwZSBFbGVtZW50UGFydHMgPVxuICB8IFsnYXR0cnMnLCAuLi5BdHRyU2V4cFtdXVxuICB8IFsnbW9kaWZpZXJzJywgLi4uTW9kaWZpZXJTZXhwW11dXG4gIHwgWydib2R5JywgLi4uQVNUdjEuU3RhdGVtZW50W11dXG4gIHwgWydjb21tZW50cycsIC4uLkVsZW1lbnRDb21tZW50W11dXG4gIHwgWydhcycsIC4uLnN0cmluZ1tdXVxuICB8IFsnbG9jJywgU291cmNlTG9jYXRpb25dO1xuXG5leHBvcnQgdHlwZSBQYXRoU2V4cCA9IHN0cmluZyB8IFsncGF0aCcsIHN0cmluZywgTG9jU2V4cD9dO1xuXG5leHBvcnQgdHlwZSBNb2RpZmllclNleHAgPVxuICB8IHN0cmluZ1xuICB8IFtQYXRoU2V4cCwgTG9jU2V4cD9dXG4gIHwgW1BhdGhTZXhwLCBBU1R2MS5FeHByZXNzaW9uW10sIExvY1NleHA/XVxuICB8IFtQYXRoU2V4cCwgQVNUdjEuRXhwcmVzc2lvbltdLCBEaWN0PEFTVHYxLkV4cHJlc3Npb24+LCBMb2NTZXhwP107XG5cbmV4cG9ydCB0eXBlIEF0dHJTZXhwID0gW3N0cmluZywgQVNUdjEuQXR0ck5vZGVbJ3ZhbHVlJ10gfCBzdHJpbmcsIExvY1NleHA/XTtcblxuZXhwb3J0IHR5cGUgTG9jU2V4cCA9IFsnbG9jJywgU291cmNlTG9jYXRpb25dO1xuXG5leHBvcnQgdHlwZSBFbGVtZW50Q29tbWVudCA9IEFTVHYxLk11c3RhY2hlQ29tbWVudFN0YXRlbWVudCB8IFNvdXJjZUxvY2F0aW9uIHwgc3RyaW5nO1xuXG5leHBvcnQgdHlwZSBTZXhwVmFsdWUgPVxuICB8IHN0cmluZ1xuICB8IEFTVHYxLkV4cHJlc3Npb25bXVxuICB8IERpY3Q8QVNUdjEuRXhwcmVzc2lvbj5cbiAgfCBMb2NTZXhwXG4gIHwgUGF0aFNleHBcbiAgfCB1bmRlZmluZWQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnVpbGRFbGVtZW50T3B0aW9ucyB7XG4gIHRhZzogc3RyaW5nO1xuICBzZWxmQ2xvc2luZzogYm9vbGVhbjtcbiAgYXR0cnM6IEFTVHYxLkF0dHJOb2RlW107XG4gIG1vZGlmaWVyczogQVNUdjEuRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50W107XG4gIGNoaWxkcmVuOiBBU1R2MS5TdGF0ZW1lbnRbXTtcbiAgY29tbWVudHM6IEVsZW1lbnRDb21tZW50W107XG4gIGJsb2NrUGFyYW1zOiBzdHJpbmdbXTtcbiAgbG9jOiBTb3VyY2VTcGFuO1xufVxuXG4vLyBFeHByZXNzaW9uc1xuXG5mdW5jdGlvbiBoZWFkVG9TdHJpbmcoaGVhZDogQVNUdjEuUGF0aEhlYWQpOiB7IG9yaWdpbmFsOiBzdHJpbmc7IHBhcnRzOiBzdHJpbmdbXSB9IHtcbiAgc3dpdGNoIChoZWFkLnR5cGUpIHtcbiAgICBjYXNlICdBdEhlYWQnOlxuICAgICAgcmV0dXJuIHsgb3JpZ2luYWw6IGhlYWQubmFtZSwgcGFydHM6IFtoZWFkLm5hbWVdIH07XG4gICAgY2FzZSAnVGhpc0hlYWQnOlxuICAgICAgcmV0dXJuIHsgb3JpZ2luYWw6IGB0aGlzYCwgcGFydHM6IFtdIH07XG4gICAgY2FzZSAnVmFySGVhZCc6XG4gICAgICByZXR1cm4geyBvcmlnaW5hbDogaGVhZC5uYW1lLCBwYXJ0czogW2hlYWQubmFtZV0gfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgQnVpbGRlcnMoKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=