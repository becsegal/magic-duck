{"version":3,"file":"resolve-package-path.js","sourceRoot":"","sources":["../src/resolve-package-path.ts"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n// credit goes to https://github.com/davecombs\n// extracted in part from: https://github.com/stefanpenner/hash-for-dep/blob/15b2ebcf22024ceb2eb7907f8c412ae40f87b15e/lib/resolve-package-path.js#L1\n//\nimport fs = require('fs');\nimport path = require('path');\nimport pathRoot = require('path-root');\n\nimport Cache = require('./cache');\nimport CacheGroup = require('./cache-group');\nimport rethrowUnlessCode from './rethrow-unless-code';\n\n/*\n * Define a regex that will match against the 'name' value passed into\n * resolvePackagePath. The regex corresponds to the following test:\n *   Match any of the following 3 alternatives:\n *\n *  1) dot, then optional second dot, then / or nothing    i.e.  .  ./  ..  ../        OR\n *  2) /                                                   i.e.  /                     OR\n *  3) (A-Za-z colon - [optional]), then / or \\            i.e. optional drive letter + colon, then / or \\\n *\n * Basically, the three choices mean \"explicitly relative or absolute path, on either\n * Unix/Linux or Windows\"\n */\n\nconst ABSOLUTE_OR_RELATIVE_PATH_REGEX = /^(?:\\.\\.?(?:\\/|$)|\\/|([A-Za-z]:)?[/\\\\])/;\n\nimport shouldPreserveSymlinks = require('./should-preserve-symlinks');\nconst PRESERVE_SYMLINKS = shouldPreserveSymlinks(process);\n/*\n * Resolve the real path for a file. Return null if does not\n * exist or is not a file or FIFO, return the real path otherwise.\n *\n * Cache the result in the passed-in cache for performance,\n * keyed on the filePath passed in.\n *\n * NOTE: Because this is a private method, it does not attempt to normalize\n * the path passed in - it assumes the caller has done that.\n *\n * @private\n * @method _getRealFilePath\n * @param {Cache} realFilePathCache the Cache object to cache the real (resolved)\n * path in, keyed by filePath. See lib/cache.js and lib/cache-group.js\n * @param {String} filePath the path to the file of interest (which must have\n * been normalized, but not necessarily resolved to a real path).\n * @return {String} real path or null\n */\nfunction _getRealFilePath(realFilePathCache: Cache, filePath: string) {\n  if (realFilePathCache.has(filePath)) {\n    return realFilePathCache.get(filePath); // could be null\n  }\n\n  let realPath = null; // null = 'FILE NOT FOUND'\n\n  try {\n    const stat = fs.statSync(filePath);\n\n    // I don't know if Node would handle having the filePath actually\n    // be a FIFO, but as the following is also part of the node-resolution\n    // algorithm in resolve.sync(), we'll do the same check here.\n    if (stat.isFile() || stat.isFIFO()) {\n      if (PRESERVE_SYMLINKS) {\n        realPath = filePath;\n      } else {\n        realPath = fs.realpathSync(filePath);\n      }\n    }\n  } catch (e) {\n    rethrowUnlessCode(e, 'ENOENT');\n  }\n\n  realFilePathCache.set(filePath, realPath);\n\n  return realPath;\n}\n\n/*\n * Resolve the real path for a directory, return null if does not\n * exist or is not a directory, return the real path otherwise.\n *\n * @param {Cache} realDirectoryPathCache the Cache object to cache the real (resolved)\n * path in, keyed by directoryPath. See lib/cache.js and lib/cache-group.js\n * @param {String} directoryPath the path to the directory of interest (which must have\n * been normalized, but not necessarily resolved to a real path).\n * @return {String} real path or null\n */\nfunction _getRealDirectoryPath(realDirectoryPathCache: Cache, directoryPath: string) {\n  if (realDirectoryPathCache.has(directoryPath)) {\n    return realDirectoryPathCache.get(directoryPath); // could be null\n  }\n\n  let realPath = null;\n\n  try {\n    const stat = fs.statSync(directoryPath);\n\n    if (stat.isDirectory()) {\n      if (PRESERVE_SYMLINKS) {\n        realPath = directoryPath;\n      } else {\n        realPath = fs.realpathSync(directoryPath);\n      }\n    }\n  } catch (e) {\n    rethrowUnlessCode(e, 'ENOENT', 'ENOTDIR');\n  }\n\n  realDirectoryPathCache.set(directoryPath, realPath);\n\n  return realPath;\n}\n\n/*\n * Given a package 'name' and starting directory, resolve to a real (existing) file path.\n *\n * Do it similar to how it is done in resolve.sync() - travel up the directory hierarchy,\n * attaching 'node-modules' to each directory and seeing if the directory exists and\n * has the relevant 'package.json' file we're searching for. It is *much* faster than\n * resolve.sync(), because we don't test that the requested name is a directory.\n * This routine assumes that it is only called when we don't already have\n * the cached entry.\n *\n * NOTE: it is valid for 'name' to be an absolute or relative path.\n * Because this is an internal routine, we'll require that 'dir' be non-empty\n * if this is called, to make things simpler (see resolvePackagePath).\n *\n * @param realFilePathCache the cache containing the real paths corresponding to\n *   various file and directory paths (which may or may not be already resolved).\n *\n * @param name the 'name' of the module, i.e. x in require(x), but with\n *   '/package.json' on the end. It is NOT referring to a directory (so we don't\n *   have to do the directory checks that resolve.sync does).\n *   NOTE: because this is an internal routine, for speed it does not check\n *   that '/package.json' is actually the end of the name.\n *\n * @param dir the directory (MUST BE non-empty, and valid) to start from, appending the name to the\n *   directory and checking that the file exists. Go up the directory hierarchy from there.\n *   if name is itself an absolute path,\n *\n * @result the path to the actual package.json file that's found, or null if not.\n */\nfunction _findPackagePath(realFilePathCache: Cache, name: string, dir: string) {\n  const fsRoot = pathRoot(dir);\n  let currPath = dir;\n\n  while (currPath !== fsRoot) {\n    // when testing for 'node_modules', need to allow names like NODE_MODULES,\n    // which can occur with case-insensitive OSes.\n    let endsWithNodeModules = path.basename(currPath).toLowerCase() === 'node_modules';\n\n    let filePath = path.join(currPath, endsWithNodeModules ? '' : 'node_modules', name);\n\n    let realPath = _getRealFilePath(realFilePathCache, filePath);\n\n    if (realPath) {\n      return realPath;\n    }\n\n    if (endsWithNodeModules) {\n      // go up past the ending node_modules directory so the next dirname\n      // goes up past that (if ending in node_modules, going up just one\n      // directory below will then add 'node_modules' on the next loop and\n      // re-process this same node_modules directory.\n      currPath = path.dirname(currPath);\n    }\n\n    currPath = path.dirname(currPath);\n  }\n\n  return null;\n}\n\n/*\n * Resolve the path to the nearest `package.json` from the given initial search\n * directory.\n *\n * @param  {Cache} findUpCache - a cache of memoized results that is\n * prioritized to avoid I/O.\n *\n * @param {string} initialSearchDir - the normalized path to start searching\n * from.\n *\n * @return {string | null} - the deepest directory on the path to root from\n * `initialSearchDir` that contains a {{package.json}}, or `null` if no such\n * directory exists.\n */\nfunction _findUpPackagePath(findUpCache: Cache, initialSearchDir: string) {\n  let previous;\n  let dir = initialSearchDir;\n  let maybePackageJsonPath;\n  let result = null;\n\n  do {\n    if (findUpCache.has(dir)) {\n      result = findUpCache.get(dir);\n      break;\n    }\n\n    maybePackageJsonPath = path.join(dir, 'package.json');\n    if (fs.existsSync(maybePackageJsonPath)) {\n      result = maybePackageJsonPath;\n      break;\n    }\n\n    previous = dir;\n    dir = path.dirname(dir);\n  } while (dir !== previous);\n\n  findUpCache.set(initialSearchDir, result);\n\n  return result;\n}\n\n/*\n * Resolve the path to a module's package.json file, if it exists. The\n * name and dir are as in hashForDep and ModuleEntry.locate.\n *\n *  @param caches an instance of CacheGroup where information will be cached\n *  during processing.\n *\n *  @param name the 'name' of the module.  The name may also be a path,\n *  either relative or absolute. The path must be to a module DIRECTORY, NOT to the\n *  package.json file in the directory, as we attach 'package.json' here.\n *\n *  @param dir (optional) the root directory to run the path resolution from.\n *  if dir is not provided, __dirname for this module is used instead.\n *\n *  @return the realPath corresponding to the module's package.json file, or null\n *  if that file is not found or is not a file.\n *\n * Note: 'name' is expected in the format expected for require(x), i.e., it is\n * resolved using the Node path-normalization rules.\n */\nfunction resolvePackagePath(caches: CacheGroup, name?: string, dir?: string) {\n  if (typeof name !== 'string' || name.length === 0) {\n    throw new TypeError(\"resolvePackagePath: 'name' must be a non-zero-length string.\");\n  }\n\n  // Perform tests similar to those in resolve.sync().\n  let basedir = dir || __dirname;\n\n  // Ensure that basedir is an absolute path at this point. If it does not refer to\n  // a real directory, go up the path until a real directory is found, or return an error.\n\n  // BUG!: this will never throw an exception, at least on Unix/Linux. If the path is\n  // relative, path.resolve() will make it absolute by putting the current directory\n  // before it, so it won't fail. If the path is already absolute, / will always be\n  // valid, so again it won't fail.\n  let absoluteStart = path.resolve(basedir);\n\n  while (_getRealDirectoryPath(caches.REAL_DIRECTORY_PATH, absoluteStart) === null) {\n    absoluteStart = path.dirname(absoluteStart);\n  }\n\n  if (!absoluteStart) {\n    let error = new TypeError(\n      \"resolvePackagePath: 'dir' or one of the parent directories in its path must refer to a valid directory.\",\n    );\n    (error as any).code = 'MODULE_NOT_FOUND';\n    throw error;\n  }\n\n  if (ABSOLUTE_OR_RELATIVE_PATH_REGEX.test(name)) {\n    let res = path.resolve(absoluteStart, name);\n    return _getRealFilePath(caches.REAL_FILE_PATH, path.join(res, 'package.json'));\n\n    // XXX Do we need to handle the core(x) case too? Not sure.\n  } else {\n    return _findPackagePath(caches.REAL_FILE_PATH, path.join(name, 'package.json'), absoluteStart);\n  }\n}\n\nexport = resolvePackagePath;\nresolvePackagePath._findPackagePath = _findPackagePath;\nresolvePackagePath._findUpPackagePath = _findUpPackagePath;\nresolvePackagePath._getRealFilePath = _getRealFilePath;\nresolvePackagePath._getRealDirectoryPath = _getRealDirectoryPath;\n"]}