{"version":3,"file":"analyzer-plugin.js","sourceRoot":"","sources":["../ts/analyzer-plugin.ts"],"names":[],"mappings":";AAEA,uDAA4D;AAU5D,6EAA6E;AAC7E,UAAU;AACV,2CAA2C;AAC3C,uCAAuC;AACvC,MAAM,iBAAiB,GAA2C,IAAI,GAAG,CAAC;IACxE,MAAM;IACN,QAAQ;CACT,CAAC,CAAC;AACH,2CAA2C;AAC3C,uCAAuC;AACvC,MAAM,iBAAiB,GAAgD,IAAI,GAAG,CAAC;IAC7E,MAAM;CACP,CAAC,CAAC;AAGH,SAAS,cAAc,CAAC,KAAmB;IACzC,IAAI,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC;IACpB,OAAO;QACL,OAAO,EAAE;YACP,OAAO,EAAE;gBACP,KAAK,CAAC,KAA0B,EAAE,KAAY;oBAC5C,KAAK,CAAC,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC,OAAO,IAAI,EAAE,CAAC;oBACzC,KAAK,CAAC,OAAO,GAAG,IAAI,OAAO,EAAE,CAAC;gBAChC,CAAC;gBACD,IAAI,CAAC,IAAyB,EAAE,KAAY;oBAC1C,oEAAoE;oBACpE,oEAAoE;oBACpE,mDAAmD;oBACnD,IAAI,IAAI,GAAG,CAAC,CAAC,mBAAmB,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;oBACtD,CAAC,CAAC,UAAU,CAAC,IAAI,EAAE,UAAU,EAAE,2BAAS,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC,CAAC;oBAC/D,IAAI,CAAC,gBAAgB,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;gBACtC,CAAC;aACF;YACD,cAAc,CAAC,IAAgC,EAAE,KAAY;gBAC3D,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;oBAChC,4DAA4D;oBAC5D,qEAAqE;oBACrE,oEAAoE;oBACpE,sEAAsE;oBACtE,kEAAkE;oBAClE,oBAAoB;oBACpB,OAAO;iBACR;gBACD,IAAI,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;gBAChC,IAAI,MAAM,CAAC,IAAI,KAAK,QAAQ,EAAE;oBAC5B,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,2BAA2B,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;oBAC5D,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAC9B;qBAAM,IACL,MAAM,CAAC,YAAY,EAAE;oBACrB,MAAM,CAAC,gBAAgB,CAAC,mBAAmB,EAAE,YAAY,CAAC,EAC1D;oBACA,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,2BAA2B,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;oBAC7D,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAC9B;YACH,CAAC;YACD,iBAAiB,CAAC,IAAmC,EAAE,KAAY;gBACjE,IAAI,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC;oBAAE,OAAO;gBACxD,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC;oBACjB,SAAS,EAAE,KAAK;oBAChB,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK;iBAClC,CAAC,CAAC;YACL,CAAC;YACD,sBAAsB,CACpB,IAAwC,EACxC,KAAY;gBAEZ,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM;oBAAE,OAAO;gBAC9B,IAAI,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC;oBAAE,OAAO;gBACxD,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC;oBACjB,SAAS,EAAE,KAAK;oBAChB,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK;iBAClC,CAAC,CAAC;YACL,CAAC;YACD,oBAAoB,CAClB,IAAsC,EACtC,KAAY;gBAEZ,IAAI,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC;oBAAE,OAAO;gBACxD,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC;oBACjB,SAAS,EAAE,KAAK;oBAChB,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK;iBAClC,CAAC,CAAC;YACL,CAAC;SACF;KACF,CAAC;AACJ,CAAC;AAED,SAAS,2BAA2B,CAClC,IAAgC,EAChC,SAAkB;IAElB,8DAA8D;IAC9D,8CAA8C;IAC9C,IAAI,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;IAEtC,QAAQ,QAAQ,CAAC,IAAI,EAAE;QACrB,KAAK,eAAe;YAClB,OAAO;gBACL,SAAS;gBACT,SAAS,EAAE,QAAQ,CAAC,KAAK;aAC1B,CAAC;QACJ,KAAK,iBAAiB;YACpB,IAAI,QAAQ,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;gBAChC,OAAO;oBACL,SAAS;oBACT,SAAS,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,MAAO;iBAC5C,CAAC;aACH;iBAAM;gBACL,OAAO;oBACL,SAAS;oBACT,YAAY,EAAE,QAAQ,CAAC,MAAM,CAAC,GAAG,CAC/B,CAAC,eAAe,EAAE,EAAE,CAAC,eAAe,CAAC,KAAK,CAAC,MAAO,CACnD;oBACD,mBAAmB,EAAE,CAAC,GAAG,QAAQ,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,aAAa,CAAC;iBAClE,CAAC;aACH;QACH;YACE,MAAM,IAAI,CAAC,mBAAmB,CAC5B,iFAAiF,CAClF,CAAC;KACL;AACH,CAAC;AAED,SAAS,aAAa,CAAC,GAA4B;IACjD,IAAI,GAAG,CAAC,IAAI,KAAK,YAAY,EAAE;QAC7B,OAAO,GAAG,CAAC,IAAI,CAAC;KACjB;SAAM;QACL,OAAO,IAAI,CAAC;KACb;AACH,CAAC;AAnHD,iBAAS,cAAc,CAAC","sourcesContent":["import type { types as t, NodePath } from '@babel/core';\nimport type * as Babel from '@babel/core';\nimport { ImportSyntax, serialize } from './analyzer-syntax';\n\ninterface State {\n  imports: ImportSyntax[];\n  handled: WeakSet<t.CallExpression>;\n  opts: {\n    imports?: ImportSyntax[];\n  };\n}\n\n// Ignores type-only imports & exports, which are erased from the final build\n// output.\n// TypeScript: `import type foo from 'foo'`\n// Flow: `import typeof foo from 'foo'`\nconst erasedImportKinds: Set<t.ImportDeclaration['importKind']> = new Set([\n  'type',\n  'typeof',\n]);\n// TypeScript: `export type foo from 'foo'`\n// Flow: doesn't have type-only exports\nconst erasedExportKinds: Set<t.ExportNamedDeclaration['exportKind']> = new Set([\n  'type',\n]);\n\nexport = analyzerPlugin;\nfunction analyzerPlugin(babel: typeof Babel) {\n  let t = babel.types;\n  return {\n    visitor: {\n      Program: {\n        enter(_path: NodePath<t.Program>, state: State) {\n          state.imports = state.opts.imports || [];\n          state.handled = new WeakSet();\n        },\n        exit(path: NodePath<t.Program>, state: State) {\n          // instead of attaching our comment metadata to an existing node, we\n          // add our own tiny harmless node. Otherwise, further processing may\n          // drop the node we put our comment on and lose it.\n          let meta = t.expressionStatement(t.numericLiteral(0));\n          t.addComment(meta, 'trailing', serialize(state.imports), true);\n          path.unshiftContainer('body', meta);\n        },\n      },\n      CallExpression(path: NodePath<t.CallExpression>, state: State) {\n        if (state.handled.has(path.node)) {\n          // We see the same CallExpression multiple times if it has a\n          // TemplateLiteral argument and another plugin or preset is rewriting\n          // TemplateLiterals to something else. We need to guard against that\n          // because the first time is fine and we capture our analysis, but the\n          // second time would cause us to throw an exception when we see an\n          // illegal argument.\n          return;\n        }\n        let callee = path.get('callee');\n        if (callee.type === 'Import') {\n          state.imports.push(processImportCallExpression(path, true));\n          state.handled.add(path.node);\n        } else if (\n          callee.isIdentifier() &&\n          callee.referencesImport('@embroider/macros', 'importSync')\n        ) {\n          state.imports.push(processImportCallExpression(path, false));\n          state.handled.add(path.node);\n        }\n      },\n      ImportDeclaration(path: NodePath<t.ImportDeclaration>, state: State) {\n        if (erasedImportKinds.has(path.node.importKind)) return;\n        state.imports.push({\n          isDynamic: false,\n          specifier: path.node.source.value,\n        });\n      },\n      ExportNamedDeclaration(\n        path: NodePath<t.ExportNamedDeclaration>,\n        state: State\n      ) {\n        if (!path.node.source) return;\n        if (erasedExportKinds.has(path.node.exportKind)) return;\n        state.imports.push({\n          isDynamic: false,\n          specifier: path.node.source.value,\n        });\n      },\n      ExportAllDeclaration(\n        path: NodePath<t.ExportAllDeclaration>,\n        state: State\n      ) {\n        if (erasedExportKinds.has(path.node.exportKind)) return;\n        state.imports.push({\n          isDynamic: false,\n          specifier: path.node.source.value,\n        });\n      },\n    },\n  };\n}\n\nfunction processImportCallExpression(\n  path: NodePath<t.CallExpression>,\n  isDynamic: boolean\n): ImportSyntax {\n  // it's a syntax error to have anything other than exactly one\n  // argument, so we can just assume this exists\n  let argument = path.node.arguments[0];\n\n  switch (argument.type) {\n    case 'StringLiteral':\n      return {\n        isDynamic,\n        specifier: argument.value,\n      };\n    case 'TemplateLiteral':\n      if (argument.quasis.length === 1) {\n        return {\n          isDynamic,\n          specifier: argument.quasis[0].value.cooked!,\n        };\n      } else {\n        return {\n          isDynamic,\n          cookedQuasis: argument.quasis.map(\n            (templateElement) => templateElement.value.cooked!\n          ),\n          expressionNameHints: [...argument.expressions].map(inferNameHint),\n        };\n      }\n    default:\n      throw path.buildCodeFrameError(\n        'import() is only allowed to contain string literals or template string literals'\n      );\n  }\n}\n\nfunction inferNameHint(exp: t.Expression | t.TSType) {\n  if (exp.type === 'Identifier') {\n    return exp.name;\n  } else {\n    return null;\n  }\n}\n"]}