{"version":3,"file":"analyzer-syntax.js","sourceRoot":"","sources":["../ts/analyzer-syntax.ts"],"names":[],"mappings":"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","sourcesContent":["import { ReadStream } from 'fs';\n\nexport interface LiteralImportSyntax {\n  isDynamic: boolean;\n  specifier: string;\n}\n\nexport interface TemplateImportSyntax {\n  isDynamic: boolean;\n  // these are the string parts of the template literal. The first one always\n  // comes before the first expression.\n  cookedQuasis: string[];\n  // for each of the expressions in between the cookedQuasis, this is an\n  // optional hint for what to name the expression that goes there. It's\n  // optional because in general there may not be an obvious name, but in\n  // practice there often is, and we can aid debuggability by using names that\n  // match the original code.\n  expressionNameHints: (string | null)[];\n}\n\nexport type ImportSyntax = LiteralImportSyntax | TemplateImportSyntax;\n\n// this should change if we ever change the implementation of the\n// serialize/deserialize below, so that babel caches will be invalidated.\n//\n// this needs to have enough entropy that is it unlikely to collide with\n// anything that appears earlier than it in the JS modules.\nexport const MARKER = 'eaimeta@70e063a35619d71f';\n\nexport function serialize(imports: ImportSyntax[]): string {\n  let tokens = [];\n  for (let imp of imports) {\n    if ('specifier' in imp) {\n      tokens.push(imp.isDynamic ? 1 : 0);\n      tokens.push(imp.specifier);\n    } else {\n      tokens.push(imp.isDynamic ? 3 : 2);\n      tokens.push(imp.cookedQuasis);\n      tokens.push(imp.expressionNameHints);\n    }\n  }\n  return `${MARKER}${JSON.stringify(tokens).slice(1, -1)}${MARKER}`;\n}\n\nexport function deserialize(source: ReadStream): Promise<ImportSyntax[]> {\n  let deserializer = new Deserializer(source);\n  return deserializer.output;\n}\n\nclass Deserializer {\n  private state:\n    | {\n        // we're looking for the start marker\n        type: 'finding-start';\n      }\n    | {\n        type: 'start-partial-match';\n        // how many codepoints of the marker were present at the end of the\n        // previous chunk (to handle a marker that splits across chunks)\n        partialMatch: number;\n      }\n    | {\n        // we're looking for the end marker\n        type: 'finding-end';\n        // the meta we've read so far\n        meta: string[];\n      }\n    | {\n        type: 'end-partial-match';\n        // the meta we've read so far\n        meta: string[];\n        // how many codepoints of the marker were present at the end of the\n        // previous chunk (to handle a marker that splits across chunks)\n        partialMatch: number;\n      }\n    | {\n        type: 'done-reading';\n        meta: string;\n      }\n    | {\n        type: 'finished';\n      } = {\n    type: 'finding-start',\n  };\n\n  output: Promise<ImportSyntax[]>;\n  private resolve: (result: ImportSyntax[]) => void;\n  private reject: (err: any) => void;\n\n  constructor(private source: ReadStream) {\n    let r: (result: ImportSyntax[]) => void, e: (err: any) => void;\n    this.output = new Promise<ImportSyntax[]>((resolve, reject) => {\n      r = resolve;\n      e = reject;\n    });\n    this.resolve = r!;\n    this.reject = e!;\n    source.on('readable', this.run.bind(this));\n    source.on('error', this.reject);\n    source.on('close', this.finish.bind(this));\n  }\n\n  // keeps consuming chunks until we read null (meaning no buffered data\n  // available) or the state machine decides to stop\n  private run() {\n    let chunk: string | null;\n    // setting the read size bigger than the marker length is important. We can\n    // deal with a marker split between two chunks, but not three or more.\n    while (null !== (chunk = this.source.read(1024))) {\n      this.consumeChunk(chunk);\n      if (this.state.type === 'done-reading') {\n        this.finish();\n        break;\n      }\n    }\n  }\n\n  private consumeChunk(chunk: string): void {\n    let { state } = this;\n    switch (state.type) {\n      case 'finding-start':\n        {\n          let start = chunk.indexOf(MARKER);\n          if (start >= 0) {\n            // found the start, enter finding-end state\n            this.state = {\n              type: 'finding-end',\n              meta: [],\n            };\n            // pass the rest of the chunk forward to the next state\n            return this.consumeChunk(chunk.slice(start + MARKER.length));\n          }\n          let partialMatch = matchesAtEnd(chunk, MARKER);\n          if (partialMatch > 0) {\n            this.state = {\n              type: 'start-partial-match',\n              partialMatch,\n            };\n          }\n        }\n        break;\n      case 'start-partial-match':\n        if (chunk.startsWith(MARKER.slice(state.partialMatch))) {\n          // completed partial match, go into finding-end state\n          this.state = {\n            type: 'finding-end',\n            meta: [],\n          };\n          return this.consumeChunk(\n            chunk.slice(MARKER.length - state.partialMatch)\n          );\n        } else {\n          // partial match failed to complete\n          this.state = {\n            type: 'finding-start',\n          };\n          return this.consumeChunk(chunk);\n        }\n      case 'finding-end': {\n        let endIndex = chunk.indexOf(MARKER);\n        if (endIndex >= 0) {\n          // found the end\n          this.state = {\n            type: 'done-reading',\n            meta: [...state.meta, chunk.slice(0, endIndex)].join(''),\n          };\n        } else {\n          let partialMatch = matchesAtEnd(chunk, MARKER);\n          if (partialMatch > 0) {\n            this.state = {\n              type: 'end-partial-match',\n              meta: [...state.meta, chunk.slice(0, -partialMatch)],\n              partialMatch,\n            };\n          } else {\n            state.meta.push(chunk);\n          }\n        }\n        break;\n      }\n      case 'end-partial-match':\n        if (chunk.startsWith(MARKER.slice(state.partialMatch))) {\n          // completed partial match, go into finding-end state\n          this.state = {\n            type: 'done-reading',\n            meta: state.meta.join(''),\n          };\n        } else {\n          // partial match failed to complete, so we need to replace the partial\n          // marker match we stripped off the last chunk\n          this.state = {\n            type: 'finding-end',\n            meta: [...state.meta, MARKER.slice(0, state.partialMatch)],\n          };\n          return this.consumeChunk(chunk);\n        }\n        break;\n      case 'done-reading':\n      case 'finished':\n        throw new Error(`bug: tried to consume more chunks when already done`);\n      default:\n        throw assertNever(state);\n    }\n  }\n\n  private convertTokens(meta: string) {\n    let tokens = JSON.parse('[' + meta + ']');\n    let syntax: ImportSyntax[] = [];\n    while (tokens.length > 0) {\n      let type = tokens.shift();\n      switch (type) {\n        case 0:\n          syntax.push({\n            isDynamic: false,\n            specifier: tokens.shift(),\n          });\n          break;\n        case 1:\n          syntax.push({\n            isDynamic: true,\n            specifier: tokens.shift(),\n          });\n          break;\n        case 2:\n          syntax.push({\n            isDynamic: false,\n            cookedQuasis: tokens.shift(),\n            expressionNameHints: tokens.shift(),\n          });\n          break;\n        case 3:\n          syntax.push({\n            isDynamic: true,\n            cookedQuasis: tokens.shift(),\n            expressionNameHints: tokens.shift(),\n          });\n          break;\n      }\n    }\n    return syntax;\n  }\n\n  private finish() {\n    if (this.state.type === 'finished') {\n      return;\n    }\n    let syntax: ImportSyntax[];\n    if (this.state.type === 'done-reading') {\n      syntax = this.convertTokens(this.state.meta);\n    } else {\n      syntax = [];\n    }\n    this.state = { type: 'finished' };\n    this.resolve(syntax);\n    this.source.destroy();\n  }\n}\n\nfunction assertNever(value: never) {\n  throw new Error(`bug: never should happen ${value}`);\n}\n\nfunction matchesAtEnd(chunk: string, marker: string): number {\n  while (marker.length > 0) {\n    if (chunk.endsWith(marker)) {\n      return marker.length;\n    }\n    marker = marker.slice(0, -1);\n  }\n  return 0;\n}\n"]}