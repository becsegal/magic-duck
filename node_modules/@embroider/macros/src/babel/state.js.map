{"version":3,"file":"state.js","sourceRoot":"","sources":["state.ts"],"names":[],"mappings":";;;;;;AACA,yEAAiD;AACjD,iEAA+C;AAC/C,+BAA8C;AAC9C,kEAAsF;AACtF,yDAA+C;AA8C/C,SAAgB,SAAS,CAAC,CAAqB,EAAE,IAAmC,EAAE,KAAY;IAChG,KAAK,CAAC,UAAU,GAAG,IAAI,8BAAU,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;IAC3C,KAAK,CAAC,iBAAiB,GAAG,IAAI,GAAG,EAAE,CAAC;IACpC,KAAK,CAAC,IAAI,GAAG,EAAE,CAAC;IAChB,KAAK,CAAC,OAAO,GAAG,IAAI,GAAG,EAAE,CAAC;IAC1B,KAAK,CAAC,iBAAiB,GAAG,IAAI,GAAG,EAAE,CAAC;IACpC,KAAK,CAAC,YAAY,GAAG,+BAAY,CAAC,MAAM,CAAC,kBAAkB,EAAE,KAAK,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;IACxF,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC,iBAAiB,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC;IAC/E,KAAK,CAAC,cAAc,GAAG,WAAW,CAAC;IACnC,KAAK,CAAC,aAAa,GAAG,aAAa,CAAC;IACpC,KAAK,CAAC,SAAS,GAAG,SAAS,CAAC;AAC9B,CAAC;AAXD,8BAWC;AAED,MAAM,gBAAgB,GAAG,IAAA,cAAO,EAAC,IAAA,WAAI,EAAC,SAAS,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC;AAEjE,SAAS,WAAW,CAAc,UAAkB;IAClD,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE;QAChC,kEAAkE;QAClE,OAAO,IAAA,mCAAgB,EAAC,IAAA,cAAO,EAAC,IAAI,CAAC,UAAU,CAAC,EAAE,IAAA,WAAI,EAAC,gBAAgB,EAAE,UAAU,CAAC,CAAC,CAAC;KACvF;SAAM;QACL,sEAAsE;QACtE,aAAa;QACb,EAAE;QACF,qEAAqE;QACrE,yEAAyE;QACzE,4EAA4E;QAC5E,0EAA0E;QAC1E,eAAe;QACf,OAAO,qBAAqB,UAAU,EAAE,CAAC;KAC1C;AACH,CAAC;AAED,SAAS,aAAa;IACpB,IAAI,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IACzD,IAAI,CAAC,GAAG,EAAE;QACR,MAAM,IAAI,KAAK,CAAC,uDAAuD,IAAI,CAAC,UAAU,EAAE,CAAC,CAAC;KAC3F;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAED,SAAS,SAAS,CAAc,IAAU;IACxC,IAAI,KAAK,GAAG,IAAI,CAAC;IACjB,OAAO,IAAA,uBAAa,EAAC,IAAI,EAAE,UAAU,KAAU;QAC7C,IAAI,KAAK,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;YACtC,IAAI,MAAM,GAAG,IAAA,mBAAe,EAAC,KAAK,CAAC,CAAC;YACpC,KAAK,CAAC,iBAAiB,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;YACpC,OAAO,MAAM,CAAC;SACf;IACH,CAAC,CAAC,CAAC;AACL,CAAC","sourcesContent":["import type { NodePath, Node } from '@babel/traverse';\nimport cloneDeepWith from 'lodash/cloneDeepWith';\nimport lodashCloneDeep from 'lodash/cloneDeep';\nimport { join, dirname, resolve } from 'path';\nimport { explicitRelative, Package, PackageCache } from '@embroider/shared-internals';\nimport { ImportUtil } from 'babel-import-util';\nimport type * as Babel from '@babel/core';\n\nexport default interface State {\n  importUtil: ImportUtil;\n  generatedRequires: Set<Node>;\n  removed: Set<Node>;\n  calledIdentifiers: Set<Node>;\n  jobs: (() => void)[];\n  packageCache: PackageCache;\n  sourceFile: string;\n  pathToOurAddon(moduleName: string): string;\n  owningPackage(): Package;\n  cloneDeep(node: Node): Node;\n\n  opts: {\n    userConfigs: {\n      [pkgRoot: string]: unknown;\n    };\n    globalConfig: {\n      [key: string]: unknown;\n    };\n    // we set this when we're running inside classic ember-cli, because in that\n    // case we don't have finer-grained info available about where the files\n    // we're processing are globally located. When running in embroider, we\n    // don't set this, because each file is visible at its full\n    // globally-relevant path.\n    owningPackageRoot: string | undefined;\n\n    // list of packages that are under active development, represented by the\n    // path to their package root directory\n    isDevelopingPackageRoots: string[];\n\n    // the package root directory of the app. Needed so that we can get\n    // consistent answers to `isDevelopingApp` and `isDeveopingThisPackage`, as\n    // well as consistent handling of Package devDependencies vs dependencies.\n    appPackageRoot: string;\n\n    embroiderMacrosConfigMarker: true;\n\n    mode: 'compile-time' | 'run-time';\n\n    importSyncImplementation: 'cjs' | 'eager';\n  };\n}\n\nexport function initState(t: typeof Babel.types, path: NodePath<Babel.types.Program>, state: State) {\n  state.importUtil = new ImportUtil(t, path);\n  state.generatedRequires = new Set();\n  state.jobs = [];\n  state.removed = new Set();\n  state.calledIdentifiers = new Set();\n  state.packageCache = PackageCache.shared('embroider-stage3', state.opts.appPackageRoot);\n  state.sourceFile = state.opts.owningPackageRoot || path.hub.file.opts.filename;\n  state.pathToOurAddon = pathToAddon;\n  state.owningPackage = owningPackage;\n  state.cloneDeep = cloneDeep;\n}\n\nconst runtimeAddonPath = resolve(join(__dirname, '..', 'addon'));\n\nfunction pathToAddon(this: State, moduleName: string): string {\n  if (!this.opts.owningPackageRoot) {\n    // running inside embroider, so make a relative path to the module\n    return explicitRelative(dirname(this.sourceFile), join(runtimeAddonPath, moduleName));\n  } else {\n    // running inside a classic build, so use a classic-compatible runtime\n    // specifier.\n    //\n    // CAUTION: the module we're pointing at here gets merged between all\n    // present versions of @embroider/macros, and one will win. So if you are\n    // introducing incompatible changes to its API, you need to change this name\n    // (by tacking on a version number, etc) and rename the corresponding file\n    // in ../addon.\n    return `@embroider/macros/${moduleName}`;\n  }\n}\n\nfunction owningPackage(this: State): Package {\n  let pkg = this.packageCache.ownerOfFile(this.sourceFile);\n  if (!pkg) {\n    throw new Error(`unable to determine which npm package owns the file ${this.sourceFile}`);\n  }\n  return pkg;\n}\n\nfunction cloneDeep(this: State, node: Node): Node {\n  let state = this;\n  return cloneDeepWith(node, function (value: any) {\n    if (state.generatedRequires.has(value)) {\n      let cloned = lodashCloneDeep(value);\n      state.generatedRequires.add(cloned);\n      return cloned;\n    }\n  });\n}\n"]}