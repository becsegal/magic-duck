{"version":3,"file":"fail-build.js","sourceRoot":"","sources":["fail-build.ts"],"names":[],"mappings":";;;;;AACA,mDAA6D;AAE7D,oDAA4B;AAC5B,+BAA8B;AAG9B,SAAwB,SAAS,CAAC,IAAgC,EAAE,KAAY;IAC9E,IAAI,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;IACjC,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;QACnB,MAAM,IAAA,eAAK,EAAC,IAAI,EAAE,uCAAuC,CAAC,CAAC;KAC5D;IAED,IAAI,CAAC,GAAG,IAAI,yBAAS,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC;IAEjC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE;QACnB,IAAI,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;QAC7C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACzC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS,EAAE;gBAC3B,MAAM,IAAA,eAAK,EAAC,IAAI,CAAC,CAAC,CAAC,EAAE,qDAAqD,CAAC,CAAC;aAC7E;SACF;QACD,IAAI,kBAAkB,GAAG,SAA8B,CAAC;QAExD,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE;YAC5B,cAAc,CAAC,IAAI,EAAE,kBAAkB,CAAC,CAAC;SAC1C;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AArBD,4BAqBC;AAED,SAAS,cAAc,CAAC,IAAgC,EAAE,SAA2B;IACnF,IAAI,CAAC,OAAO,EAAE,GAAG,IAAI,CAAC,GAAG,SAAS,CAAC;IACnC,MAAM,IAAA,eAAK,EAAC,IAAI,EAAE,IAAA,aAAM,EAAC,cAAc,OAAO,CAAC,KAAK,EAAE,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AACtF,CAAC;AAED,SAAS,UAAU,CAAC,IAAc,EAAE,KAAY;IAC9C,OAAO,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAClG,CAAC","sourcesContent":["import type { NodePath } from '@babel/traverse';\nimport { Evaluator, ConfidentResult } from './evaluate-json';\nimport type { types as t } from '@babel/core';\nimport error from './error';\nimport { format } from 'util';\nimport State from './state';\n\nexport default function failBuild(path: NodePath<t.CallExpression>, state: State) {\n  let args = path.get('arguments');\n  if (args.length < 1) {\n    throw error(path, `failBuild needs at least one argument`);\n  }\n\n  let e = new Evaluator({ state });\n\n  state.jobs.push(() => {\n    let argValues = args.map(a => e.evaluate(a));\n    for (let i = 0; i < argValues.length; i++) {\n      if (!argValues[i].confident) {\n        throw error(args[i], `the arguments to failBuild must be statically known`);\n      }\n    }\n    let confidentArgValues = argValues as ConfidentResult[];\n\n    if (!wasRemoved(path, state)) {\n      maybeEmitError(path, confidentArgValues);\n    }\n  });\n}\n\nfunction maybeEmitError(path: NodePath<t.CallExpression>, argValues: { value: any }[]) {\n  let [message, ...rest] = argValues;\n  throw error(path, format(`failBuild: ${message.value}`, ...rest.map(r => r.value)));\n}\n\nfunction wasRemoved(path: NodePath, state: State) {\n  return state.removed.has(path.node) || Boolean(path.findParent(p => state.removed.has(p.node)));\n}\n"]}