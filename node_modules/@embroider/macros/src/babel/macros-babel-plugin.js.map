{"version":3,"file":"macros-babel-plugin.js","sourceRoot":"","sources":["macros-babel-plugin.ts"],"names":[],"mappings":"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","sourcesContent":["import type { NodePath } from '@babel/traverse';\nimport type { types as t } from '@babel/core';\nimport { PackageCache } from '@embroider/shared-internals';\nimport State, { initState } from './state';\nimport { inlineRuntimeConfig, insertConfig, Mode as GetConfigMode } from './get-config';\nimport macroCondition, { isMacroConditionPath } from './macro-condition';\nimport { isEachPath, insertEach } from './each';\n\nimport error from './error';\nimport failBuild from './fail-build';\nimport { Evaluator, buildLiterals } from './evaluate-json';\nimport type * as Babel from '@babel/core';\n\nexport default function main(context: typeof Babel): unknown {\n  let t = context.types;\n  let visitor = {\n    Program: {\n      enter(path: NodePath<t.Program>, state: State) {\n        initState(t, path, state);\n\n        state.packageCache = PackageCache.shared('embroider-stage3', state.opts.appPackageRoot);\n      },\n      exit(_: NodePath<t.Program>, state: State) {\n        // @embroider/macros itself has no runtime behaviors and should always be removed\n        state.importUtil.removeAllImports('@embroider/macros');\n        for (let handler of state.jobs) {\n          handler();\n        }\n      },\n    },\n    'IfStatement|ConditionalExpression': {\n      enter(path: NodePath<t.IfStatement | t.ConditionalExpression>, state: State) {\n        if (isMacroConditionPath(path)) {\n          state.calledIdentifiers.add(path.get('test').get('callee').node);\n          macroCondition(path, state);\n        }\n      },\n    },\n    ForOfStatement: {\n      enter(path: NodePath<t.ForOfStatement>, state: State) {\n        if (isEachPath(path)) {\n          state.calledIdentifiers.add(path.get('right').get('callee').node);\n          insertEach(path, state, context);\n        }\n      },\n    },\n    FunctionDeclaration: {\n      enter(path: NodePath<t.FunctionDeclaration>, state: State) {\n        let id = path.get('id');\n        if (id.isIdentifier() && id.node.name === 'initializeRuntimeMacrosConfig' && state.opts.mode === 'run-time') {\n          let pkg = state.owningPackage();\n          if (pkg && pkg.name === '@embroider/macros') {\n            inlineRuntimeConfig(path, state, context);\n          }\n        }\n      },\n    },\n    CallExpression: {\n      enter(path: NodePath<t.CallExpression>, state: State) {\n        let callee = path.get('callee');\n        if (!callee.isIdentifier()) {\n          return;\n        }\n\n        // failBuild is implemented for side-effect, not value, so it's not\n        // handled by evaluateMacroCall.\n        if (callee.referencesImport('@embroider/macros', 'failBuild')) {\n          state.calledIdentifiers.add(callee.node);\n          failBuild(path, state);\n          return;\n        }\n\n        if (callee.referencesImport('@embroider/macros', 'importSync')) {\n          // we handle importSync in the exit hook\n          return;\n        }\n\n        // getOwnConfig/getGlobalConfig/getConfig needs special handling, so\n        // even though it also emits values via evaluateMacroCall when they're\n        // needed recursively by other macros, it has its own insertion-handling\n        // code that we invoke here.\n        //\n        // The things that are special include:\n        //  - automatic collapsing of chained properties, etc\n        //  - these macros have runtime implementations sometimes, which changes\n        //    how we rewrite them\n        let mode: GetConfigMode | false = callee.referencesImport('@embroider/macros', 'getOwnConfig')\n          ? 'own'\n          : callee.referencesImport('@embroider/macros', 'getGlobalConfig')\n          ? 'getGlobalConfig'\n          : callee.referencesImport('@embroider/macros', 'getConfig')\n          ? 'package'\n          : false;\n        if (mode) {\n          state.calledIdentifiers.add(callee.node);\n          insertConfig(path, state, mode, context);\n          return;\n        }\n\n        // isTesting can have a runtime implementation. At compile time it\n        // instead falls through to evaluateMacroCall.\n        if (callee.referencesImport('@embroider/macros', 'isTesting') && state.opts.mode === 'run-time') {\n          state.calledIdentifiers.add(callee.node);\n          callee.replaceWith(state.importUtil.import(callee, state.pathToOurAddon('runtime'), 'isTesting'));\n          return;\n        }\n\n        let result = new Evaluator({ state }).evaluateMacroCall(path);\n        if (result.confident) {\n          state.calledIdentifiers.add(callee.node);\n          path.replaceWith(buildLiterals(result.value, context));\n        }\n      },\n      exit(path: NodePath<t.CallExpression>, state: State) {\n        let callee = path.get('callee');\n        if (!callee.isIdentifier()) {\n          return;\n        }\n        // importSync doesn't evaluate to a static value, so it's implemented\n        // directly here, not in evaluateMacroCall.\n        // We intentionally do this on exit here, to allow other transforms to handle importSync before we do\n        // For example ember-auto-import needs to do some custom transforms to enable use of dynamic template strings,\n        // so its babel plugin needs to see and handle the importSync call first!\n        if (callee.referencesImport('@embroider/macros', 'importSync')) {\n          if (state.opts.importSyncImplementation === 'eager') {\n            let specifier = path.node.arguments[0];\n            if (specifier?.type !== 'StringLiteral') {\n              throw new Error(`importSync eager mode doesn't implement non string literal arguments yet`);\n            }\n            path.replaceWith(state.importUtil.import(path, specifier.value, '*'));\n            state.calledIdentifiers.add(callee.node);\n          } else {\n            if (path.scope.hasBinding('require')) {\n              path.scope.rename('require');\n            }\n            let r = t.identifier('require');\n            state.generatedRequires.add(r);\n            path.replaceWith(\n              t.callExpression(state.importUtil.import(path, state.pathToOurAddon('es-compat'), 'default', 'esc'), [\n                t.callExpression(r, path.node.arguments),\n              ])\n            );\n          }\n          return;\n        }\n      },\n    },\n    ReferencedIdentifier(path: NodePath<t.Identifier>, state: State) {\n      for (let candidate of [\n        'dependencySatisfies',\n        'moduleExists',\n        'getConfig',\n        'getOwnConfig',\n        'failBuild',\n        // we cannot check importSync, as the babel transform runs on exit, so *after* this check\n        // 'importSync',\n        'isDevelopingApp',\n        'isDevelopingThisPackage',\n        'isTesting',\n      ]) {\n        if (path.referencesImport('@embroider/macros', candidate) && !state.calledIdentifiers.has(path.node)) {\n          throw error(path, `You can only use ${candidate} as a function call`);\n        }\n      }\n\n      if (path.referencesImport('@embroider/macros', 'macroCondition') && !state.calledIdentifiers.has(path.node)) {\n        throw error(path, `macroCondition can only be used as the predicate of an if statement or ternary expression`);\n      }\n\n      if (path.referencesImport('@embroider/macros', 'each') && !state.calledIdentifiers.has(path.node)) {\n        throw error(\n          path,\n          `the each() macro can only be used within a for ... of statement, like: for (let x of each(thing)){}`\n        );\n      }\n\n      if (state.opts.owningPackageRoot) {\n        // there is only an owningPackageRoot when we are running inside a\n        // classic ember-cli build. In the embroider stage3 build, there is no\n        // owning package root because we're compiling *all* packages\n        // simultaneously.\n        //\n        // given that we're inside classic ember-cli, stop here without trying\n        // to rewrite bare `require`. It's not needed, because both our\n        // `importSync` and any user-written bare `require` can both mean the\n        // same thing: runtime AMD `require`.\n        return;\n      }\n\n      if (\n        state.opts.importSyncImplementation === 'cjs' &&\n        path.node.name === 'require' &&\n        !state.generatedRequires.has(path.node) &&\n        !path.scope.hasBinding('require') &&\n        state.owningPackage().isEmberPackage()\n      ) {\n        // Our importSync macro has been compiled to `require`. But we want to\n        // distinguish that from any pre-existing, user-written `require` in an\n        // Ember addon, which should retain its *runtime* meaning.\n        path.replaceWith(t.memberExpression(t.identifier('window'), path.node));\n      }\n    },\n  };\n\n  if ((context as any).types.OptionalMemberExpression) {\n    // our getConfig and getOwnConfig macros are supposed to be able to absorb\n    // optional chaining. To make that work we need to see the optional chaining\n    // before preset-env compiles them away.\n    (visitor as any).OptionalMemberExpression = {\n      enter(path: NodePath<t.OptionalMemberExpression>, state: State) {\n        if (state.opts.mode === 'compile-time') {\n          let result = new Evaluator({ state }).evaluate(path);\n          if (result.confident) {\n            path.replaceWith(buildLiterals(result.value, context));\n          }\n        }\n      },\n    };\n  }\n\n  return { visitor };\n}\n"]}