{"version":3,"file":"get-config.js","sourceRoot":"","sources":["get-config.ts"],"names":[],"mappings":"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","sourcesContent":["import type { NodePath } from '@babel/traverse';\nimport State from './state';\nimport { PackageCache, Package } from '@embroider/shared-internals';\nimport error from './error';\nimport { Evaluator, assertArray, buildLiterals, ConfidentResult } from './evaluate-json';\nimport assertNever from 'assert-never';\nimport type * as Babel from '@babel/core';\nimport type { types as t } from '@babel/core';\n\nexport type Mode = 'own' | 'getGlobalConfig' | 'package';\n\nfunction getPackage(path: NodePath<t.CallExpression>, state: State, mode: 'own' | 'package'): { root: string } | null {\n  let packageName: string | undefined;\n  if (mode === 'own') {\n    if (path.node.arguments.length !== 0) {\n      throw error(path, `getOwnConfig takes zero arguments, you passed ${path.node.arguments.length}`);\n    }\n    packageName = undefined;\n  } else if (mode === 'package') {\n    if (path.node.arguments.length !== 1) {\n      throw error(path, `getConfig takes exactly one argument, you passed ${path.node.arguments.length}`);\n    }\n    let packageNode = path.node.arguments[0];\n    if (packageNode.type !== 'StringLiteral') {\n      throw error(assertArray(path.get('arguments'))[0], `the argument to getConfig must be a string literal`);\n    }\n    packageName = packageNode.value;\n  } else {\n    assertNever(mode);\n  }\n  return targetPackage(state.sourceFile, packageName, state.packageCache);\n}\n\n// this evaluates to the actual value of the config. It can be used directly by the Evaluator.\nexport default function getConfig(path: NodePath<t.CallExpression>, state: State, mode: Mode) {\n  let config: unknown | undefined;\n  if (mode === 'getGlobalConfig') {\n    return state.opts.globalConfig;\n  }\n  let pkg = getPackage(path, state, mode);\n  if (pkg) {\n    config = state.opts.userConfigs[pkg.root];\n  }\n  return config;\n}\n\n// this is the imperative version that's invoked directly by the babel visitor\n// when we encounter getConfig. It's implemented in terms of getConfig so we can\n// be sure we have the same semantics.\nexport function insertConfig(path: NodePath<t.CallExpression>, state: State, mode: Mode, context: typeof Babel) {\n  if (state.opts.mode === 'compile-time') {\n    let config = getConfig(path, state, mode);\n    let collapsed = collapse(path, config);\n    let literalResult = buildLiterals(collapsed.config, context);\n    collapsed.path.replaceWith(literalResult);\n  } else {\n    if (mode === 'getGlobalConfig') {\n      let callee = path.get('callee');\n      callee.replaceWith(state.importUtil.import(callee, state.pathToOurAddon('runtime'), 'getGlobalConfig'));\n    } else {\n      let pkg = getPackage(path, state, mode);\n      let pkgRoot;\n      if (pkg) {\n        pkgRoot = context.types.stringLiteral(pkg.root);\n      } else {\n        pkgRoot = context.types.identifier('undefined');\n      }\n      path.replaceWith(\n        context.types.callExpression(state.importUtil.import(path, state.pathToOurAddon('runtime'), 'config'), [\n          pkgRoot,\n        ])\n      );\n    }\n  }\n}\n\nfunction targetPackage(fromPath: string, packageName: string | undefined, packageCache: PackageCache): Package | null {\n  let us = packageCache.ownerOfFile(fromPath);\n  if (!us) {\n    throw new Error(`unable to determine which npm package owns the file ${fromPath}`);\n  }\n  if (!packageName) {\n    return us;\n  }\n  try {\n    return packageCache.resolve(packageName, us);\n  } catch (err) {\n    return null;\n  }\n}\n\nfunction collapse(path: NodePath, config: any) {\n  let evaluator = new Evaluator({ knownPaths: new Map([[path, { confident: true, value: config }]]) });\n\n  while (true) {\n    let parentPath = path.parentPath;\n    let result = evaluator.evaluate(parentPath);\n    if (!result.confident || parentPath.isAssignmentExpression()) {\n      return { path, config: (evaluator.evaluate(path) as ConfidentResult).value };\n    }\n    path = parentPath;\n  }\n}\n\nexport function inlineRuntimeConfig(path: NodePath<t.FunctionDeclaration>, state: State, context: typeof Babel) {\n  path.get('body').node.body = [\n    context.types.returnStatement(\n      buildLiterals({ packages: state.opts.userConfigs, global: state.opts.globalConfig }, context)\n    ),\n  ];\n}\n"]}