{"version":3,"file":"macro-condition.js","sourceRoot":"","sources":["macro-condition.ts"],"names":[],"mappings":";;;;;;AAAA,0DAAkC;AAElC,SAAgB,YAAY,CAAC,IAAS;IACpC,IAAI,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAE/B,IAAI,CAAC,SAAS,IAAI,SAAS,CAAC,IAAI,KAAK,eAAe,IAAI,SAAS,CAAC,IAAI,CAAC,QAAQ,KAAK,gBAAgB,EAAE;QACpG,OAAO,IAAI,CAAC;KACb;IAED,IAAI,SAAS,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;QACjC,MAAM,IAAI,KAAK,CAAC,qDAAqD,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;KAC5F;IAED,IAAI,MAAM,GAAG,IAAA,kBAAQ,EAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3C,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE;QACrB,MAAM,IAAI,KAAK,CAAC,0DAA0D,CAAC,CAAC;KAC7E;IAED,IAAI,MAAM,CAAC,KAAK,EAAE;QAChB,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;KAC1B;SAAM;QACL,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;SAC1B;aAAM;YACL,OAAO,EAAE,CAAC;SACX;KACF;AACH,CAAC;AAzBD,oCAyBC;AAED,SAAgB,iBAAiB,CAAC,IAAS,EAAE,QAAa;IACxD,IAAI,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAE/B,IAAI,CAAC,SAAS,IAAI,SAAS,CAAC,IAAI,KAAK,eAAe,IAAI,SAAS,CAAC,IAAI,CAAC,QAAQ,KAAK,gBAAgB,EAAE;QACpG,OAAO,IAAI,CAAC;KACb;IAED,IAAI,SAAS,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;QACjC,MAAM,IAAI,KAAK,CAAC,qDAAqD,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;KAC5F;IAED,IAAI,MAAM,GAAG,IAAA,kBAAQ,EAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3C,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE;QACrB,MAAM,IAAI,KAAK,CAAC,0DAA0D,CAAC,CAAC;KAC7E;IAED,IAAI,MAAM,CAAC,KAAK,EAAE;QAChB,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;KACvB;SAAM;QACL,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,SAAS,EAAE,CAAC;KAC/C;AACH,CAAC;AArBD,8CAqBC;AAED,SAAgB,eAAe,CAAC,IAAS,EAAE,QAAa;IACtD,IAAI,MAAM,GAAG,iBAAiB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IAE/C,IAAI,MAAM,KAAK,IAAI,EAAE;QACnB,OAAO,IAAI,CAAC;KACb;IAED,IAAI,MAAM,CAAC,IAAI,KAAK,eAAe,EAAE;QACnC,OAAO,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC;KACnE;IAED,OAAO,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;AACnC,CAAC;AAZD,0CAYC","sourcesContent":["import evaluate from './evaluate';\n\nexport function macroIfBlock(node: any) {\n  let condition = node.params[0];\n\n  if (!condition || condition.type !== 'SubExpression' || condition.path.original !== 'macroCondition') {\n    return node;\n  }\n\n  if (condition.params.length !== 1) {\n    throw new Error(`macroCondition requires one arguments, you passed ${node.params.length}`);\n  }\n\n  let result = evaluate(condition.params[0]);\n  if (!result.confident) {\n    throw new Error(`argument to macroCondition must be statically analyzable`);\n  }\n\n  if (result.value) {\n    return node.program.body;\n  } else {\n    if (node.inverse) {\n      return node.inverse.body;\n    } else {\n      return [];\n    }\n  }\n}\n\nexport function macroIfExpression(node: any, builders: any) {\n  let condition = node.params[0];\n\n  if (!condition || condition.type !== 'SubExpression' || condition.path.original !== 'macroCondition') {\n    return node;\n  }\n\n  if (condition.params.length !== 1) {\n    throw new Error(`macroCondition requires one arguments, you passed ${node.params.length}`);\n  }\n\n  let result = evaluate(condition.params[0]);\n  if (!result.confident) {\n    throw new Error(`argument to macroCondition must be statically analyzable`);\n  }\n\n  if (result.value) {\n    return node.params[1];\n  } else {\n    return node.params[2] || builders.undefined();\n  }\n}\n\nexport function macroIfMustache(node: any, builders: any) {\n  let result = macroIfExpression(node, builders);\n\n  if (result === node) {\n    return node;\n  }\n\n  if (result.type === 'SubExpression') {\n    return builders.mustache(result.path, result.params, result.hash);\n  }\n\n  return builders.mustache(result);\n}\n"]}