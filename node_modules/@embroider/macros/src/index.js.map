{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":";AAAA,2BAA2B;;;AAE3B;;;;;;;;;;;;;;EAcE;AAEF,SAAgB,mBAAmB,CAAC,WAAmB,EAAE,WAAmB;IAC1E,MAAM,IAAI,IAAI,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;AAC3C,CAAC;AAFD,kDAEC;AAED,SAAgB,cAAc,CAAC,SAAkB;IAC/C,MAAM,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC;AAC5B,CAAC;AAFD,wCAEC;AAED,SAAgB,IAAI,CAAI,KAAU;IAChC,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC;AACxB,CAAC;AAFD,oBAEC;AAED,4BAA4B;AAC5B,mFAAmF;AACnF,kDAAkD;AAClD,SAAgB,UAAU,CAAC,SAAiB;IAC1C,MAAM,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC;AAC5B,CAAC;AAFD,gCAEC;AAED,SAAgB,SAAS,CAAI,WAAmB;IAC9C,MAAM,IAAI,IAAI,CAAC,WAAW,CAAC,CAAC;AAC9B,CAAC;AAFD,8BAEC;AAED,SAAgB,YAAY;IAC1B,MAAM,IAAI,IAAI,EAAE,CAAC;AACnB,CAAC;AAFD,oCAEC;AAED,SAAgB,eAAe;IAC7B,MAAM,IAAI,IAAI,EAAE,CAAC;AACnB,CAAC;AAFD,0CAEC;AAED,SAAgB,eAAe;IAC7B,MAAM,IAAI,IAAI,EAAE,CAAC;AACnB,CAAC;AAFD,0CAEC;AAED,SAAgB,SAAS;IACvB,MAAM,IAAI,IAAI,EAAE,CAAC;AACnB,CAAC;AAFD,8BAEC;AAED,SAAgB,SAAS,CAAC,OAAe;IACvC,MAAM,IAAI,IAAI,CAAC,OAAO,CAAC,CAAC;AAC1B,CAAC;AAFD,8BAEC;AAED,SAAgB,YAAY,CAAC,WAAmB;IAC9C,MAAM,IAAI,IAAI,CAAC,WAAW,CAAC,CAAC;AAC9B,CAAC;AAFD,oCAEC;AAED,MAAM,IAAK,SAAQ,KAAK;IAEtB,YAAY,GAAG,MAAa;QAC1B,KAAK,CACH,6HAA6H,CAC9H,CAAC;QACF,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;CACF","sourcesContent":["/* Macro Type Signatures */\n\n/*\n  CAUTION: this code is not necessarily what you are actually running. In\n  general, the macros are implemented at build time using babel, and so calls to\n  these functions get compiled away before they ever run. However, this code is\n  here because it provides types to typescript users of the macros.\n\n  Some macros also have runtime implementations that are useful in development\n  mode, in addition to their build-time implementations in babel. You can find\n  the runtime implementations in runtime.ts.\n\n  Having a runtime mode lets us do things like produce a single build in\n  development that works for both fastboot and browser, using the macros to\n  switch between modes. For production, you would switch to the build-time macro\n  implementation to get two optimized builds instead.\n*/\n\nexport function dependencySatisfies(packageName: string, semverRange: string): boolean {\n  throw new Oops(packageName, semverRange);\n}\n\nexport function macroCondition(predicate: boolean): boolean {\n  throw new Oops(predicate);\n}\n\nexport function each<T>(array: T[]): T[] {\n  throw new Oops(array);\n}\n\n// We would prefer to write:\n//   export function importSync<T extends string>(specifier: T): typeof import(T) {\n// but TS doesn't seem to support that at present.\nexport function importSync(specifier: string): unknown {\n  throw new Oops(specifier);\n}\n\nexport function getConfig<T>(packageName: string): T {\n  throw new Oops(packageName);\n}\n\nexport function getOwnConfig<T>(): T {\n  throw new Oops();\n}\n\nexport function getGlobalConfig<T>(): T {\n  throw new Oops();\n}\n\nexport function isDevelopingApp(): boolean {\n  throw new Oops();\n}\n\nexport function isTesting(): boolean {\n  throw new Oops();\n}\n\nexport function failBuild(message: string): void {\n  throw new Oops(message);\n}\n\nexport function moduleExists(packageName: string): boolean {\n  throw new Oops(packageName);\n}\n\nclass Oops extends Error {\n  params: any[];\n  constructor(...params: any[]) {\n    super(\n      `this method is really implemented at compile time via a babel plugin. If you're seeing this exception, something went wrong`\n    );\n    this.params = params;\n  }\n}\n"]}