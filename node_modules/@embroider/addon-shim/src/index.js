"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addonV1Shim = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const shared_internals_1 = require("@embroider/shared-internals");
const broccoli_funnel_1 = __importDefault(require("broccoli-funnel"));
const semver_1 = require("semver");
function addonMeta(pkgJSON) {
    let meta = pkgJSON['ember-addon'];
    if ((meta === null || meta === void 0 ? void 0 : meta.version) !== 2 || (meta === null || meta === void 0 ? void 0 : meta.type) !== 'addon') {
        throw new Error(`did not find valid v2 addon metadata in ${pkgJSON.name}`);
    }
    return meta;
}
function addonV1Shim(directory, options = {}) {
    let pkg = JSON.parse((0, fs_1.readFileSync)((0, path_1.resolve)(directory, './package.json'), 'utf8'));
    let meta = addonMeta(pkg);
    let disabled = false;
    const rootTrees = new WeakMap();
    function rootTree(addonInstance) {
        let tree = rootTrees.get(addonInstance);
        if (!tree) {
            tree = addonInstance.treeGenerator(directory);
            rootTrees.set(addonInstance, tree);
        }
        return tree;
    }
    let autoImportInstance;
    return {
        name: pkg.name,
        included(...args) {
            var _a, _b;
            let parentOptions;
            let parentName;
            if ((0, shared_internals_1.isDeepAddonInstance)(this)) {
                parentOptions = this.parent.options;
                parentName = this.parent.name;
            }
            else {
                parentOptions = this.app.options;
                parentName = this.parent.name();
            }
            // if we're being used by a v1 package, that package needs ember-auto-import 2
            if (((_b = (_a = this.parent.pkg['ember-addon']) === null || _a === void 0 ? void 0 : _a.version) !== null && _b !== void 0 ? _b : 1) < 2) {
                let autoImport = locateAutoImport(this.parent.addons);
                if (!autoImport.present) {
                    throw new Error(`${parentName} needs to depend on ember-auto-import in order to use ${this.name}`);
                }
                if (!autoImport.satisfiesV2) {
                    throw new Error(`${parentName} has ember-auto-import ${autoImport.version} which is not new enough to use ${this.name}. It needs to upgrade to >=2.0`);
                }
                autoImportInstance = autoImport.instance;
                autoImportInstance.registerV2Addon(this.name, directory);
            }
            else {
                // if we're being used by a v2 addon, it also has this shim and will
                // forward our registration onward to ember-auto-import
                this.parent.registerV2Addon(this.name, directory);
            }
            if (options.disabled) {
                disabled = options.disabled(parentOptions);
            }
            // this is at the end so we can find our own autoImportInstance before any
            // deeper v2 addons ask us to forward registrations upward to it
            this._super.included.apply(this, args);
        },
        treeForApp() {
            if (disabled) {
                return undefined;
            }
            let maybeAppJS = meta['app-js'];
            if (maybeAppJS) {
                const appJS = maybeAppJS;
                return (0, broccoli_funnel_1.default)(rootTree(this), {
                    files: Object.values(appJS),
                    getDestinationPath(relativePath) {
                        for (let [exteriorName, interiorName] of Object.entries(appJS)) {
                            if (relativePath === interiorName) {
                                return exteriorName;
                            }
                        }
                        throw new Error(`bug in addonV1Shim, no match for ${relativePath} in ${JSON.stringify(appJS)}`);
                    },
                });
            }
        },
        treeForAddon() {
            // this never goes through broccoli -- it's always pulled into the app via
            // ember-auto-import, as needed. This means it always benefits from
            // tree-shaking.
            return undefined;
        },
        treeForPublic() {
            if (disabled) {
                return undefined;
            }
            let maybeAssets = meta['public-assets'];
            if (maybeAssets) {
                const assets = maybeAssets;
                return (0, broccoli_funnel_1.default)(rootTree(this), {
                    files: Object.keys(assets),
                    getDestinationPath(relativePath) {
                        for (let [interiorName, exteriorName] of Object.entries(assets)) {
                            if (relativePath === interiorName) {
                                return exteriorName;
                            }
                        }
                        throw new Error(`bug in addonV1Shim, no match for ${relativePath} in ${JSON.stringify(assets)}`);
                    },
                });
            }
        },
        cacheKeyForTree(treeType) {
            return `embroider-addon-shim/${treeType}/${directory}`;
        },
        isDevelopingAddon() {
            // if the app is inside our own directory, we must be under development.
            // This setting controls whether ember-cli will watch for changes in the
            // broccoli trees we expose, but it doesn't have any control over our
            // files that get auto-imported into the app. For that, you should use
            // ember-auto-import's watchDependencies option (and this should become
            // part of the blueprint for test apps).
            let appInstance = this._findHost();
            return isInside(directory, appInstance.project.root);
        },
        registerV2Addon(name, root) {
            autoImportInstance.registerV2Addon(name, root);
        },
    };
}
exports.addonV1Shim = addonV1Shim;
function isInside(parentDir, otherDir) {
    let rel = (0, path_1.relative)(parentDir, otherDir);
    return Boolean(rel) && !rel.startsWith('..') && !(0, path_1.isAbsolute)(rel);
}
function locateAutoImport(addons) {
    let instance = addons.find((a) => a.name === 'ember-auto-import');
    if (!instance) {
        return { present: false };
    }
    let version = instance.pkg.version;
    let satisfiesV2 = (0, semver_1.satisfies)(version, '>=2.0.0-alpha.0', {
        includePrerelease: true,
    });
    if (satisfiesV2) {
        return {
            present: true,
            version,
            satisfiesV2,
            instance: instance,
        };
    }
    else {
        return {
            present: true,
            version,
            satisfiesV2,
        };
    }
}
//# sourceMappingURL=index.js.map