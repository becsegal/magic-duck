{"version":3,"file":"ember-standard-modules.js","sourceRoot":"","sources":["ember-standard-modules.ts"],"names":[],"mappings":";;;;;;AAAA,8EAA8E;AAC9E,8EAA8E;AAC9E,+CAA+C;AAC/C,EAAE;AACF,aAAa;AACb,oFAAuD;AAEvD,gFAAgF;AAChF,2EAA2E;AAC3E,8CAA8C;AAC9C,EAAE;AACF,+EAA+E;AAC/E,4CAA4C;AAC5C,EAAE;AACF,+EAA+E;AAC/E,6EAA6E;AAC7E,kDAAkD;AACrC,QAAA,oBAAoB,GAAG,IAAI,GAAG,CAAS,uBAAQ,CAAC,GAAG,CAAC,CAAC,CAAM,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;AAExF,gFAAgF;AAChF,6EAA6E;AAC7E,+EAA+E;AAC/E,4EAA4E;AAC5E,gFAAgF;AAChF,8EAA8E;AAC9E,gCAAgC;AACnB,QAAA,oBAAoB,GAAG,IAAI,GAAG,CAAS,CAAC,oBAAoB,EAAE,mBAAmB,CAAC,CAAC,CAAC;AAEjG,kEAAkE;AAClE,4BAAoB,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC;AAC7C,4BAAoB,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;AAE1C,6EAA6E;AAC7E,8EAA8E;AAC9E,qDAAqD;AACrD,4BAAoB,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;AACzC,4BAAoB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;AAClC,4BAAoB,CAAC,GAAG,CAAC,mBAAmB,CAAC,CAAC;AAE9C,8EAA8E;AAC9E,eAAe;AACF,QAAA,0BAA0B,GAAG,MAAM,CAAC,MAAM,CAAC;IACtD,EAAE,MAAM,EAAE,4BAA4B,EAAE,YAAY,EAAE,SAAS,EAAE;IACjE,EAAE,MAAM,EAAE,sCAAsC,EAAE,YAAY,EAAE,SAAS,EAAE;IAC3E,EAAE,MAAM,EAAE,oBAAoB,EAAE,YAAY,EAAE,KAAK,EAAE;IACrD,EAAE,MAAM,EAAE,gCAAgC,EAAE,YAAY,EAAE,oBAAoB,EAAE;CACjF,CAAC,CAAC","sourcesContent":["// I'm doing this as a json import because even though that's not standard JS,\n// it's relaively easy to consume into builds for the web. As opposed to doing\n// something like fs.readFile, which is harder.\n//\n// @ts-ignore\nimport mappings from 'ember-rfc176-data/mappings.json';\n\n// these are packages that available to import in standard ember code that don't\n// exist as real packages. If a build system encounters them in stage 3, it\n// should convert them to runtime AMD require.\n//\n// Some of them (like @embroider/macros) won't ever be seen in stage 3, because\n// earlier plugins should take care of them.\n//\n// In embroider builds using ember-source >= 3.28, you won't see *any* of these\n// in stage3 because ember-source uses the standard rename-modules feature to\n// map them into real modules within ember-source.\nexport const emberVirtualPackages = new Set<string>(mappings.map((m: any) => m.module));\n\n// these are *real* packages that every ember addon is allowed to resolve *as if\n// they were peerDepenedencies, because the host application promises to have\n// these packages. In principle, we could force every addon to declare these as\n// real peerDeps all the way down the dependency graph, but in practice that\n// makes the migration from v1 to v2 addons more painful than necessary, because\n// a v1 addon in between the app and a v2 addon might not declare the peerDep,\n// breaking the deeper v2 addon.\nexport const emberVirtualPeerDeps = new Set<string>(['@glimmer/component', '@glimmer/tracking']);\n\n// this is a real package, even though it's still listed in rfc176\nemberVirtualPackages.delete('@ember/string');\nemberVirtualPeerDeps.add('@ember/string');\n\n// these can also appear in ember code and should get compiled away by babel,\n// but we may need to tell a build tool that is inspecting pre-transpiled code\n// (like snowpack) not to worrya bout these packages.\nemberVirtualPackages.add('@glimmer/env');\nemberVirtualPackages.add('ember');\nemberVirtualPackages.add('@embroider/macros');\n\n// These are the known names that people use to import template precomiplation\n// macros from.\nexport const templateCompilationModules = Object.freeze([\n  { module: 'htmlbars-inline-precompile', exportedName: 'default' },\n  { module: 'ember-cli-htmlbars-inline-precompile', exportedName: 'default' },\n  { module: 'ember-cli-htmlbars', exportedName: 'hbs' },\n  { module: '@ember/template-precompilation', exportedName: 'precompileTemplate' },\n]);\n"]}