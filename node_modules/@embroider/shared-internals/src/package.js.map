{"version":3,"file":"package.js","sourceRoot":"","sources":["package.ts"],"names":[],"mappings":"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","sourcesContent":["import { Memoize } from 'typescript-memoize';\nimport { readFileSync, existsSync } from 'fs-extra';\nimport { join, extname } from 'path';\nimport get from 'lodash/get';\nimport { AddonMeta, AppMeta, PackageInfo } from './metadata';\nimport PackageCache from './package-cache';\nimport flatMap from 'lodash/flatMap';\nexport default class Package {\n  private dependencyKeys: ('dependencies' | 'devDependencies' | 'peerDependencies')[];\n\n  constructor(readonly root: string, protected packageCache: PackageCache, isApp: boolean) {\n    this.dependencyKeys = isApp\n      ? ['dependencies', 'devDependencies', 'peerDependencies']\n      : ['dependencies', 'peerDependencies'];\n  }\n\n  get name(): string {\n    return this.packageJSON.name;\n  }\n\n  get version(): string {\n    return this.packageJSON.version;\n  }\n\n  @Memoize()\n  protected get internalPackageJSON() {\n    return JSON.parse(readFileSync(join(this.root, 'package.json'), 'utf8'));\n  }\n\n  @Memoize()\n  get packageJSON(): PackageInfo {\n    let json = this.internalPackageJSON;\n    if (this.nonResolvableDeps) {\n      if (!json.dependencies) {\n        json.dependencies = {};\n      }\n      for (let dep of this.nonResolvableDeps.values()) {\n        json.dependencies[dep.name] = dep.version || '*';\n      }\n    }\n    return json;\n  }\n\n  get meta(): AddonMeta | AppMeta | undefined {\n    let m = this.packageJSON['ember-addon'];\n    if (this.isV2App()) {\n      return m as unknown as AppMeta;\n    }\n    if (this.isV2Addon()) {\n      return m as AddonMeta;\n    }\n  }\n\n  isEmberPackage(): boolean {\n    let keywords = this.packageJSON.keywords;\n    return Boolean(keywords && (keywords as string[]).includes('ember-addon'));\n  }\n\n  isEngine(): boolean {\n    let keywords = this.packageJSON.keywords;\n    return Boolean(keywords && (keywords as string[]).includes('ember-engine'));\n  }\n\n  isLazyEngine(): boolean {\n    return this.isEngine() && get(this.packageJSON, 'ember-addon.lazy-engine');\n  }\n\n  isV2Ember(): this is V2Package {\n    return this.isEmberPackage() && get(this.packageJSON, 'ember-addon.version') === 2;\n  }\n\n  isV2App(): this is V2AppPackage {\n    return this.isV2Ember() && this.packageJSON['ember-addon'].type === 'app';\n  }\n\n  isV2Addon(): this is V2AddonPackage {\n    return this.isV2Ember() && this.packageJSON['ember-addon'].type === 'addon';\n  }\n\n  findDescendants(filter?: (pkg: Package) => boolean): Package[] {\n    let pkgs = new Set<Package>();\n    let queue: Package[] = [this];\n    while (true) {\n      let pkg = queue.shift();\n      if (!pkg) {\n        break;\n      }\n      if (!pkgs.has(pkg)) {\n        pkgs.add(pkg);\n        let nextLevel;\n        if (filter) {\n          nextLevel = pkg.dependencies.filter(filter);\n        } else {\n          nextLevel = pkg.dependencies;\n        }\n        nextLevel.forEach(d => queue.push(d));\n      }\n    }\n    pkgs.delete(this);\n    return [...pkgs.values()];\n  }\n\n  get mayRebuild(): boolean {\n    // if broccoli memoization is enabled, allowing addons to rebuild\n    // automatically is cheap, so we allow all addons to rebuild.\n    if (process.env['BROCCOLI_ENABLED_MEMOIZE'] === 'true') {\n      return true;\n    }\n\n    // Otherwise, we only allow addons to rebuild that you've explicitly asked for\n    // via env var.\n    if (process.env.EMBROIDER_REBUILD_ADDONS) {\n      if (process.env.EMBROIDER_REBUILD_ADDONS.split(',').includes(this.name)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  @Memoize()\n  get nonResolvableDeps(): Map<string, Package> | undefined {\n    let meta = this.internalPackageJSON['ember-addon'];\n    if (meta && meta.paths) {\n      return new Map(\n        meta.paths\n          .map((path: string) => {\n            // ember-cli gives a warning if the path specifies an invalid, malformed or missing addon. the logic for invalidating an addon is:\n            // https://github.com/ember-cli/ember-cli/blob/627934f91b2aa0e19b041fdb1b547873c1855793/lib/models/package-info-cache/index.js#L427\n            //\n            // Note that we only need to be this lenient with in-repo addons,\n            // which is why this logic is here in nonResolvableDeps. If you try\n            // to ship broken stuff in regular dependencies, NPM is going to\n            // stop you.\n            let pkg, main;\n            try {\n              pkg = this.packageCache.get(join(this.packageCache.basedir(this), path));\n              main = pkg.packageJSON['ember-addon']?.main || pkg.packageJSON['main'];\n            } catch (err) {\n              // package was missing or had invalid package.json\n              return false;\n            }\n\n            if (!main || main === '.' || main === './') {\n              main = 'index.js';\n            } else if (!extname(main)) {\n              main = `${main}.js`;\n            }\n\n            let mainPath = join(this.packageCache.basedir(this), path, main);\n            if (!existsSync(mainPath)) {\n              // package has no valid main\n              return false;\n            }\n            return [pkg.name, pkg];\n          })\n          .filter(Boolean)\n      );\n    }\n  }\n\n  @Memoize()\n  get dependencies(): Package[] {\n    let names = flatMap(this.dependencyKeys, key => Object.keys(this.packageJSON[key] || {}));\n    return names\n      .map(name => {\n        if (this.nonResolvableDeps) {\n          let dep = this.nonResolvableDeps.get(name);\n          if (dep) {\n            return dep;\n          }\n        }\n        try {\n          return this.packageCache.resolve(name, this);\n        } catch (error) {\n          // if the package was not found do not error out here. this is relevant\n          // for the case where a package might be an optional peerDependency and we dont\n          // want to error if it was not found. Additionally, erroring here is \"far\" away\n          // from the actual logical failure point and so not failing here will provide a better\n          // error message down the line\n          if (error.code === 'MODULE_NOT_FOUND') {\n            return false;\n          }\n\n          throw error;\n        }\n      })\n      .filter(Boolean) as Package[];\n  }\n\n  hasDependency(name: string): boolean {\n    for (let section of this.dependencyKeys) {\n      if (this.packageJSON[section]) {\n        if ((this.packageJSON[section] as Record<string, string>)[name]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n\nexport interface PackageConstructor {\n  new (root: string, mayUseDevDeps: boolean, packageCache: PackageCache): Package;\n}\n\nexport interface V2Package extends Package {\n  meta: AddonMeta | AppMeta;\n}\n\nexport interface V2AddonPackage extends Package {\n  meta: AddonMeta;\n}\n\nexport interface V2AppPackage extends Package {\n  meta: AppMeta;\n}\n"]}