"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const _1 = require(".");
const babel_import_util_1 = require("babel-import-util");
function setComponentTemplate(target, state) {
    return state.adder.import(target, '@ember/component', 'setComponentTemplate');
}
function main(babel) {
    let t = babel.types;
    return {
        visitor: {
            Program: {
                enter(path, state) {
                    state.adder = new babel_import_util_1.ImportUtil(t, path);
                    let filename = path.hub.file.opts.filename;
                    if (state.opts.packageGuard) {
                        let owningPackage = _1.PackageCache.shared('embroider-stage3', state.opts.appRoot).ownerOfFile(filename);
                        if (!owningPackage || !owningPackage.isV2Ember() || !owningPackage.meta['auto-upgraded']) {
                            return;
                        }
                    }
                    let hbsFilename = filename.replace(/\.\w{1,3}$/, '') + '.hbs';
                    if (hbsFilename !== filename && (0, fs_1.existsSync)(hbsFilename)) {
                        state.colocatedTemplate = hbsFilename;
                    }
                },
                exit(path, state) {
                    if (state.associate) {
                        path.node.body.push(t.expressionStatement(t.callExpression(setComponentTemplate(path, state), [
                            state.associate.template,
                            state.associate.component,
                        ])));
                    }
                },
            },
            ExportDefaultDeclaration(path, state) {
                var _a;
                let template = getTemplate(path, state);
                if (!template) {
                    return;
                }
                let declaration = path.get('declaration').node;
                if (t.isClassDeclaration(declaration)) {
                    if (declaration.id != null) {
                        state.associate = { template, component: declaration.id };
                    }
                    else {
                        path.node.declaration = t.callExpression(setComponentTemplate(path, state), [
                            template,
                            t.classExpression(null, declaration.superClass, declaration.body, (_a = declaration.decorators) !== null && _a !== void 0 ? _a : []),
                        ]);
                    }
                }
                else if (t.isFunctionDeclaration(declaration)) {
                    if (declaration.id != null) {
                        state.associate = { template, component: declaration.id };
                    }
                    else {
                        path.node.declaration = t.callExpression(setComponentTemplate(path, state), [
                            template,
                            t.functionExpression(null, declaration.params, declaration.body, declaration.generator, declaration.async),
                        ]);
                    }
                }
                else if (t.isTSDeclareFunction(declaration)) {
                    // we don't rewrite this
                }
                else {
                    path.node.declaration = t.callExpression(setComponentTemplate(path, state), [template, declaration]);
                }
            },
            ExportNamedDeclaration(path, state) {
                let template = getTemplate(path, state);
                if (!template) {
                    return;
                }
                let { node } = path;
                for (let specifier of path.node.specifiers) {
                    if (t.isExportDefaultSpecifier(specifier)) {
                    }
                    else if (t.isExportSpecifier(specifier)) {
                        const name = specifier.exported.type === 'Identifier' ? specifier.exported.name : specifier.exported.value;
                        if (name === 'default') {
                            if (node.source) {
                                // our default export is a reexport from elsewhere. We will
                                // synthesize a new import for it so we can get a local handle
                                // on it
                                let component = state.adder.import(path, node.source.value, specifier.local.name, 'COMPONENT');
                                state.associate = { template, component };
                            }
                            else {
                                // our default export is one of our local names
                                state.associate = { template, component: t.identifier(specifier.local.name) };
                            }
                        }
                    }
                }
            },
        },
    };
}
exports.default = main;
function getTemplate(target, state) {
    if (state.colocatedTemplate) {
        return state.adder.import(target, (0, _1.explicitRelative)((0, path_1.dirname)(state.colocatedTemplate), state.colocatedTemplate), 'default', 'TEMPLATE');
    }
}
//# sourceMappingURL=template-colocation-plugin.js.map