{"version":3,"file":"template-colocation-plugin.js","sourceRoot":"","sources":["template-colocation-plugin.ts"],"names":[],"mappings":"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","sourcesContent":["import type { NodePath } from '@babel/traverse';\nimport { existsSync } from 'fs';\nimport type * as Babel from '@babel/core';\nimport type { types as t } from '@babel/core';\nimport { dirname } from 'path';\nimport { explicitRelative, PackageCache } from '.';\nimport { ImportUtil } from 'babel-import-util';\n\n// these options are designed so the defaults are appropriate for use within an\n// addon's dev pipeline, whereas when we use it within Embroider we diverge from\n// the defaults. That means less options for addon authors to need to know\n// about.\nexport interface Options {\n  // Defaults to false.\n  //\n  // When true, we will only apply changes to components that are owned by\n  // packages that are auto-upgraded v2 ember packages. When false, we apply\n  // changes to whatever we see.\n  //\n  // This option is used by Embroider itself to help with compatibility, other\n  // users should probably not use it.\n  packageGuard?: boolean;\n\n  appRoot: string;\n}\n\ninterface State {\n  colocatedTemplate: string | undefined;\n  associate: { component: t.Identifier; template: t.Identifier } | undefined;\n  adder: ImportUtil;\n  opts: Options;\n}\n\nfunction setComponentTemplate(target: NodePath<t.Node>, state: State) {\n  return state.adder.import(target, '@ember/component', 'setComponentTemplate');\n}\n\nexport default function main(babel: typeof Babel) {\n  let t = babel.types;\n  return {\n    visitor: {\n      Program: {\n        enter(path: NodePath<t.Program>, state: State) {\n          state.adder = new ImportUtil(t, path);\n          let filename = path.hub.file.opts.filename;\n\n          if (state.opts.packageGuard) {\n            let owningPackage = PackageCache.shared('embroider-stage3', state.opts.appRoot).ownerOfFile(filename);\n            if (!owningPackage || !owningPackage.isV2Ember() || !owningPackage.meta['auto-upgraded']) {\n              return;\n            }\n          }\n\n          let hbsFilename = filename.replace(/\\.\\w{1,3}$/, '') + '.hbs';\n          if (hbsFilename !== filename && existsSync(hbsFilename)) {\n            state.colocatedTemplate = hbsFilename;\n          }\n        },\n        exit(path: NodePath<t.Program>, state: State) {\n          if (state.associate) {\n            path.node.body.push(\n              t.expressionStatement(\n                t.callExpression(setComponentTemplate(path, state), [\n                  state.associate.template,\n                  state.associate.component,\n                ])\n              )\n            );\n          }\n        },\n      },\n\n      ExportDefaultDeclaration(path: NodePath<t.ExportDefaultDeclaration>, state: State) {\n        let template = getTemplate(path, state);\n        if (!template) {\n          return;\n        }\n\n        let declaration = path.get('declaration').node;\n\n        if (t.isClassDeclaration(declaration)) {\n          if (declaration.id != null) {\n            state.associate = { template, component: declaration.id };\n          } else {\n            path.node.declaration = t.callExpression(setComponentTemplate(path, state), [\n              template,\n              t.classExpression(null, declaration.superClass, declaration.body, declaration.decorators ?? []),\n            ]);\n          }\n        } else if (t.isFunctionDeclaration(declaration)) {\n          if (declaration.id != null) {\n            state.associate = { template, component: declaration.id };\n          } else {\n            path.node.declaration = t.callExpression(setComponentTemplate(path, state), [\n              template,\n              t.functionExpression(\n                null,\n                declaration.params,\n                declaration.body,\n                declaration.generator,\n                declaration.async\n              ),\n            ]);\n          }\n        } else if (t.isTSDeclareFunction(declaration)) {\n          // we don't rewrite this\n        } else {\n          path.node.declaration = t.callExpression(setComponentTemplate(path, state), [template, declaration]);\n        }\n      },\n      ExportNamedDeclaration(path: NodePath<t.ExportNamedDeclaration>, state: State) {\n        let template = getTemplate(path, state);\n        if (!template) {\n          return;\n        }\n        let { node } = path;\n        for (let specifier of path.node.specifiers) {\n          if (t.isExportDefaultSpecifier(specifier)) {\n          } else if (t.isExportSpecifier(specifier)) {\n            const name = specifier.exported.type === 'Identifier' ? specifier.exported.name : specifier.exported.value;\n\n            if (name === 'default') {\n              if (node.source) {\n                // our default export is a reexport from elsewhere. We will\n                // synthesize a new import for it so we can get a local handle\n                // on it\n                let component = state.adder.import(path, node.source.value, specifier.local.name, 'COMPONENT');\n                state.associate = { template, component };\n              } else {\n                // our default export is one of our local names\n                state.associate = { template, component: t.identifier(specifier.local.name) };\n              }\n            }\n          }\n        }\n      },\n    },\n  };\n}\n\nfunction getTemplate(target: NodePath<t.Node>, state: State) {\n  if (state.colocatedTemplate) {\n    return state.adder.import(\n      target,\n      explicitRelative(dirname(state.colocatedTemplate), state.colocatedTemplate),\n      'default',\n      'TEMPLATE'\n    );\n  }\n}\n"]}