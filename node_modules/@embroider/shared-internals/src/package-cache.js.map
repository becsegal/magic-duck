{"version":3,"file":"package-cache.js","sourceRoot":"","sources":["package-cache.ts"],"names":[],"mappings":"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","sourcesContent":["import Package from './package';\nimport { existsSync, realpathSync } from 'fs';\nimport { getOrCreate } from './get-or-create';\nimport resolvePackagePath from 'resolve-package-path';\nimport { dirname, sep } from 'path';\n\nexport default class PackageCache {\n  constructor(public appRoot: string) {}\n\n  resolve(packageName: string, fromPackage: Package): Package {\n    let cache = getOrCreate(this.resolutionCache, fromPackage, () => new Map() as Map<string, Package | null>);\n    let result = getOrCreate(cache, packageName, () => {\n      // the type cast is needed because resolvePackagePath itself is erroneously typed as `any`.\n      let packagePath = resolvePackagePath(packageName, this.basedir(fromPackage)) as string | null;\n      if (!packagePath) {\n        // this gets our null into the cache so we don't keep trying to resolve\n        // a thing that is not found\n        return null;\n      }\n      return this.get(dirname(packagePath));\n    });\n    if (!result) {\n      let e = new Error(`unable to resolve package ${packageName} from ${fromPackage.root}`);\n      (e as any).code = 'MODULE_NOT_FOUND';\n      throw e;\n    }\n    return result;\n  }\n\n  seed(pkg: Package) {\n    if (this.rootCache.has(pkg.root)) {\n      throw new Error(`bug: tried to seed package ${pkg.name} but it's already in packageCache`);\n    }\n    this.rootCache.set(pkg.root, pkg);\n  }\n\n  protected rootCache: Map<string, Package> = new Map();\n  protected resolutionCache: Map<Package, Map<string, Package | null>> = new Map();\n\n  basedir(pkg: Package): string {\n    return pkg.root;\n  }\n\n  get(packageRoot: string) {\n    let root = realpathSync(packageRoot);\n    let p = getOrCreate(this.rootCache, root, () => {\n      return new Package(root, this, root === this.appRoot);\n    });\n    return p;\n  }\n\n  ownerOfFile(filename: string): Package | undefined {\n    let segments = filename.split(sep);\n\n    // first we look through our cached packages for any that are rooted right\n    // at or above the file.\n    for (let length = segments.length; length >= 0; length--) {\n      if (segments[length - 1] === 'node_modules') {\n        // once we hit a node_modules, we're leaving the package we were in, so\n        // any higher caches don't apply to us\n        break;\n      }\n\n      let usedSegments = segments.slice(0, length);\n      let candidate = usedSegments.join(sep);\n      if (this.rootCache.has(candidate)) {\n        return this.rootCache.get(candidate);\n      }\n      if (existsSync([...usedSegments, 'package.json'].join(sep))) {\n        return this.get(candidate);\n      }\n    }\n  }\n\n  // register to be shared as the per-process package cache with the given name\n  shareAs(identifier: string) {\n    shared.set(identifier, this);\n  }\n\n  static shared(identifier: string, appRoot: string) {\n    return getOrCreate(shared, identifier, () => new PackageCache(appRoot));\n  }\n}\n\nconst shared: Map<string, PackageCache> = new Map();\n"]}