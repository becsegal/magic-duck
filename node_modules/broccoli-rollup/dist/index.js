"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BroccoliRollup = void 0;
const BroccoliPlugin = require("broccoli-plugin");
const fs_1 = require("fs");
const path = require("path");
const symlink_or_copy_1 = require("symlink-or-copy");
const rollup_helper_1 = require("./rollup-helper");
const utils_1 = require("./utils");
function rollup(node, options) {
    return new BroccoliRollup(node, options);
}
exports.default = rollup;
class BroccoliRollup extends BroccoliPlugin {
    constructor(node, options) {
        super([node], {
            annotation: options.annotation,
            name: options.name,
            persistentOutput: true,
        });
        this.rollupOptions = options.rollup;
        this.cache =
            options.rollup.cache === false ? false : options.cache !== false;
        this._rollupHelper = undefined;
        if (options.nodeModulesPath !== undefined &&
            !path.isAbsolute(options.nodeModulesPath)) {
            throw new Error(`nodeModulesPath must be fully qualified and you passed a relative path`);
        }
        this.nodeModulesPath =
            options.nodeModulesPath || utils_1.nodeModulesPath(process.cwd());
    }
    async build() {
        let rollupHelper = this._rollupHelper;
        if (rollupHelper === undefined) {
            if (this.nodeModulesPath) {
                symlink_or_copy_1.sync(this.nodeModulesPath, `${this.cachePath}/node_modules`);
            }
            const buildPath = `${this.cachePath}/build`;
            fs_1.mkdirSync(buildPath);
            rollupHelper = this._rollupHelper = new rollup_helper_1.default(this.inputPaths[0], buildPath, this.outputPath, this.rollupOptions, utils_1.normalizeArray(this.rollupOptions.output), this.cache);
        }
        await rollupHelper.build();
    }
}
exports.BroccoliRollup = BroccoliRollup;
//# sourceMappingURL=index.js.map