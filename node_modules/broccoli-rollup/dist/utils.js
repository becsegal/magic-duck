"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nodeModulesPath = exports.normalizeArray = exports.treeFromEntries = exports.treeFromPath = exports.normalize = exports.realpath = exports.writeFile = exports.syncFiles = void 0;
const crypto_1 = require("crypto");
const fs_1 = require("fs");
const FSTree = require("fs-tree-diff");
const path_1 = require("path");
const walkSync = require("walk-sync");
function syncFiles(src, dest, changes, digests) {
    changes.forEach(change => {
        const op = change[0];
        const relativePath = change[1];
        const entry = change[2];
        switch (op) {
            case 'mkdir':
                fs_1.mkdirSync(`${dest}/${relativePath}`);
                break;
            case 'unlink':
                fs_1.unlinkSync(`${dest}/${relativePath}`);
                if (digests !== undefined) {
                    digests.delete(relativePath);
                }
                break;
            case 'rmdir':
                fs_1.rmdirSync(`${dest}/${relativePath}`);
                break;
            case 'create':
            case 'change':
                // mtime is a Date for FSEntry
                writeFile(src, dest, entry, digests);
                break;
        }
    });
}
exports.syncFiles = syncFiles;
function writeFile(src, dest, entry, digests) {
    const relativePath = entry.relativePath;
    const content = fs_1.readFileSync(`${src}/${relativePath}`);
    if (!shouldWrite(relativePath, content, digests)) {
        return;
    }
    const fd = fs_1.openSync(`${dest}/${relativePath}`, 'w', entry.mode);
    try {
        let offset = 0;
        let length = content.byteLength;
        while (length > 0) {
            const written = fs_1.writeSync(fd, content, offset, length);
            offset += written;
            length -= written;
        }
        const mtime = new Date(entry.mtime);
        fs_1.futimesSync(fd, mtime, mtime);
    }
    finally {
        fs_1.closeSync(fd);
    }
}
exports.writeFile = writeFile;
function realpath(path) {
    return normalize(fs_1.realpathSync(path));
}
exports.realpath = realpath;
function normalize(path) {
    if (path_1.sep !== '/') {
        return path.split(path_1.sep).join('/');
    }
    return path;
}
exports.normalize = normalize;
function shouldWrite(relativePath, content, digests) {
    if (digests === undefined) {
        return true;
    }
    const oldDigest = digests.get(relativePath);
    const newDigest = crypto_1.createHash('md5')
        .update(content)
        .digest('hex') + content.byteLength;
    digests.set(relativePath, newDigest);
    return newDigest !== oldDigest;
}
function treeFromPath(path) {
    return treeFromEntries(walkSync.entries(path));
}
exports.treeFromPath = treeFromPath;
function treeFromEntries(entries, options) {
    const tree = new FSTree();
    tree.addEntries(entries, options);
    return tree;
}
exports.treeFromEntries = treeFromEntries;
function normalizeArray(arr) {
    return Array.isArray(arr) ? arr : [arr];
}
exports.normalizeArray = normalizeArray;
// tslint:disable:no-var-requires
exports.nodeModulesPath = require('node-modules-path');
// tslint:enable:no-var-requires
//# sourceMappingURL=utils.js.map