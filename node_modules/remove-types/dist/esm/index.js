import { transformAsync, createConfigItem } from '@babel/core';
import { format } from 'prettier';
import bts from '@babel/plugin-transform-typescript';
const babelTsTransform = createConfigItem(bts);
import bsd from '@babel/plugin-syntax-decorators';
const babelDecoratorSyntax = createConfigItem([bsd, { legacy: true }]);
export async function removeTypes(code, prettierConfig = true) {
    code = code.replace(/\n\n+/g, '/* ___NEWLINE___ */\n');
    const removeComments = {
        enter(nodePath) {
            if (!nodePath.node.leadingComments)
                return;
            for (let i = nodePath.node.leadingComments.length - 1; i >= 0; i--) {
                const comment = nodePath.node.leadingComments[i];
                if (code.slice(comment.end).match(/^\s*\n\s*\n/) ||
                    comment.value.includes('___NEWLINE___')) {
                    break;
                }
                comment.value = '___REMOVE_ME___';
            }
        },
    };
    const transformed = await transformAsync(code, {
        plugins: [
            {
                name: 'comment-remover',
                visitor: {
                    TSTypeAliasDeclaration: removeComments,
                    TSInterfaceDeclaration: removeComments,
                    TSDeclareFunction: removeComments,
                    TSDeclareMethod: removeComments,
                    TSImportType: removeComments,
                    TSModuleDeclaration: removeComments,
                },
            },
            babelTsTransform,
            babelDecoratorSyntax,
        ],
        generatorOpts: {
            retainLines: true,
            shouldPrintComment: (comment) => comment !== '___REMOVE_ME___',
        },
    });
    if (!transformed || !transformed.code) {
        throw new Error('There was an issue with the Babel transform.');
    }
    const fixed = transformed.code.replace(/\/\* ___NEWLINE___ \*\//g, '\n');
    if (prettierConfig === false) {
        return fixed;
    }
    const standardPrettierOptions = {
        parser: 'babel',
        singleQuote: true,
    };
    if (prettierConfig === true) {
        return format(fixed, standardPrettierOptions);
    }
    const mergedPrettierOptions = {
        ...standardPrettierOptions,
        ...prettierConfig,
    };
    return format(fixed, mergedPrettierOptions);
}
export default removeTypes;
//# sourceMappingURL=index.js.map